<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>The Limitations of 'Secure' SSRF Patches: Advanced Bypasses and Defense-in-Depth | Code Before Breach</title>
<meta name=keywords content="ssrf,security,defense,web"><meta name=description content="A deep dive into why common SSRF defense code is often incomplete, real-world bypasses, and practical, layered mitigation strategies for developers and security engineers."><meta name=author content><link rel=canonical href=https://windshock.github.io/en/post/2025-06-25-ssrf-defense/><link href="https://fonts.googleapis.com/css2?family=Spectral:wght@400;700&display=swap" rel=stylesheet><link rel=alternate type=application/rss+xml title=RSS href=https://windshock.github.io/index.xml><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://windshock.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://windshock.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://windshock.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://windshock.github.io/apple-touch-icon.png><link rel=mask-icon href=https://windshock.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://windshock.github.io/en/post/2025-06-25-ssrf-defense/><link rel=alternate hreflang=ko href=https://windshock.github.io/ko/post/2025-06-25-ssrf-defense/><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/swiper@11/swiper-bundle.min.css><script defer src=https://cdn.jsdelivr.net/npm/swiper@11/swiper-bundle.min.js></script><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6N6EEJ259T"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6N6EEJ259T")}</script><meta property="og:url" content="https://windshock.github.io/en/post/2025-06-25-ssrf-defense/"><meta property="og:site_name" content="Code Before Breach"><meta property="og:title" content="The Limitations of 'Secure' SSRF Patches: Advanced Bypasses and Defense-in-Depth"><meta property="og:description" content="A deep dive into why common SSRF defense code is often incomplete, real-world bypasses, and practical, layered mitigation strategies for developers and security engineers."><meta property="og:locale" content="en-US"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-06-25T00:00:00+00:00"><meta property="article:modified_time" content="2025-06-25T00:00:00+00:00"><meta property="article:tag" content="Ssrf"><meta property="article:tag" content="Security"><meta property="article:tag" content="Defense"><meta property="article:tag" content="Web"><meta name=twitter:card content="summary"><meta name=twitter:title content="The Limitations of 'Secure' SSRF Patches: Advanced Bypasses and Defense-in-Depth"><meta name=twitter:description content="A deep dive into why common SSRF defense code is often incomplete, real-world bypasses, and practical, layered mitigation strategies for developers and security engineers."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://windshock.github.io/en/post/"},{"@type":"ListItem","position":2,"name":"The Limitations of 'Secure' SSRF Patches: Advanced Bypasses and Defense-in-Depth","item":"https://windshock.github.io/en/post/2025-06-25-ssrf-defense/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"The Limitations of 'Secure' SSRF Patches: Advanced Bypasses and Defense-in-Depth","name":"The Limitations of \u0027Secure\u0027 SSRF Patches: Advanced Bypasses and Defense-in-Depth","description":"A deep dive into why common SSRF defense code is often incomplete, real-world bypasses, and practical, layered mitigation strategies for developers and security engineers.","keywords":["ssrf","security","defense","web"],"articleBody":" No Silver Bullet: Folklore \u0026 Modern Meaning\nThe phrase ‚Äúno silver bullet‚Äù originated in European folklore, where silver bullets were believed to be uniquely effective against supernatural creatures like werewolves or vampires. The earliest documented use appears in Walter Scott‚Äôs 1816 Tales of My Landlord, and historical cases such as the 1765 Beast of G√©vaudan reference silver bullets as a last resort against mysterious threats. Over time, the expression evolved: today, ‚Äúno silver bullet‚Äù means there is no single, simple solution to complex problems‚Äîa message popularized in software engineering by Fred Brooks‚Äô 1986 essay. This post applies that lesson to SSRF defense: beware of one-size-fits-all fixes, and look deeper than folklore or quick patches.\nThe Limitations of ‚ÄúSecure‚Äù SSRF Patches: Advanced Bypasses and Defense-in-Depth Introduction: Understanding SSRF and Its Risks Server-Side Request Forgery (SSRF) is a web vulnerability that allows an attacker to trick a server into making HTTP requests to unintended locations. In a typical SSRF attack, the adversary supplies a URL or address that the server-side code fetches ‚Äì but instead of fetching an expected external resource, the server is coerced into contacting internal services or protected endpoints not normally accessible to the attacker. This can lead to serious consequences: attackers may scan internal networks, access database endpoints, or retrieve cloud instance metadata (like AWS EC2 tokens) by exploiting SSRF. It‚Äôs no surprise SSRF has earned a spot in the OWASP Top 10 (2021) and is a growing concern for developers.\n‚ÄúJust use startsWith('https://trusted.com') to block SSRF!‚Äù\n‚Äî Common advice on StackOverflow (that fails in practice)\nBecause of its severity, many developers reach for quick patch methods to fix SSRF vulnerabilities. But as the quote above shows, well-intentioned advice often leads to incomplete or bypassable defenses. A quick search online yields plenty of code snippets and StackOverflow answers claiming to ‚Äúfix‚Äù SSRF by filtering URLs, enforcing domain allowlists, etc. In theory, these patches intend to restrict outgoing requests to safe targets. In practice, however, many commonly shared SSRF fixes are incomplete‚Äîthey cover basic cases but don‚Äôt hold up against advanced bypass techniques.\nIn this post, you‚Äôll learn:\nWhy ‚Äúsecure‚Äù SSRF patches often fail in real-world scenarios How attackers bypass naive defenses with creative payloads How to build robust, layered SSRF defenses in Node.js (Express + Axios) Practical test strategies and a hands-on SSRF Defense Lab By the end, you‚Äôll know how to spot incomplete SSRF fixes, understand advanced bypass tricks, and implement defense-in-depth that holds up under real attack. Security requires continuous testing and iterative hardening‚Äîbut with the right approach, you can stay a step ahead of attackers.\nCommon SSRF Patch Methods (and Why They Fall Short) Developers under pressure to patch an SSRF bug often implement quick solutions that seem to work. Some of the most common SSRF mitigation patterns include:\nAllowlisting by URL Prefix or Hostname Substring ‚Äì e.g. only fetch URLs that start with a specific domain. Basic Hostname Validation ‚Äì e.g. parse the user-supplied URL and ensure the hostname equals an expected value. Blocking Private IP Address Ranges by String ‚Äì e.g. reject any URLs containing 127.0.0.1 or localhost. Filtering Schemes ‚Äì e.g. only allow http:// or https:// URLs, and block others (FTP, file, etc.). Not Following Redirects ‚Äì or so one hopes (some fixes assume no redirects without enforcing it). Superficial Checks for Malicious Patterns ‚Äì e.g. disallow file:// in the URL, or attempts to sniff out hex/encoded IPs in the string. On paper, these measures sound reasonable. In practice, attackers have developed numerous tricks to evade such filters. Let‚Äôs examine a few pitfalls in naive SSRF defenses and how exploiters get around them:\n1. Na√Øve Domain Allowlisting via Prefix Matching One common approach is to allow requests only to a specific trusted domain or base URL. The code might do something like:\n// ‚ùå Vulnerable SSRF check (naive allowlist by prefix) if (!userUrl.startsWith(allowedBaseUrl)) { throw new Error(\"URL not allowed\"); } This looks straightforward ‚Äì if the user-provided URL doesn‚Äôt begin with say, https://trusted.example.com, the request is blocked. The problem: string matching on URLs can be easily fooled by crafty URL formatting. Attackers often exploit the @ notation in URLs to bypass such checks. In an HTTP URL, anything before an @ symbol is treated as user credentials (userinfo) for authentication, and the actual host comes after the @. For example:\nIntended safe URL: https://trusted.example.com/path/file.txt Malicious URL using @: https://trusted.example.com@evil.attacker-site.com/path/file.txt At a glance, the malicious URL starts with https://trusted.example.com, so a naive startsWith() check passes. However, the true hostname of this URL is evil.attacker-site.com (the portion after the @). The prefix trusted.example.com is simply interpreted as a username by the URL parser. As a result, the server will actually perform the request to the attacker‚Äôs domain, not the trusted domain ‚Äì a successful SSRF bypass.\nReal-world case study: The open-source ChatGPT-Next-Web project once implemented an SSRF fix using a prefix allowlist for certain API endpoints. It checked that user-supplied URLs began with allowed host prefixes (e.g. a list of trusted WebDAV service URLs). Security researchers discovered this was insufficient. Because the code didn‚Äôt enforce a delimiter after the allowed domain, an attacker could append an allowed prefix onto a malicious domain string. For example, if https://webdav.yandex.com was allowed, an attacker could use https://webdav.yandex.com.attacker.tld/evil ‚Äì which passes the .startsWith() check but actually points to attacker.tld. In ChatGPT-Next-Web‚Äôs case, this loophole enabled arbitrary HTTPS requests to attacker-controlled servers despite the allowlist ‚Äúfix.‚Äù In short, simple prefix checks can be trivially bypassed by including the trusted string in a larger malicious hostname.\n2. Shallow Hostname Validation and Subdomain Tricks A slightly better approach is to actually parse the URL and inspect the hostname. For example, using Node‚Äôs url.parse() or the WHATWG URL API, one might extract the hostname and compare it to an allowlist:\nconst parsed = new URL(userUrl); if (parsed.hostname !== \"trusted.example.com\") { throw new Error(\"Hostname not allowed\"); } This fixes the @ issue ‚Äì since parsed.hostname of https://trusted.example.com@evil.com would correctly yield evil.com. However, developers must still be careful: string comparison of hostnames has its own edge cases. Consider subdomains and lookalikes. If the intention is to allow only a specific host, you should ensure exact match (or a well-defined pattern). Attackers can register malicious domains that include or mimic allowed names. For instance:\nAllowed host: api.mycompany.com Attacker registers: api.mycompany.com.evil.org (a subdomain of evil.org). A check that naively does endsWith(\"api.mycompany.com\") or contains that string could be fooled. Even checking for .mycompany.com could be tricked by a domain like really-trusted.mycompany.com.evil.org. The ChatGPT-Next-Web exploit above is a prime example of subdomain prefix abuse. The lesson is to anchor your host validation ‚Äì e.g., ensure the entire hostname matches an allowlist entry, or if subdomains of an allowed domain are acceptable, use strict suffix matching that accounts for dot boundaries (like *.example.com but not example.com.evil.com).\nAnother often-overlooked aspect is DNS resolution: Just because a URL‚Äôs hostname looks legitimate doesn‚Äôt mean it will resolve to the expected IP. In a DNS rebinding scenario, an attacker controls a domain and can manipulate its DNS responses. Your server might check parsed.hostname against an allowlist of, say, attacker‚Äôs domain (which obviously won‚Äôt be in the allowlist). But consider if the allowlist is for external hosts only (to block internal IPs) ‚Äì an attacker‚Äôs domain could resolve to a private IP after initial validation. For example, a filter might allow any hostname that resolves to a public IP, using a function like is_external(host). The attacker‚Äôs domain could initially resolve to a benign public IP for the check, then a second DNS query (when the request is made) returns 127.0.0.1. If the code isn‚Äôt carefully using the same resolved result, this DNS rebinding can route a seemingly external hostname to internal resources. Proper mitigations involve resolving the hostname to an IP once and validating that IP (and perhaps even forcing the request to that IP), or performing continuous checks if multiple connections occur.\nFinally, watch out for alternative IP notations. If your code blocks explicit localhost strings or literal 127.0.0.1, an attacker might supply 2130706433 (which is 0x7F000001 in decimal ‚Äì the same loopback IP in a different form) or even an IPv6 loopback ::1. Any robust solution should normalize and validate addresses, not rely solely on string matching for IPs.\n3. Inadequate Redirect Handling HTTP redirection can completely undermine SSRF filters that don‚Äôt account for it. Many HTTP client libraries (Axios, requests, etc.) follow redirects automatically by default. That means your backend might fetch a URL that responds with a 301/302 redirect, and the client will transparently fetch the new location. If your SSRF defense only checks the initial URL, an attacker can easily bounce the request through an intermediate site.\nFor example, suppose your application only allows downloading from https://cdn.safe-files.com. An attacker finds that cdn.safe-files.com (or an allowed domain) has an open redirect vulnerability, or they use a purpose-built redirect service like 302.r3dir.me. The attacker crafts a URL to the allowed domain that immediately redirects to a malicious or internal address. Your code sees the allowed domain in the request URL and permits it, but then the server follows the redirect to the forbidden target. By the time the dust settles, your server has made a call to the internal resource ‚Äì SSRF success.\nA practical demonstration of this uses the service 302.r3dir.me, which is designed to aid SSRF testing by redirecting to a target provided in the URL query. Imagine the target is the AWS EC2 metadata URL http://169.254.169.254/latest/meta-data/iam/security-credentials/. An attacker could submit:\nhttps://your-allowed-cdn.com@302.r3dir.me/--to/?url=http://169.254.169.254/latest/meta-data/iam/ This single URL incorporates both the @ trick (to satisfy a naive prefix check) and a redirect to the internal AWS metadata service. If the server follows it, the response will be AWS credentials from the metadata! In our example test suite, a similar payload https://cdn.example.com@302.r3dir.me/--to/?url=http://intranet.com/ was used to simulate a redirect-based bypass. Without proper safeguards, such a request would slip past an allowlist and hit the final target. Indeed, it‚Äôs been noted that using 302.r3dir.me (or a custom redirect server) can bypass poorly implemented SSRF defenses, granting access to internal networks and metadata endpoints.\nTo make matters worse, scheme enforcement can be bypassed via redirects as well. Some developers try to allow only https:// URLs for extra safety (to avoid cleartext or other protocols). But if redirects aren‚Äôt controlled, an attacker can start with an https:// URL that later redirects to an http:// URL. Many HTTP libraries will follow an HTTPS-to-HTTP redirect unless explicitly configured not to. As Leviathan Security researchers pointed out, this trick enables attackers to ultimately reach internal HTTP services (which many backend systems and cloud metadata endpoints use) even if the initial URL was HTTPS. Without a redirect limit, your ‚ÄúHTTPS-only‚Äù rule might only apply to the first hop ‚Äì after that, all bets are off.\n4. Other Advanced Bypass Techniques Beyond the big three (prefix tricks, subdomain exploits, and redirects), there are other creative ways SSRF filters have been bypassed:\nMixed IP/Domain Formats: Some browsers/clients allow URLs like http://127.0.0.1.xip.io or http://[::ffff:127.0.0.1]. These appear as hostnames or IPv6, but effectively point to IPv4 localhost. If a filter isn‚Äôt comprehensive (e.g., only checks for ‚Äú127.0.0.1‚Äù literal), these can sneak through. HTTP Headers Injection (Less Common): In rare cases, if user input is directly concatenated into an HTTP request, an attacker might insert header delimiters to alter the request. This is more of an input parsing flaw than SSRF bypass per se, but it underscores the need to use proper libraries for requests. Alternate Schemes (Gopher, File): Although most SSRF patches focus on HTTP/HTTPS, remember that if your request function supports other schemes, an attacker might use file:// to read files or gopher:// for tricky interactions. Many SSRF exploits of the past used gopher to poke at internal memcached or other services. Ensuring you only allow the protocols you intend is vital (and usually that‚Äôs just HTTP/HTTPS for web apps). In summary, many of the ‚Äúsimple‚Äù SSRF fixes found online do not account for these edge cases. A patch might block obvious malicious URLs but still be bypassable by an imaginative attacker. As developers, we have to think like attackers when designing validations. Next, we‚Äôll look at how to build a more robust SSRF defense step by step, using Node.js as an example.\nBuilding a Robust SSRF Defense (Node.js Example) To truly fix SSRF, a single check is not enough. You‚Äôll want to validate the request URL at multiple layers and use secure library features to avoid mistakes. Let‚Äôs walk through a hardened approach using Node.js (Express + Axios), incorporating the lessons from above.\nBelow is an example of secure coding for a file download endpoint that only allows files from a specific CDN domain. This approach uses URL parsing, an allowlist, interceptors, and strict request options to mitigate SSRF:\nimport axios from \"axios\"; import { URL } from \"url\"; import express from \"express\"; const R = express.Router(); const ALLOWED_HOSTS = [\"cdn.example.com\"]; // Whitelisted hostname(s) // Create an Axios instance with a short timeout const downloader = axios.create({ timeout: 10000 }); // Attach a request interceptor to enforce URL policies downloader.interceptors.request.use(config =\u003e { const u = new URL(config.url, config.baseURL); // Enforce HTTPS protocol and allowed hostname if (u.protocol !== \"https:\" || !ALLOWED_HOSTS.includes(u.hostname)) { return Promise.reject(new Error(`Blocked hostname: ${u.hostname}`)); } return config; }); R.get(\"/file-proxy/download\", async (req, res) =\u003e { const url = req.query.url; const fname = req.query.file_name; if (!url || !fname) { return res.status(400).send(\"Missing parameters\"); } try { const resp = await downloader.get(url, { responseType: \"stream\", maxRedirects: 0, // Disallow redirects //validateStatus: status =\u003e status \u003c 400 // Treat 3xx as success (so we catch them manually) }); // Set download headers res.setHeader(\"Content-Disposition\", `attachment; filename=${encodeURIComponent(fname)}`); res.setHeader(\"Content-Type\", resp.headers[\"content-type\"] || \"application/octet-stream\"); // Pipe the response stream directly to the client resp.data.pipe(res); } catch (e) { console.error(\"Blocked or failed download:\", e.message); res.status(400).send(\"Invalid or forbidden URL\"); } }); Let‚Äôs break down how this implementation counters the earlier bypass techniques:\nURL Parsing and Host Allowlist: We use Node‚Äôs standard URL constructor to parse the requested URL (new URL(config.url)). This ensures we correctly identify the components of the URL. By checking u.protocol and u.hostname, we eliminate confusion around tricky formats. For example, u.hostname for https://cdn.cloudfront.net@evil.com/... will be evil.com, so the interceptor will reject it. We only allow hostnames explicitly listed in ALLOWED_HOSTS. In this case, the only allowed host is the specific CloudFront domain we trust. If an attacker tries any other host (including subdomains or lookalikes), the request is blocked before it is even sent.\nHTTPS-Only Enforcement: The interceptor also checks u.protocol !== \"https:\" and rejects anything that isn‚Äôt HTTPS. This means no http:// (preventing downgrade attacks) and no weird schemes like file:// ‚Äì they‚Äôll be blocked immediately. One thing to note: by itself this HTTPS check could be bypassed by an HTTPS URL that redirects to HTTP (as discussed earlier). That‚Äôs why we also set maxRedirects: 0 on the request ‚Äì to prevent any protocol change via redirect.\nDisabling Redirects: Setting maxRedirects: 0 tells Axios not to follow redirects at all. If the response is a 302 or other redirect, Axios will return it directly without chasing the Location. In our code, we treat any HTTP status \u003e= 300 as an error (by using a custom validateStatus that only considers \u003c400 as okay). This way, a redirect from the allowed host to an unallowed host is caught: the allowed host responded with a redirect, but we didn‚Äôt follow it ‚Äì instead we throw an error and return ‚ÄúInvalid URL.‚Äù This intercepts the scenario of using an open redirect or r3dir.me. In our test, for example, if cdn.example.com tried to redirect to evil.com, our server would not follow; we‚Äôd catch it and respond with 400. Note: In some cases, you might allow a limited number of redirects but need to validate each hop ‚Äì that gets complicated fast. It‚Äôs safer to disallow redirects for user-supplied URLs unless absolutely necessary.\nCentralized Enforcement via Interceptor: By using an Axios request interceptor, we ensure the policy is applied consistently for every request made with that downloader instance. This is better than scattering checks around or relying on developers to always call a validation function. It‚Äôs a form of defense-in-depth in code ‚Äì even if someone forgets to do a manual check before calling downloader.get(), the interceptor will kick in. It also makes the code cleaner in the route handler ‚Äì we simply call downloader.get(url) and know that the interceptor will block any disallowed URL upfront.\nTimeout and Error Handling: While not directly an SSRF bypass issue, we set a reasonable timeout (10 seconds here) on the Axios instance to avoid hanging on slow or non-responsive endpoints. We also gracefully handle errors: any thrown error (be it from our interceptor or the request itself) results in a 400 response to the client and logs an error. The error message can indicate why it was blocked (e.g., ‚ÄúBlocked hostname: evil.com‚Äù), which can be useful in detecting attacks in logs, but be careful not to leak too much detail to end-users.\nContent Considerations: In this snippet, after a successful response, we pipe the content out as a download (attachment; filename=...). We trust the allowed source to provide legitimate content. If additional validation of the content type or size is needed (for example, ensure it‚Äôs actually a PDF or under certain size), that can be added before piping. The primary focus here is on securing the request against SSRF exploits.\nWith the above measures in place, our Express endpoint would have passed the earlier test cases that defeated the naive implementation. The startsWith-based filter was bypassable with @ and open redirects; our new implementation isn‚Äôt, because it checks the true hostname and disallows redirects entirely. In fact, using a nearly identical test suite:\nWhitelisted domain allowed: A normal URL to the allowed CDN succeeds (status 200 OK). @ redirect payload blocked: The malicious ...cloudfront.net@302.r3dir.me/... URL is rejected with a 400 and logged (our interceptor sees hostname = 302.r3dir.me, which is not allowed). Direct external domain blocked: A URL to https://evil.com/... is immediately blocked by hostname check (not in allowlist). Allowed host redirecting to evil blocked: If the allowed CDN tries to redirect (we simulate with a 302 via nock in testing), the request is not followed and we return 400. By using proper URL parsing and enforcing policies at the HTTP client level, we‚Äôve significantly reduced the SSRF risk. But we‚Äôre not done yet ‚Äì truly secure SSRF defense means multiple layers of checks.\nDefense-in-Depth: Additional Safeguards The code-level protections above are a strong start. However, savvy attackers might still look for gaps, especially in complex real-world environments. Here are additional defense-in-depth measures that you (and your security team) should consider:\nValidate DNS Resolution and IP Ranges: Even after hostname allowlisting, it‚Äôs wise to double-check where the domain resolves to. For instance, ensure the IP address of the allowed host is in a range you expect. If your server is running in a cloud environment, be mindful that some cloud hostnames could resolve to internal IPs. Implement a DNS lookup and verify the resulting IP is not a private/internal address (RFC1918 ranges, localhost, link-local, etc.) before making the request. This prevents scenarios where an allowed domain is hijacked or a DNS rebinding tricks the server into targeting an internal IP. Many languages have libraries or functions (like Python‚Äôs ipaddress module or Golang‚Äôs net package) to check if an IP is in a private network. In Node, you might use dns.promises.lookup and then inspect the IP. Be cautious to do the lookup and request in a way that avoids race conditions (the interceptor approach above could be extended with a custom DNS resolver that filters IPs).\nNetwork Egress Filtering (CIDR Allow/Deny Lists): Don‚Äôt rely solely on application code to enforce SSRF protection. Network-level controls can provide a safety net. For example, if your service should only call a specific external API or CDN, configure firewall rules or a cloud security group to block all other outbound requests. Many cloud providers and container orchestration platforms allow egress restrictions. A Web Application Firewall (WAF) or API gateway can also be configured with rules to prevent traffic to internal IP ranges, adding another layer of defense beyond the app logic.\nLimit Allowed Ports and Protocols: If your use-case is only to fetch HTTP/S on standard ports, consider restricting that. An SSRF attacker may try to hit non-HTTP services (like http://target:22/ to check an SSH server banner, or other ports for port scanning). Your HTTP client might not speak those protocols, but even connecting can yield information. You can often specify allowed ports or disallow non-80/443 in your allowlist policy. Some frameworks let you enforce this in the URL parser (for example, by checking u.port or requiring u.port is blank or 443/80 if https/http). Similarly, ensure only http and https schemes ‚Äì no ftp:, no file: ‚Äì are ever accepted.\nLogging and Alerting: Treat SSRF attempt logs as high-severity events. In our code above, we do console.error logging when a download is blocked. In production, you‚Äôd want to funnel such logs to a monitoring system. If you see repeated ‚ÄúBlocked hostname: 169.254.169.254‚Äù or the like, that‚Äôs a red flag someone is probing for SSRF. Set up alerts for these patterns. Comprehensive access logs that include the requested URL (or at least the domain) can help incident response trace what an attacker tried to do. Remember that sometimes SSRF is blind (the attacker doesn‚Äôt get the response directly), so they might be fuzzing your endpoint and watching side-effects. Good logging might be your only clue something is amiss.\nSecurity Testing and Automation: Given the myriad ways to bypass SSRF filters, it‚Äôs important to continuously test your defenses. Incorporate SSRF test cases into your QA or CI/CD pipeline. For example, the test suite we showed earlier programmatically tries an @ payload and an open redirect to ensure the server returns 400, not 200. You can leverage security scanning tools or write unit tests for your validation logic. Static analysis can help too ‚Äì for instance, using Semgrep or CodeQL queries to detect any use of dangerous patterns (like raw axios.get(userInput) without validation). Organizations should also perform periodic penetration testing. Tools like Burp Suite have SSRF payload lists and can automate trying dozens of variants (encoded IPs, etc.) against your endpoints. Make sure your ‚Äúsafe‚Äù code actually holds up against these.\nKeep Dependencies and Knowledge Updated: The ecosystem around SSRF is evolving. New bypass tricks get discovered (for example, novel URL parsing quirks in different languages or odd behavior in cloud metadata services). Stay updated on security advisories ‚Äì for instance, the nossrf npm package was created to prevent SSRF, but even it had a critical bypass discovered. Always use the latest patched versions of any libraries or packages related to URL fetching, and review their changelogs for security fixes. And of course, never disable critical protections like certificate verification on your HTTP client ‚Äì doing so could let an attacker intercept your ‚Äúsafe‚Äù requests or present fake certificates.\nIn essence, defense-in-depth means assuming one layer of defense could fail, so you have others to mitigate the impact. We saw how relying just on a prefix check failed; combining hostname + protocol + redirect controls in the code made it much harder to bypass. Adding network rules and continuous testing makes it harder still. The more hurdles an attacker has to jump through, the more likely they‚Äôll give up or slip up and get detected.\nConclusion: Never Trust a ‚ÄúOne-Size-Fits-All‚Äù SSRF Fix There is no silver bullet.\nNot in folklore. Not in security. Security isn‚Äôt a one-liner ‚Äî it‚Äôs a process: Think. Test. Break. Fix. Repeat.\nSSRF vulnerabilities teach us a broader lesson in software security: beware of silver-bullet fixes. If you find a code snippet online claiming ‚Äújust do X to fix SSRF‚Äù without accounting for edge cases, be skeptical. We‚Äôve highlighted how even widely suggested or ‚Äúsecure‚Äù patches can be incomplete ‚Äì from ChatGPT-Next-Web‚Äôs initial fix being bypassed to the simple allowlist that failed against @ and redirect tricks. Attackers think outside the box, so our defenses must as well.\nSSRF Defense Lab: Practical Testbed Looking to verify your SSRF defenses in practice? Check out the open-source SSRF Defense Lab I created:\nüß™ Minimal, self-contained Node.js/Express testbed for SSRF security üîß Secure and vulnerable router examples with real bypass test cases üõ†Ô∏è Automated test utilities for CDN/domain allowlisting, redirect bypass, and more üìã All tests must pass for a router to be considered secure Project highlights:\nReusable SSRF security test utilities Secure/vulnerable router code and tests Covers common bypasses: @ tricks, open redirects, non-whitelisted domains Easy to run: npm install \u0026\u0026 npm test Source \u0026 docs: github.com/windshock/ssrf-defense-lab\nFor developers and security engineers, the key takeaways are:\nKey Takeaways Always validate and sanitize user-controlled URLs. Rely on proven libraries for parsing‚Äînever trust raw string checks. Layer your defenses. Combine hostname allowlists, protocol checks, DNS/IP validation, and strict redirect handling. Test like an attacker. Challenge your own defenses with real-world bypass payloads and automated tests. Adopt defense-in-depth. Use both application logic and network-layer controls to reduce risk and monitor for abuse. Stay ahead of new tricks. Security is never finished‚Äîkeep learning, updating, and adapting. Preventing SSRF isn‚Äôt about a single fix‚Äîit‚Äôs about building resilient, layered defenses and never letting your guard down. Be proactive: review, test, and challenge your solutions regularly. If you don‚Äôt, someone else surely will. Secure by design, and let your defenses grow stronger with every lesson learned.\nReferences Bypassing SSRF Filters Using r3dir ‚Äî Leviathan Security Server-side request forgery (Wikipedia) Silver Bullet ‚Äì Archive.org Snyk Blog: Preventing SSRF in Node.js GitHub Patch (NextChat) NextChat SSRF Advisory (GitHub) SSRF Defense Lab (GitHub) ","wordCount":"4260","inLanguage":"en","datePublished":"2025-06-25T00:00:00Z","dateModified":"2025-06-25T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://windshock.github.io/en/post/2025-06-25-ssrf-defense/"},"publisher":{"@type":"Organization","name":"Code Before Breach","logo":{"@type":"ImageObject","url":"https://windshock.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://windshock.github.io/en/ accesskey=h title="Code Before Breach (Alt + H)"><img src=https://windshock.github.io/images/logo-terminal-animated.svg alt aria-label=logo class="h-7 w-auto" height=28>Code Before Breach</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://windshock.github.io/ko/ title=ÌïúÍµ≠Ïñ¥ aria-label=ÌïúÍµ≠Ïñ¥>Ko</a></li></ul></div></div><ul id=menu><li><a href=https://windshock.github.io/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://windshock.github.io/en/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://windshock.github.io/en/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://windshock.github.io/en/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://windshock.github.io/en/about/ title=About><span>About</span></a></li><li><a href=https://windshock.github.io/en/index.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://windshock.github.io/en/>Home</a>&nbsp;¬ª&nbsp;<a href=https://windshock.github.io/en/post/>Posts</a></div><h1 class="post-title entry-hint-parent">The Limitations of 'Secure' SSRF Patches: Advanced Bypasses and Defense-in-Depth</h1><div class=post-description>A deep dive into why common SSRF defense code is often incomplete, real-world bypasses, and practical, layered mitigation strategies for developers and security engineers.</div><div class=post-meta><span title='2025-06-25 00:00:00 +0000 UTC'>June 25, 2025</span>&nbsp;¬∑&nbsp;20 min&nbsp;¬∑&nbsp;4260 words&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://windshock.github.io/ko/post/2025-06-25-ssrf-defense/>Ko</a></li></ul></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#the-limitations-of-secure-ssrf-patches-advanced-bypasses-and-defense-in-depth aria-label="The Limitations of ‚ÄúSecure‚Äù SSRF Patches: Advanced Bypasses and Defense-in-Depth">The Limitations of ‚ÄúSecure‚Äù SSRF Patches: Advanced Bypasses and Defense-in-Depth</a><ul><li><a href=#introduction-understanding-ssrf-and-its-risks aria-label="Introduction: Understanding SSRF and Its Risks">Introduction: Understanding SSRF and Its Risks</a></li><li><a href=#common-ssrf-patch-methods-and-why-they-fall-short aria-label="Common SSRF Patch Methods (and Why They Fall Short)">Common SSRF Patch Methods (and Why They Fall Short)</a><ul><li><a href=#1-na%c3%afve-domain-allowlisting-via-prefix-matching aria-label="1. Na√Øve Domain Allowlisting via Prefix Matching">1. Na√Øve Domain Allowlisting via Prefix Matching</a></li><li><a href=#2-shallow-hostname-validation-and-subdomain-tricks aria-label="2. Shallow Hostname Validation and Subdomain Tricks">2. Shallow Hostname Validation and Subdomain Tricks</a></li><li><a href=#3-inadequate-redirect-handling aria-label="3. Inadequate Redirect Handling">3. Inadequate Redirect Handling</a></li><li><a href=#4-other-advanced-bypass-techniques aria-label="4. Other Advanced Bypass Techniques">4. Other Advanced Bypass Techniques</a></li></ul></li><li><a href=#building-a-robust-ssrf-defense-nodejs-example aria-label="Building a Robust SSRF Defense (Node.js Example)">Building a Robust SSRF Defense (Node.js Example)</a></li><li><a href=#defense-in-depth-additional-safeguards aria-label="Defense-in-Depth: Additional Safeguards">Defense-in-Depth: Additional Safeguards</a></li><li><a href=#conclusion-never-trust-a-one-size-fits-all-ssrf-fix aria-label="Conclusion: Never Trust a ‚ÄúOne-Size-Fits-All‚Äù SSRF Fix">Conclusion: Never Trust a ‚ÄúOne-Size-Fits-All‚Äù SSRF Fix</a></li><li><a href=#ssrf-defense-lab-practical-testbed aria-label="SSRF Defense Lab: Practical Testbed">SSRF Defense Lab: Practical Testbed</a></li><li><a href=#key-takeaways aria-label="Key Takeaways">Key Takeaways</a></li><li><a href=#references aria-label=References>References</a></li></ul></li></ul></div></details></div><div class=post-content><blockquote><p><strong>No Silver Bullet: Folklore & Modern Meaning</strong></p><p>The phrase &ldquo;no silver bullet&rdquo; originated in European folklore, where silver bullets were believed to be uniquely effective against supernatural creatures like werewolves or vampires. The earliest documented use appears in Walter Scott&rsquo;s 1816 <em>Tales of My Landlord</em>, and historical cases such as the 1765 Beast of G√©vaudan reference silver bullets as a last resort against mysterious threats. Over time, the expression evolved: today, &ldquo;no silver bullet&rdquo; means there is no single, simple solution to complex problems‚Äîa message popularized in software engineering by Fred Brooks&rsquo; 1986 essay. This post applies that lesson to SSRF defense: beware of one-size-fits-all fixes, and look deeper than folklore or quick patches.</p></blockquote><h1 id=the-limitations-of-secure-ssrf-patches-advanced-bypasses-and-defense-in-depth>The Limitations of ‚ÄúSecure‚Äù SSRF Patches: Advanced Bypasses and Defense-in-Depth<a hidden class=anchor aria-hidden=true href=#the-limitations-of-secure-ssrf-patches-advanced-bypasses-and-defense-in-depth>#</a></h1><h2 id=introduction-understanding-ssrf-and-its-risks>Introduction: Understanding SSRF and Its Risks<a hidden class=anchor aria-hidden=true href=#introduction-understanding-ssrf-and-its-risks>#</a></h2><p>Server-Side Request Forgery (SSRF) is a web vulnerability that allows an attacker to trick a server into making HTTP requests to unintended locations. In a typical SSRF attack, the adversary supplies a URL or address that the server-side code fetches ‚Äì but instead of fetching an expected external resource, the server is coerced into contacting internal services or protected endpoints not normally accessible to the attacker. This can lead to <em>serious</em> consequences: attackers may scan internal networks, access database endpoints, or retrieve cloud instance metadata (like AWS EC2 tokens) by exploiting SSRF. It‚Äôs no surprise SSRF has earned a spot in the OWASP Top 10 (2021) and is a growing concern for developers.</p><blockquote><p>‚ÄúJust use <code>startsWith('https://trusted.com')</code> to block SSRF!‚Äù<br>‚Äî Common advice on StackOverflow (that fails in practice)</p></blockquote><p>Because of its severity, many developers reach for quick patch methods to fix SSRF vulnerabilities. But as the quote above shows, well-intentioned advice often leads to incomplete or bypassable defenses. A quick search online yields plenty of code snippets and StackOverflow answers claiming to <strong>‚Äúfix‚Äù SSRF</strong> by filtering URLs, enforcing domain allowlists, etc. In theory, these patches intend to restrict outgoing requests to safe targets. In practice, however, <strong>many commonly shared SSRF fixes are incomplete</strong>‚Äîthey cover basic cases but <strong>don‚Äôt hold up against advanced bypass techniques</strong>.</p><p><strong>In this post, you‚Äôll learn:</strong></p><ul><li>Why ‚Äúsecure‚Äù SSRF patches often fail in real-world scenarios</li><li>How attackers bypass naive defenses with creative payloads</li><li>How to build robust, layered SSRF defenses in Node.js (Express + Axios)</li><li>Practical test strategies and a hands-on SSRF Defense Lab</li></ul><p>By the end, you‚Äôll know how to spot incomplete SSRF fixes, understand advanced bypass tricks, and implement defense-in-depth that holds up under real attack. Security requires continuous testing and iterative hardening‚Äîbut with the right approach, you can stay a step ahead of attackers.</p><h2 id=common-ssrf-patch-methods-and-why-they-fall-short>Common SSRF Patch Methods (and Why They Fall Short)<a hidden class=anchor aria-hidden=true href=#common-ssrf-patch-methods-and-why-they-fall-short>#</a></h2><p>Developers under pressure to patch an SSRF bug often implement quick solutions that <em>seem</em> to work. Some of the most common SSRF mitigation patterns include:</p><ul><li><strong>Allowlisting by URL Prefix or Hostname Substring</strong> ‚Äì e.g. only fetch URLs that start with a specific domain.</li><li><strong>Basic Hostname Validation</strong> ‚Äì e.g. parse the user-supplied URL and ensure the hostname equals an expected value.</li><li><strong>Blocking Private IP Address Ranges by String</strong> ‚Äì e.g. reject any URLs containing <code>127.0.0.1</code> or <code>localhost</code>.</li><li><strong>Filtering Schemes</strong> ‚Äì e.g. only allow <code>http://</code> or <code>https://</code> URLs, and block others (FTP, file, etc.).</li><li><strong>Not Following Redirects</strong> ‚Äì or so one hopes (some fixes <em>assume</em> no redirects without enforcing it).</li><li><strong>Superficial Checks for Malicious Patterns</strong> ‚Äì e.g. disallow <code>file://</code> in the URL, or attempts to sniff out hex/encoded IPs in the string.</li></ul><p>On paper, these measures sound reasonable. In practice, <strong>attackers have developed numerous tricks to evade such filters</strong>. Let‚Äôs examine a few pitfalls in naive SSRF defenses and how exploiters get around them:</p><h3 id=1-na√Øve-domain-allowlisting-via-prefix-matching>1. Na√Øve Domain Allowlisting via Prefix Matching<a hidden class=anchor aria-hidden=true href=#1-na√Øve-domain-allowlisting-via-prefix-matching>#</a></h3><p>One common approach is to allow requests only to a specific trusted domain or base URL. The code might do something like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#75715e>// ‚ùå Vulnerable SSRF check (naive allowlist by prefix)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>userUrl</span>.<span style=color:#a6e22e>startsWith</span>(<span style=color:#a6e22e>allowedBaseUrl</span>)) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error(<span style=color:#e6db74>&#34;URL not allowed&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This looks straightforward ‚Äì if the user-provided URL doesn‚Äôt begin with say, <code>https://trusted.example.com</code>, the request is blocked. <strong>The problem</strong>: string matching on URLs can be easily fooled by crafty URL formatting. Attackers often exploit the <strong><code>@</code> notation</strong> in URLs to bypass such checks. In an HTTP URL, anything before an <code>@</code> symbol is treated as user credentials (userinfo) for authentication, and the actual host comes <strong>after</strong> the <code>@</code>. For example:</p><ul><li><strong>Intended safe URL:</strong> <code>https://trusted.example.com/path/file.txt</code></li><li><strong>Malicious URL using <code>@</code>:</strong> <code>https://trusted.example.com@evil.attacker-site.com/path/file.txt</code></li></ul><p>At a glance, the malicious URL <em>starts with</em> <code>https://trusted.example.com</code>, so a naive <code>startsWith()</code> check passes. However, the true hostname of this URL is <code>evil.attacker-site.com</code> (the portion after the <code>@</code>). The prefix <code>trusted.example.com</code> is simply interpreted as a username by the URL parser. As a result, the server will actually perform the request to the attacker‚Äôs domain, not the trusted domain ‚Äì a successful SSRF bypass.</p><p>Real-world case study: The open-source <strong>ChatGPT-Next-Web</strong> project once implemented an SSRF fix using a prefix allowlist for certain API endpoints. It checked that user-supplied URLs began with allowed host prefixes (e.g. a list of trusted WebDAV service URLs). Security researchers discovered this was insufficient. Because the code didn‚Äôt enforce a delimiter after the allowed domain, an attacker could append an allowed prefix onto a malicious domain string. For example, if <code>https://webdav.yandex.com</code> was allowed, an attacker could use <code>https://webdav.yandex.com.attacker.tld/evil</code> ‚Äì which passes the <code>.startsWith()</code> check but actually points to <code>attacker.tld</code>. In ChatGPT-Next-Web‚Äôs case, this loophole enabled arbitrary HTTPS requests to attacker-controlled servers despite the allowlist ‚Äúfix.‚Äù In short, simple prefix checks can be <strong>trivially bypassed</strong> by including the trusted string in a larger malicious hostname.</p><h3 id=2-shallow-hostname-validation-and-subdomain-tricks>2. Shallow Hostname Validation and Subdomain Tricks<a hidden class=anchor aria-hidden=true href=#2-shallow-hostname-validation-and-subdomain-tricks>#</a></h3><p>A slightly better approach is to actually parse the URL and inspect the hostname. For example, using Node‚Äôs <code>url.parse()</code> or the WHATWG <code>URL</code> API, one might extract the hostname and compare it to an allowlist:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>parsed</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>URL</span>(<span style=color:#a6e22e>userUrl</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>parsed</span>.<span style=color:#a6e22e>hostname</span> <span style=color:#f92672>!==</span> <span style=color:#e6db74>&#34;trusted.example.com&#34;</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error(<span style=color:#e6db74>&#34;Hostname not allowed&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This fixes the <code>@</code> issue ‚Äì since <code>parsed.hostname</code> of <code>https://trusted.example.com@evil.com</code> would correctly yield <code>evil.com</code>. However, developers must still be careful: <em>string comparison of hostnames</em> has its own edge cases. Consider subdomains and lookalikes. If the intention is to allow only a specific host, you should ensure <strong>exact</strong> match (or a well-defined pattern). Attackers can register malicious domains that include or mimic allowed names. For instance:</p><ul><li>Allowed host: <code>api.mycompany.com</code></li><li>Attacker registers: <code>api.mycompany.com.evil.org</code> (a subdomain of <code>evil.org</code>).</li></ul><p>A check that naively does <code>endsWith("api.mycompany.com")</code> or contains that string could be fooled. Even checking for <code>.mycompany.com</code> could be tricked by a domain like <code>really-trusted.mycompany.com.evil.org</code>. The ChatGPT-Next-Web exploit above is a prime example of subdomain prefix abuse. The lesson is to <strong>anchor your host validation</strong> ‚Äì e.g., ensure the entire hostname matches an allowlist entry, or if subdomains of an allowed domain are acceptable, use strict suffix matching that accounts for dot boundaries (like <code>*.example.com</code> but not <code>example.com.evil.com</code>).</p><p>Another often-overlooked aspect is <strong>DNS resolution</strong>: Just because a URL‚Äôs hostname looks legitimate doesn‚Äôt mean it will resolve to the expected IP. In a DNS rebinding scenario, an attacker controls a domain and can manipulate its DNS responses. Your server might check <code>parsed.hostname</code> against an allowlist of, say, attacker‚Äôs domain (which obviously won‚Äôt be in the allowlist). But consider if the allowlist is for <em>external</em> hosts only (to block internal IPs) ‚Äì an attacker‚Äôs domain could resolve to a private IP after initial validation. For example, a filter might allow any hostname that resolves to a public IP, using a function like <code>is_external(host)</code>. The attacker‚Äôs domain could initially resolve to a benign public IP for the check, then a second DNS query (when the request is made) returns <code>127.0.0.1</code>. If the code isn‚Äôt carefully using the same resolved result, this <strong>DNS rebinding</strong> can route a seemingly external hostname to internal resources. Proper mitigations involve resolving the hostname to an IP <strong>once</strong> and validating that IP (and perhaps even forcing the request to that IP), or performing continuous checks if multiple connections occur.</p><p>Finally, watch out for <strong>alternative IP notations</strong>. If your code blocks explicit localhost strings or literal <code>127.0.0.1</code>, an attacker might supply <code>2130706433</code> (which is <code>0x7F000001</code> in decimal ‚Äì the same loopback IP in a different form) or even an IPv6 loopback <code>::1</code>. Any robust solution should normalize and validate addresses, not rely solely on string matching for IPs.</p><h3 id=3-inadequate-redirect-handling>3. Inadequate Redirect Handling<a hidden class=anchor aria-hidden=true href=#3-inadequate-redirect-handling>#</a></h3><p><strong>HTTP redirection can completely undermine SSRF filters</strong> that don‚Äôt account for it. Many HTTP client libraries (Axios, requests, etc.) follow redirects automatically by default. That means your backend might fetch a URL that responds with a 301/302 redirect, and the client will transparently fetch the new location. If your SSRF defense only checks the <em>initial</em> URL, an attacker can easily bounce the request through an intermediate site.</p><p>For example, suppose your application only allows downloading from <code>https://cdn.safe-files.com</code>. An attacker finds that <code>cdn.safe-files.com</code> (or an allowed domain) has an <strong>open redirect</strong> vulnerability, or they use a purpose-built redirect service like <code>302.r3dir.me</code>. The attacker crafts a URL to the allowed domain that immediately redirects to a malicious or internal address. Your code sees the allowed domain in the request URL and permits it, but then the server follows the redirect to the forbidden target. <strong>By the time the dust settles, your server has made a call to the internal resource</strong> ‚Äì SSRF success.</p><p>A practical demonstration of this uses the service <strong><code>302.r3dir.me</code></strong>, which is designed to aid SSRF testing by redirecting to a target provided in the URL query. Imagine the target is the AWS EC2 metadata URL <code>http://169.254.169.254/latest/meta-data/iam/security-credentials/</code>. An attacker could submit:</p><pre tabindex=0><code>https://your-allowed-cdn.com@302.r3dir.me/--to/?url=http://169.254.169.254/latest/meta-data/iam/
</code></pre><p>This single URL incorporates both the <code>@</code> trick (to satisfy a naive prefix check) and a redirect to the internal AWS metadata service. If the server follows it, the response will be AWS credentials from the metadata! In our example test suite, a similar payload <code>https://cdn.example.com@302.r3dir.me/--to/?url=http://intranet.com/</code> was used to simulate a redirect-based bypass. Without proper safeguards, such a request would slip past an allowlist and hit the final target. Indeed, it‚Äôs been noted that using <code>302.r3dir.me</code> (or a custom redirect server) can bypass poorly implemented SSRF defenses, granting access to internal networks and metadata endpoints.</p><p>To make matters worse, <strong>scheme enforcement can be bypassed via redirects as well</strong>. Some developers try to allow only <code>https://</code> URLs for extra safety (to avoid cleartext or other protocols). But if redirects aren‚Äôt controlled, an attacker can start with an <code>https://</code> URL that later redirects to an <code>http://</code> URL. Many HTTP libraries will follow an HTTPS-to-HTTP redirect unless explicitly configured not to. As Leviathan Security researchers pointed out, this trick enables attackers to ultimately reach internal HTTP services (which many backend systems and cloud metadata endpoints use) even if the initial URL was HTTPS. Without a redirect limit, your ‚ÄúHTTPS-only‚Äù rule might only apply to the first hop ‚Äì after that, all bets are off.</p><h3 id=4-other-advanced-bypass-techniques>4. Other Advanced Bypass Techniques<a hidden class=anchor aria-hidden=true href=#4-other-advanced-bypass-techniques>#</a></h3><p>Beyond the big three (prefix tricks, subdomain exploits, and redirects), there are other creative ways SSRF filters have been bypassed:</p><ul><li><strong>Mixed IP/Domain Formats:</strong> Some browsers/clients allow URLs like <code>http://127.0.0.1.xip.io</code> or <code>http://[::ffff:127.0.0.1]</code>. These appear as hostnames or IPv6, but effectively point to IPv4 localhost. If a filter isn‚Äôt comprehensive (e.g., only checks for ‚Äú127.0.0.1‚Äù literal), these can sneak through.</li><li><strong>HTTP Headers Injection (Less Common):</strong> In rare cases, if user input is directly concatenated into an HTTP request, an attacker might insert header delimiters to alter the request. This is more of an input parsing flaw than SSRF bypass per se, but it underscores the need to use proper libraries for requests.</li><li><strong>Alternate Schemes (Gopher, File)</strong>: Although most SSRF patches focus on HTTP/HTTPS, remember that if your request function supports other schemes, an attacker might use <code>file://</code> to read files or <code>gopher://</code> for tricky interactions. Many SSRF exploits of the past used gopher to poke at internal memcached or other services. Ensuring you <strong>only allow the protocols you intend</strong> is vital (and usually that‚Äôs just HTTP/HTTPS for web apps).</li></ul><p>In summary, <em>many of the ‚Äúsimple‚Äù SSRF fixes found online do not account for these edge cases</em>. A patch might block obvious malicious URLs but still be bypassable by an imaginative attacker. As developers, we have to think like attackers when designing validations. Next, we‚Äôll look at how to build a <strong>more robust SSRF defense</strong> step by step, using Node.js as an example.</p><h2 id=building-a-robust-ssrf-defense-nodejs-example>Building a Robust SSRF Defense (Node.js Example)<a hidden class=anchor aria-hidden=true href=#building-a-robust-ssrf-defense-nodejs-example>#</a></h2><p>To truly fix SSRF, a <strong>single check is not enough</strong>. You‚Äôll want to validate the request URL at multiple layers and use secure library features to avoid mistakes. Let‚Äôs walk through a hardened approach using <strong>Node.js (Express + Axios)</strong>, incorporating the lessons from above.</p><p>Below is an example of secure coding for a file download endpoint that only allows files from a specific CDN domain. This approach uses URL parsing, an allowlist, interceptors, and strict request options to mitigate SSRF:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>axios</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#34;axios&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>URL</span> } <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#34;url&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>express</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#34;express&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>R</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>express</span>.<span style=color:#a6e22e>Router</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>ALLOWED_HOSTS</span> <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#34;cdn.example.com&#34;</span>];  <span style=color:#75715e>// Whitelisted hostname(s)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Create an Axios instance with a short timeout
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>downloader</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>axios</span>.<span style=color:#a6e22e>create</span>({ <span style=color:#a6e22e>timeout</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>10000</span> });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Attach a request interceptor to enforce URL policies
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>downloader</span>.<span style=color:#a6e22e>interceptors</span>.<span style=color:#a6e22e>request</span>.<span style=color:#a6e22e>use</span>(<span style=color:#a6e22e>config</span> =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>u</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>URL</span>(<span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>url</span>, <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>baseURL</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Enforce HTTPS protocol and allowed hostname
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>u</span>.<span style=color:#a6e22e>protocol</span> <span style=color:#f92672>!==</span> <span style=color:#e6db74>&#34;https:&#34;</span> <span style=color:#f92672>||</span> <span style=color:#f92672>!</span><span style=color:#a6e22e>ALLOWED_HOSTS</span>.<span style=color:#a6e22e>includes</span>(<span style=color:#a6e22e>u</span>.<span style=color:#a6e22e>hostname</span>)) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Promise.<span style=color:#a6e22e>reject</span>(<span style=color:#66d9ef>new</span> Error(<span style=color:#e6db74>`Blocked hostname: </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>u</span>.<span style=color:#a6e22e>hostname</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>config</span>;
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>R</span>.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#34;/file-proxy/download&#34;</span>, <span style=color:#66d9ef>async</span> (<span style=color:#a6e22e>req</span>, <span style=color:#a6e22e>res</span>) =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>url</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>query</span>.<span style=color:#a6e22e>url</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>fname</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>query</span>.<span style=color:#a6e22e>file_name</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>url</span> <span style=color:#f92672>||</span> <span style=color:#f92672>!</span><span style=color:#a6e22e>fname</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>status</span>(<span style=color:#ae81ff>400</span>).<span style=color:#a6e22e>send</span>(<span style=color:#e6db74>&#34;Missing parameters&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>resp</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>downloader</span>.<span style=color:#a6e22e>get</span>(<span style=color:#a6e22e>url</span>, {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>responseType</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;stream&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>maxRedirects</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>,               <span style=color:#75715e>// Disallow redirects 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>//validateStatus: status =&gt; status &lt; 400  // Treat 3xx as success (so we catch them manually)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        });
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Set download headers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>setHeader</span>(<span style=color:#e6db74>&#34;Content-Disposition&#34;</span>, <span style=color:#e6db74>`attachment; filename=</span><span style=color:#e6db74>${</span>encodeURIComponent(<span style=color:#a6e22e>fname</span>)<span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>setHeader</span>(<span style=color:#e6db74>&#34;Content-Type&#34;</span>, <span style=color:#a6e22e>resp</span>.<span style=color:#a6e22e>headers</span>[<span style=color:#e6db74>&#34;content-type&#34;</span>] <span style=color:#f92672>||</span> <span style=color:#e6db74>&#34;application/octet-stream&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Pipe the response stream directly to the client
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>resp</span>.<span style=color:#a6e22e>data</span>.<span style=color:#a6e22e>pipe</span>(<span style=color:#a6e22e>res</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (<span style=color:#a6e22e>e</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#34;Blocked or failed download:&#34;</span>, <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>message</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>status</span>(<span style=color:#ae81ff>400</span>).<span style=color:#a6e22e>send</span>(<span style=color:#e6db74>&#34;Invalid or forbidden URL&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>Let‚Äôs break down how this implementation counters the earlier bypass techniques:</p><ul><li><p><strong>URL Parsing and Host Allowlist:</strong> We use Node‚Äôs standard <code>URL</code> constructor to parse the requested URL (<code>new URL(config.url)</code>). This ensures we correctly identify the components of the URL. By checking <code>u.protocol</code> and <code>u.hostname</code>, we eliminate confusion around tricky formats. For example, <code>u.hostname</code> for <code>https://cdn.cloudfront.net@evil.com/...</code> will be <code>evil.com</code>, so the interceptor will reject it. We only allow hostnames explicitly listed in <code>ALLOWED_HOSTS</code>. In this case, the only allowed host is the specific CloudFront domain we trust. If an attacker tries any other host (including subdomains or lookalikes), the request is blocked before it is even sent.</p></li><li><p><strong>HTTPS-Only Enforcement:</strong> The interceptor also checks <code>u.protocol !== "https:"</code> and rejects anything that isn‚Äôt HTTPS. This means no <code>http://</code> (preventing downgrade attacks) and no weird schemes like <code>file://</code> ‚Äì they‚Äôll be blocked immediately. One thing to note: by itself this HTTPS check could be bypassed by an HTTPS URL that redirects to HTTP (as discussed earlier). That‚Äôs why we also set <code>maxRedirects: 0</code> on the request ‚Äì to prevent <em>any</em> protocol change via redirect.</p></li><li><p><strong>Disabling Redirects:</strong> Setting <code>maxRedirects: 0</code> tells Axios <strong>not to follow redirects</strong> at all. If the response is a 302 or other redirect, Axios will return it directly without chasing the Location. In our code, we treat any HTTP status >= 300 as an error (by using a custom <code>validateStatus</code> that only considers &lt;400 as okay). This way, a redirect from the allowed host to an unallowed host is caught: the allowed host responded with a redirect, but we didn‚Äôt follow it ‚Äì instead we throw an error and return ‚ÄúInvalid URL.‚Äù This intercepts the scenario of using an open redirect or r3dir.me. In our test, for example, if <code>cdn.example.com</code> tried to redirect to <code>evil.com</code>, our server would <em>not</em> follow; we‚Äôd catch it and respond with 400. <strong>Note:</strong> In some cases, you might allow a limited number of redirects but need to validate each hop ‚Äì that gets complicated fast. It‚Äôs safer to disallow redirects for user-supplied URLs unless absolutely necessary.</p></li><li><p><strong>Centralized Enforcement via Interceptor:</strong> By using an Axios request interceptor, we ensure the policy is applied consistently for every request made with that <code>downloader</code> instance. This is better than scattering checks around or relying on developers to always call a validation function. It‚Äôs a form of <strong>defense-in-depth in code</strong> ‚Äì even if someone forgets to do a manual check before calling <code>downloader.get()</code>, the interceptor will kick in. It also makes the code cleaner in the route handler ‚Äì we simply call <code>downloader.get(url)</code> and know that the interceptor will block any disallowed URL upfront.</p></li><li><p><strong>Timeout and Error Handling:</strong> While not directly an SSRF bypass issue, we set a reasonable timeout (10 seconds here) on the Axios instance to avoid hanging on slow or non-responsive endpoints. We also gracefully handle errors: any thrown error (be it from our interceptor or the request itself) results in a 400 response to the client and logs an error. The error message can indicate <em>why</em> it was blocked (e.g., ‚ÄúBlocked hostname: evil.com‚Äù), which can be useful in detecting attacks in logs, but be careful not to leak too much detail to end-users.</p></li><li><p><strong>Content Considerations:</strong> In this snippet, after a successful response, we pipe the content out as a download (<code>attachment; filename=...</code>). We trust the allowed source to provide legitimate content. If additional validation of the content type or size is needed (for example, ensure it‚Äôs actually a PDF or under certain size), that can be added before piping. The primary focus here is on securing the request against SSRF exploits.</p></li></ul><p>With the above measures in place, our Express endpoint would have passed the earlier test cases that defeated the naive implementation. The <code>startsWith</code>-based filter was bypassable with <code>@</code> and open redirects; our new implementation isn‚Äôt, because it checks the true hostname and disallows redirects entirely. In fact, using a nearly identical test suite:</p><ul><li><strong>Whitelisted domain allowed:</strong> A normal URL to the allowed CDN succeeds (status 200 OK).</li><li><strong><code>@</code> redirect payload blocked:</strong> The malicious <code>...cloudfront.net@302.r3dir.me/...</code> URL is rejected with a 400 and logged (our interceptor sees <code>hostname = 302.r3dir.me</code>, which is not allowed).</li><li><strong>Direct external domain blocked:</strong> A URL to <code>https://evil.com/...</code> is immediately blocked by hostname check (not in allowlist).</li><li><strong>Allowed host redirecting to evil blocked:</strong> If the allowed CDN tries to redirect (we simulate with a 302 via nock in testing), the request is not followed and we return 400.</li></ul><p>By using proper URL parsing and enforcing policies at the HTTP client level, we‚Äôve significantly reduced the SSRF risk. But we‚Äôre not done yet ‚Äì truly secure SSRF defense means <strong>multiple layers</strong> of checks.</p><h2 id=defense-in-depth-additional-safeguards>Defense-in-Depth: Additional Safeguards<a hidden class=anchor aria-hidden=true href=#defense-in-depth-additional-safeguards>#</a></h2><p>The code-level protections above are a strong start. However, savvy attackers might still look for gaps, especially in complex real-world environments. Here are additional <strong>defense-in-depth measures</strong> that you (and your security team) should consider:</p><ul><li><p><strong>Validate DNS Resolution and IP Ranges:</strong> Even after hostname allowlisting, it‚Äôs wise to double-check where the domain resolves to. For instance, ensure the IP address of the allowed host is in a range you expect. If your server is running in a cloud environment, be mindful that some cloud hostnames could resolve to internal IPs. Implement a DNS lookup and verify the resulting IP is not a private/internal address (RFC1918 ranges, localhost, link-local, etc.) before making the request. This prevents scenarios where an allowed domain is hijacked or a DNS rebinding tricks the server into targeting an internal IP. Many languages have libraries or functions (like Python‚Äôs <code>ipaddress</code> module or Golang‚Äôs <code>net</code> package) to check if an IP is in a private network. In Node, you might use <code>dns.promises.lookup</code> and then inspect the IP. Be cautious to do the lookup <em>and</em> request in a way that avoids race conditions (the interceptor approach above could be extended with a custom DNS resolver that filters IPs).</p></li><li><p><strong>Network Egress Filtering (CIDR Allow/Deny Lists):</strong> Don‚Äôt rely solely on application code to enforce SSRF protection. Network-level controls can provide a safety net. For example, if your service should only call a specific external API or CDN, configure firewall rules or a cloud security group to block all other outbound requests. Many cloud providers and container orchestration platforms allow egress restrictions. A Web Application Firewall (WAF) or API gateway can also be configured with rules to prevent traffic to internal IP ranges, adding another layer of defense beyond the app logic.</p></li><li><p><strong>Limit Allowed Ports and Protocols:</strong> If your use-case is only to fetch HTTP/S on standard ports, consider restricting that. An SSRF attacker may try to hit non-HTTP services (like <code>http://target:22/</code> to check an SSH server banner, or other ports for port scanning). Your HTTP client might not speak those protocols, but even connecting can yield information. You can often specify allowed ports or disallow non-80/443 in your allowlist policy. Some frameworks let you enforce this in the URL parser (for example, by checking <code>u.port</code> or requiring <code>u.port</code> is blank or 443/80 if <code>https/http</code>). Similarly, ensure only <code>http</code> and <code>https</code> schemes ‚Äì no <code>ftp:</code>, no <code>file:</code> ‚Äì are ever accepted.</p></li><li><p><strong>Logging and Alerting:</strong> Treat SSRF attempt logs as high-severity events. In our code above, we do <code>console.error</code> logging when a download is blocked. In production, you‚Äôd want to funnel such logs to a monitoring system. If you see repeated ‚ÄúBlocked hostname: 169.254.169.254‚Äù or the like, that‚Äôs a red flag someone is probing for SSRF. Set up alerts for these patterns. Comprehensive access logs that include the requested URL (or at least the domain) can help incident response trace what an attacker tried to do. Remember that sometimes SSRF is blind (the attacker doesn‚Äôt get the response directly), so they might be fuzzing your endpoint and watching side-effects. Good logging might be your only clue something is amiss.</p></li><li><p><strong>Security Testing and Automation:</strong> Given the myriad ways to bypass SSRF filters, it‚Äôs important to <strong>continuously test</strong> your defenses. Incorporate SSRF test cases into your QA or CI/CD pipeline. For example, the test suite we showed earlier programmatically tries an <code>@</code> payload and an open redirect to ensure the server returns 400, not 200. You can leverage security scanning tools or write unit tests for your validation logic. Static analysis can help too ‚Äì for instance, using Semgrep or CodeQL queries to detect any use of dangerous patterns (like raw <code>axios.get(userInput)</code> without validation). Organizations should also perform periodic penetration testing. Tools like Burp Suite have SSRF payload lists and can automate trying dozens of variants (encoded IPs, etc.) against your endpoints. Make sure your ‚Äúsafe‚Äù code actually holds up against these.</p></li><li><p><strong>Keep Dependencies and Knowledge Updated:</strong> The ecosystem around SSRF is evolving. New bypass tricks get discovered (for example, novel URL parsing quirks in different languages or odd behavior in cloud metadata services). Stay updated on security advisories ‚Äì for instance, the <strong><code>nossrf</code> npm package</strong> was created to prevent SSRF, but even it had a critical bypass discovered. Always use the latest patched versions of any libraries or packages related to URL fetching, and review their changelogs for security fixes. And of course, never disable critical protections like certificate verification on your HTTP client ‚Äì doing so could let an attacker intercept your ‚Äúsafe‚Äù requests or present fake certificates.</p></li></ul><p>In essence, <strong>defense-in-depth means assuming one layer of defense <em>could</em> fail</strong>, so you have others to mitigate the impact. We saw how relying just on a prefix check failed; combining hostname + protocol + redirect controls in the code made it much harder to bypass. Adding network rules and continuous testing makes it harder still. The more hurdles an attacker has to jump through, the more likely they‚Äôll give up or slip up and get detected.</p><h2 id=conclusion-never-trust-a-one-size-fits-all-ssrf-fix>Conclusion: Never Trust a ‚ÄúOne-Size-Fits-All‚Äù SSRF Fix<a hidden class=anchor aria-hidden=true href=#conclusion-never-trust-a-one-size-fits-all-ssrf-fix>#</a></h2><blockquote><p><strong>There is no silver bullet.</strong></p><p>Not in folklore. Not in security.
Security isn‚Äôt a one-liner ‚Äî it‚Äôs a process: Think. Test. Break. Fix. Repeat.</p></blockquote><p>SSRF vulnerabilities teach us a broader lesson in software security: <strong>beware of silver-bullet fixes.</strong> If you find a code snippet online claiming ‚Äújust do X to fix SSRF‚Äù without accounting for edge cases, be skeptical. We‚Äôve highlighted how even widely suggested or <strong>‚Äúsecure‚Äù patches can be incomplete</strong> ‚Äì from ChatGPT-Next-Web‚Äôs initial fix being bypassed to the simple allowlist that failed against <code>@</code> and redirect tricks. Attackers think outside the box, so our defenses must as well.</p><hr><h2 id=ssrf-defense-lab-practical-testbed>SSRF Defense Lab: Practical Testbed<a hidden class=anchor aria-hidden=true href=#ssrf-defense-lab-practical-testbed>#</a></h2><p>Looking to verify your SSRF defenses in practice? Check out the open-source <a href=https://github.com/windshock/ssrf-defense-lab>SSRF Defense Lab</a> I created:</p><ul><li>üß™ Minimal, self-contained Node.js/Express testbed for SSRF security</li><li>üîß Secure and vulnerable router examples with real bypass test cases</li><li>üõ†Ô∏è Automated test utilities for CDN/domain allowlisting, redirect bypass, and more</li><li>üìã All tests must pass for a router to be considered secure</li></ul><p><strong>Project highlights:</strong></p><ul><li>Reusable SSRF security test utilities</li><li>Secure/vulnerable router code and tests</li><li>Covers common bypasses: <code>@</code> tricks, open redirects, non-whitelisted domains</li><li>Easy to run: <code>npm install && npm test</code></li></ul><p>Source & docs: <a href=https://github.com/windshock/ssrf-defense-lab>github.com/windshock/ssrf-defense-lab</a></p><hr><p>For developers and security engineers, the key takeaways are:</p><h2 id=key-takeaways>Key Takeaways<a hidden class=anchor aria-hidden=true href=#key-takeaways>#</a></h2><ul><li><strong>Always validate and sanitize user-controlled URLs.</strong> Rely on proven libraries for parsing‚Äînever trust raw string checks.</li><li><strong>Layer your defenses.</strong> Combine hostname allowlists, protocol checks, DNS/IP validation, and strict redirect handling.</li><li><strong>Test like an attacker.</strong> Challenge your own defenses with real-world bypass payloads and automated tests.</li><li><strong>Adopt defense-in-depth.</strong> Use both application logic and network-layer controls to reduce risk and monitor for abuse.</li><li><strong>Stay ahead of new tricks.</strong> Security is never finished‚Äîkeep learning, updating, and adapting.</li></ul><p>Preventing SSRF isn‚Äôt about a single fix‚Äîit‚Äôs about building resilient, layered defenses and never letting your guard down. Be proactive: review, test, and challenge your solutions regularly. If you don‚Äôt, someone else surely will. Secure by design, and let your defenses grow stronger with every lesson learned.</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=https://www.leviathansecurity.com/blog/bypassing-ssrf-filters-using-r3dir>Bypassing SSRF Filters Using r3dir ‚Äî Leviathan Security</a></li><li><a href=https://en.wikipedia.org/wiki/Server-side_request_forgery>Server-side request forgery (Wikipedia)</a></li><li><a href=https://archive.org/details/silverbulletothe0000unse>Silver Bullet ‚Äì Archive.org</a></li><li><a href=https://snyk.io/blog/preventing-server-side-request-forgery-node-js/>Snyk Blog: Preventing SSRF in Node.js</a></li><li><a href=https://github.com/ChatGPTNextWeb/NextChat/commit/9fb8fbcc65c29c74473a13715c05725e2b49065d>GitHub Patch (NextChat)</a></li><li><a href=https://github.com/ChatGPTNextWeb/NextChat/security/advisories/GHSA-gph5-rx77-3pjg>NextChat SSRF Advisory (GitHub)</a></li><li><a href=https://github.com/windshock/ssrf-defense-lab>SSRF Defense Lab (GitHub)</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://windshock.github.io/en/tags/ssrf/>Ssrf</a></li><li><a href=https://windshock.github.io/en/tags/security/>Security</a></li><li><a href=https://windshock.github.io/en/tags/defense/>Defense</a></li><li><a href=https://windshock.github.io/en/tags/web/>Web</a></li></ul><nav class=paginav><a class=prev href=https://windshock.github.io/en/post/2025-06-30-ciso-strategy-execution/><span class=title>¬´ Prev</span><br><span>The Gap Between CISO Strategy and Execution: The WAF Debate and Field Leadership Report</span>
</a><a class=next href=https://windshock.github.io/en/post/2025-06-10-rce-via-exception-serialization-in-openstack-nova/><span class=title>Next ¬ª</span><br><span>Exception Serialization Patterns in OpenStack Nova: Theoretical RCE Risks and Lessons Learned</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share The Limitations of 'Secure' SSRF Patches: Advanced Bypasses and Defense-in-Depth on x" href="https://x.com/intent/tweet/?text=The%20Limitations%20of%20%27Secure%27%20SSRF%20Patches%3a%20Advanced%20Bypasses%20and%20Defense-in-Depth&amp;url=https%3a%2f%2fwindshock.github.io%2fen%2fpost%2f2025-06-25-ssrf-defense%2f&amp;hashtags=ssrf%2csecurity%2cdefense%2cweb"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share The Limitations of 'Secure' SSRF Patches: Advanced Bypasses and Defense-in-Depth on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fwindshock.github.io%2fen%2fpost%2f2025-06-25-ssrf-defense%2f&amp;title=The%20Limitations%20of%20%27Secure%27%20SSRF%20Patches%3a%20Advanced%20Bypasses%20and%20Defense-in-Depth&amp;summary=The%20Limitations%20of%20%27Secure%27%20SSRF%20Patches%3a%20Advanced%20Bypasses%20and%20Defense-in-Depth&amp;source=https%3a%2f%2fwindshock.github.io%2fen%2fpost%2f2025-06-25-ssrf-defense%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share The Limitations of 'Secure' SSRF Patches: Advanced Bypasses and Defense-in-Depth on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwindshock.github.io%2fen%2fpost%2f2025-06-25-ssrf-defense%2f&title=The%20Limitations%20of%20%27Secure%27%20SSRF%20Patches%3a%20Advanced%20Bypasses%20and%20Defense-in-Depth"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share The Limitations of 'Secure' SSRF Patches: Advanced Bypasses and Defense-in-Depth on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwindshock.github.io%2fen%2fpost%2f2025-06-25-ssrf-defense%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share The Limitations of 'Secure' SSRF Patches: Advanced Bypasses and Defense-in-Depth on whatsapp" href="https://api.whatsapp.com/send?text=The%20Limitations%20of%20%27Secure%27%20SSRF%20Patches%3a%20Advanced%20Bypasses%20and%20Defense-in-Depth%20-%20https%3a%2f%2fwindshock.github.io%2fen%2fpost%2f2025-06-25-ssrf-defense%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share The Limitations of 'Secure' SSRF Patches: Advanced Bypasses and Defense-in-Depth on telegram" href="https://telegram.me/share/url?text=The%20Limitations%20of%20%27Secure%27%20SSRF%20Patches%3a%20Advanced%20Bypasses%20and%20Defense-in-Depth&amp;url=https%3a%2f%2fwindshock.github.io%2fen%2fpost%2f2025-06-25-ssrf-defense%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share The Limitations of 'Secure' SSRF Patches: Advanced Bypasses and Defense-in-Depth on ycombinator" href="https://news.ycombinator.com/submitlink?t=The%20Limitations%20of%20%27Secure%27%20SSRF%20Patches%3a%20Advanced%20Bypasses%20and%20Defense-in-Depth&u=https%3a%2f%2fwindshock.github.io%2fen%2fpost%2f2025-06-25-ssrf-defense%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://windshock.github.io/en/>Code Before Breach</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>function loadGiscus(e){document.querySelectorAll('.giscus-frame, script[src*="giscus.app"]').forEach(e=>e.remove());const t=document.createElement("script");t.src="https://giscus.app/client.js",t.setAttribute("data-repo","windshock/windshock.github.io"),t.setAttribute("data-repo-id","MDEwOlJlcG9zaXRvcnkxODQ2MDMyMTk="),t.setAttribute("data-category","General"),t.setAttribute("data-category-id","DIC_kwDOCwDSU84CoqLg"),t.setAttribute("data-mapping","pathname"),t.setAttribute("data-reactions-enabled","1"),t.setAttribute("data-theme",e),t.setAttribute("data-lang","en"),t.setAttribute("data-input-position","bottom"),t.setAttribute("data-loading","lazy"),t.crossOrigin="anonymous",t.async=!0,document.body.appendChild(t)}const currentTheme=document.body.classList.contains("dark")?"dark":"light";loadGiscus(currentTheme);const observer=new MutationObserver(()=>{const e=document.body.classList.contains("dark")?"dark":"light";loadGiscus(e)});observer.observe(document.body,{attributes:!0,attributeFilter:["class"]})</script><script>function initSwiperIfNeeded(){if(typeof Swiper=="undefined")return setTimeout(initSwiperIfNeeded,50);document.querySelector(".swiper")?(new Swiper(".swiper",{slidesPerView:1.2,spaceBetween:16,loop:!0,preloadImages:!1,lazy:{loadOnTransitionStart:!0,loadPrevNext:!0},pagination:{el:".swiper-pagination",clickable:!0},breakpoints:{768:{slidesPerView:2.5},1024:{slidesPerView:3.2}}}),document.querySelectorAll("img.swiper-lazy").forEach(e=>{e.src=e.dataset.src})):setTimeout(initSwiperIfNeeded,100)}initSwiperIfNeeded()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>