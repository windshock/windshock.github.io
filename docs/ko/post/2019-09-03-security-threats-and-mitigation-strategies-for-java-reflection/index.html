<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>자바 리플렉션의 보안 위협과 완화 전략 | Code Before Breach</title>
<meta name=keywords content><meta name=description content="자바 리플렉션의 보안 위협과 완화 전략
자바 리플렉션 API는 런타임에 클래스, 메서드, 인터페이스를 동적으로 조작할 수 있게 해주는 강력한 도구입니다. 하지만 그 유연성 때문에 공격자가 이를 악용해 시스템에 무단 접근할 수 있는 심각한 보안 위험이 발생합니다. 본 문서에서는 자바 리플렉션이 야기하는 보안 위협을 살펴보고, 이러한 위험을 완화하기 위한 전략들을 설명합니다.
리플렉션 API 사용 시의 위험성
리플렉션은 객체의 구조를 검사하거나 런타임에 메서드를 동적으로 호출하는 데 일반적으로 사용됩니다. 그러나 적절한 **보안 관리자(Security Manager)**가 없는 경우, execute, eval 등과 같은 민감한 메서드에 접근할 수 있어 잠재적인 원격 코드 실행(RCE) 공격을 유발할 수 있습니다."><meta name=author content><link rel=canonical href=https://windshock.github.io/ko/post/2019-09-03-security-threats-and-mitigation-strategies-for-java-reflection/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://windshock.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://windshock.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://windshock.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://windshock.github.io/apple-touch-icon.png><link rel=mask-icon href=https://windshock.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://windshock.github.io/en/post/2019-09-03-security-threats-and-mitigation-strategies-for-java-reflection/><link rel=alternate hreflang=ko href=https://windshock.github.io/ko/post/2019-09-03-security-threats-and-mitigation-strategies-for-java-reflection/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://windshock.github.io/ko/post/2019-09-03-security-threats-and-mitigation-strategies-for-java-reflection/"><meta property="og:site_name" content="Code Before Breach"><meta property="og:title" content="자바 리플렉션의 보안 위협과 완화 전략"><meta property="og:description" content="자바 리플렉션의 보안 위협과 완화 전략 자바 리플렉션 API는 런타임에 클래스, 메서드, 인터페이스를 동적으로 조작할 수 있게 해주는 강력한 도구입니다. 하지만 그 유연성 때문에 공격자가 이를 악용해 시스템에 무단 접근할 수 있는 심각한 보안 위험이 발생합니다. 본 문서에서는 자바 리플렉션이 야기하는 보안 위협을 살펴보고, 이러한 위험을 완화하기 위한 전략들을 설명합니다.
리플렉션 API 사용 시의 위험성 리플렉션은 객체의 구조를 검사하거나 런타임에 메서드를 동적으로 호출하는 데 일반적으로 사용됩니다. 그러나 적절한 **보안 관리자(Security Manager)**가 없는 경우, execute, eval 등과 같은 민감한 메서드에 접근할 수 있어 잠재적인 원격 코드 실행(RCE) 공격을 유발할 수 있습니다."><meta property="og:locale" content="ko-KR"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2019-09-03T00:00:00+00:00"><meta property="article:modified_time" content="2019-09-03T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="자바 리플렉션의 보안 위협과 완화 전략"><meta name=twitter:description content="자바 리플렉션의 보안 위협과 완화 전략
자바 리플렉션 API는 런타임에 클래스, 메서드, 인터페이스를 동적으로 조작할 수 있게 해주는 강력한 도구입니다. 하지만 그 유연성 때문에 공격자가 이를 악용해 시스템에 무단 접근할 수 있는 심각한 보안 위험이 발생합니다. 본 문서에서는 자바 리플렉션이 야기하는 보안 위협을 살펴보고, 이러한 위험을 완화하기 위한 전략들을 설명합니다.
리플렉션 API 사용 시의 위험성
리플렉션은 객체의 구조를 검사하거나 런타임에 메서드를 동적으로 호출하는 데 일반적으로 사용됩니다. 그러나 적절한 **보안 관리자(Security Manager)**가 없는 경우, execute, eval 등과 같은 민감한 메서드에 접근할 수 있어 잠재적인 원격 코드 실행(RCE) 공격을 유발할 수 있습니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://windshock.github.io/ko/post/"},{"@type":"ListItem","position":2,"name":"자바 리플렉션의 보안 위협과 완화 전략","item":"https://windshock.github.io/ko/post/2019-09-03-security-threats-and-mitigation-strategies-for-java-reflection/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"자바 리플렉션의 보안 위협과 완화 전략","name":"자바 리플렉션의 보안 위협과 완화 전략","description":"자바 리플렉션의 보안 위협과 완화 전략 자바 리플렉션 API는 런타임에 클래스, 메서드, 인터페이스를 동적으로 조작할 수 있게 해주는 강력한 도구입니다. 하지만 그 유연성 때문에 공격자가 이를 악용해 시스템에 무단 접근할 수 있는 심각한 보안 위험이 발생합니다. 본 문서에서는 자바 리플렉션이 야기하는 보안 위협을 살펴보고, 이러한 위험을 완화하기 위한 전략들을 설명합니다.\n리플렉션 API 사용 시의 위험성 리플렉션은 객체의 구조를 검사하거나 런타임에 메서드를 동적으로 호출하는 데 일반적으로 사용됩니다. 그러나 적절한 **보안 관리자(Security Manager)**가 없는 경우, execute, eval 등과 같은 민감한 메서드에 접근할 수 있어 잠재적인 원격 코드 실행(RCE) 공격을 유발할 수 있습니다.\n","keywords":[],"articleBody":"자바 리플렉션의 보안 위협과 완화 전략 자바 리플렉션 API는 런타임에 클래스, 메서드, 인터페이스를 동적으로 조작할 수 있게 해주는 강력한 도구입니다. 하지만 그 유연성 때문에 공격자가 이를 악용해 시스템에 무단 접근할 수 있는 심각한 보안 위험이 발생합니다. 본 문서에서는 자바 리플렉션이 야기하는 보안 위협을 살펴보고, 이러한 위험을 완화하기 위한 전략들을 설명합니다.\n리플렉션 API 사용 시의 위험성 리플렉션은 객체의 구조를 검사하거나 런타임에 메서드를 동적으로 호출하는 데 일반적으로 사용됩니다. 그러나 적절한 **보안 관리자(Security Manager)**가 없는 경우, execute, eval 등과 같은 민감한 메서드에 접근할 수 있어 잠재적인 원격 코드 실행(RCE) 공격을 유발할 수 있습니다.\n예를 들어, 아래 코드는 시스템 명령어를 실행하기 위해 리플렉션을 사용하는 위험성을 보여줍니다:\n#set($exp=\"test\") $exp.getClass().forName(\"java.lang.Runtime\") .getMethod(\"getRuntime\", null) .invoke(null, null) .exec(\"calc\") 이 코드는 Velocity 템플릿 엔진과 리플렉션을 사용하여 시스템 명령어를 실행하는데, 적절한 보안 조치가 마련되지 않은 경우 공격자에 의해 악용될 수 있습니다. 다행히도, Java 9에서는 이러한 위험을 완화하기 위한 보안 메커니즘이 강화되었습니다.\nJava 9와 StackWalker API Java 9에서는 기존의 Reflection.getCallerClass 메서드가 더 이상 사용되지 않고, 대신 StackWalker API가 도입되었습니다. 이 API는 호출 클래스를 검사하는 보다 안전한 방법을 제공합니다. 이전에는 보안 검사가 바로 직전 호출자에 대해서만 수행되었지만, StackWalker를 사용하면 전체 호출 스택을 검사하여 보다 포괄적인 보안을 확보할 수 있습니다.\n자세한 내용은 Stack Walking API 가이드를 참고하세요. 이 방법은 호출 체인 전체에 걸친 잠재적 취약점을 모두 해결하도록 돕는데, 이는 CVE-2012-4681 취약점 사례에서도 확인할 수 있습니다. 이 취약점에서는 자바의 호출자 민감 메서드가 악용되어 공격이 발생했으나, Java 8 이후로 @CallerSensitive 애노테이션을 통해 이러한 메서드를 보호할 수 있게 되었습니다.\n블랙리스트 기반 보안의 문제점과 화이트리스트의 필요성 전통적인 블랙리스트 기반 보안 접근 방식은 특정 위험 요소를 차단하는 데 초점을 맞추지만, 모든 공격 벡터를 포괄하지 못하는 한계가 있습니다. 예를 들어, 특정 메서드나 클래스를 블랙리스트에 올려도, 공격자는 차단되지 않은 다른 대체 방법을 사용하여 우회할 수 있습니다.\n표현 언어 주입(Expression Language Injection) 및 기타 동적 코드 실행 공격은 이러한 한계를 자주 악용합니다. Blackhat JSON Attacks에서처럼, 블랙리스트 필터링 방식은 우회될 수 있으며, 공격자는 차단되지 않은 경로를 통해 악의적인 명령어를 실행할 수 있습니다.\n이러한 이유로 화이트리스트 접근 방식이 일반적으로 더 효과적입니다. 화이트리스트 방식은 명시적으로 신뢰할 수 있는 클래스와 메서드만 접근을 허용하고 기본적으로 나머지를 모두 차단하므로, 승인되지 않은 메서드나 리플렉션 기반 공격을 통한 코드 실행 위험을 크게 줄일 수 있습니다.\nSecureUberspector의 역할과 한계 Apache Velocity의 SecureUberspector는 클래스 로딩과 리플렉션을 제한하는 도구로, 특히 신뢰할 수 없는 다수의 템플릿 작성자가 관여하는 경우에 유용합니다. 이는 임의의 객체 실행과 해당 객체에 대한 리플렉션을 차단하여 보안을 강화합니다. 그러나 한계가 존재합니다.\n예를 들어, CVE-2019-17558에서 SecureUberspector는 모든 리플렉션 기반 공격을 완전히 차단하지 못했습니다. 특히, javax.script.ScriptEngineManager의 사용을 막지 못해, 이를 통해 임의의 코드 실행이 가능해졌습니다. GHSL-2020-048에서는 공격자가 이 취약점을 이용하여 SecureUberspector를 우회하는 방법을 보여줍니다:\n#set($engine = $scriptEngineManager.getEngineByName(\"nashorn\")) #engine.eval(\"java.lang.Runtime.getRuntime().exec('calc')\") 이 스크립트는 SecureUberspector를 우회하여 원격 명령어 실행을 가능하게 합니다. 마찬가지로, 공격자는 SecureLayer7 분석에서 언급된 바와 같이 Groovy 스크립트를 사용해 보안 메커니즘을 우회할 수 있습니다.\n화이트리스트 적용: 구체적인 전략 화이트리스트는 신뢰할 수 있는 클래스, 메서드, 객체만 허용하고 그 외는 모두 차단하는 보안 모델로, 선호되는 방식입니다. 아래는 자바에서 화이트리스트를 적용하는 구체적인 방법들입니다.\n보안 관리자(Security Manager) 사용\n자바 보안 관리자를 사용하면 민감한 리소스에 대한 접근을 제한하고 특정 클래스나 메서드만 실행할 수 있도록 할 수 있습니다.\nSystem.setSecurityManager(new SecurityManager()); // 신뢰할 수 있는 메서드/클래스에 대한 권한 정의 PermissionCollection perms = new Permissions(); perms.add(new RuntimePermission(\"accessDeclaredMembers\")); // 리플렉션 접근 허용 perms.add(new RuntimePermission(\"createClassLoader\")); // 클래스 로더 생성 허용 AccessController.doPrivileged(new PrivilegedAction\u003cVoid\u003e() { public Void run() { // 화이트리스트에 포함된 메서드 내에서만 실행 secureMethod(); return null; } }, new AccessControlContext(new ProtectionDomain[] {new ProtectionDomain(null, perms)})); 리플렉션을 통한 접근 제어\n리플렉션 사용 시, 특정 클래스와 메서드에 대한 접근을 수동으로 제한하여 명시적으로 허용되지 않은 경우 접근을 거부할 수 있습니다.\nprivate static final Set\u003cString\u003e allowedMethods = Set.of( \"java.lang.String\", \"java.util.List\" // 화이트리스트에 포함된 클래스 ); public static Object invokeMethod(Method method, Object target, Object... args) throws Exception { if (!allowedMethods.contains(method.getDeclaringClass().getName())) { throw new SecurityException(\"Unauthorized method invocation: \" + method.getName()); } return method.invoke(target, args); // 화이트리스트에 포함된 메서드만 실행 } 스크립트 엔진에서의 화이트리스트 적용\njavax.script.ScriptEngineManager와 같은 스크립트 엔진도 화이트리스트를 구현하여 안전한 스크립트나 명령어만 실행되도록 할 수 있습니다.\nScriptEngine engine = new ScriptEngineManager().getEngineByName(\"nashorn\"); engine.setBindings(new SimpleBindings(allowedMethods), ScriptContext.ENGINE_SCOPE); // 화이트리스트 적용 engine.eval(\"some safe script here\"); 템플릿 엔진에서의 화이트리스트 적용\nSecureUberspector와 같은 도구는 템플릿 엔진 내에서 신뢰할 수 있는 메서드와 객체에 대한 접근을 제한하는 화이트리스트 방식을 강제하도록 설정할 수 있습니다.\npublic Iterator getIterator(Object obj, Info i) { if (obj != null) { SecureIntrospectorControl sic = (SecureIntrospectorControl) introspector; if (sic.checkObjectExecutePermission(obj.getClass(), null)) { return super.getIterator(obj, i); } else { log.warn(\"보안 제한으로 인해 \" + obj.getClass() + \"에서 iterator를 가져올 수 없습니다.\"); } } return null; } StackWalker를 통한 보호: 호출자 검증 Java 9에서 도입된 StackWalker API는 호출 스택을 검사하는 안전한 방법을 제공하여, 메서드 호출에 대한 더 나은 제어를 가능하게 합니다. StackWalker를 사용하면 메서드가 신뢰할 수 있는 호출자에 의해서만 호출되는지 확인할 수 있습니다.\n다음은 StackWalker를 사용하여 메서드의 호출자를 검증하는 예제입니다:\nimport java.lang.StackWalker; import java.util.List; import java.util.Set; import java.util.stream.Collectors; public class SecurityManagerUtil { // 화이트리스트에 포함된 호출자 클래스 private static final Set\u003cString\u003e allowedCallers = Set.of(\"com.example.TrustedClass\"); public static void checkCaller() { List\u003cString\u003e stackTrace = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE) .walk(frames -\u003e frames.map(frame -\u003e frame.getDeclaringClass().getName()) .collect(Collectors.toList())); // 호출자가 화이트리스트에 포함되지 않은 경우 예외 발생 boolean isCallerAllowed = stackTrace.stream().anyMatch(allowedCallers::contains); if (!isCallerAllowed) { throw new SecurityException(\"Unauthorized caller detected: \" + stackTrace); } } public static void secureMethod() { checkCaller(); // 실행 전 호출자 검증 System.out.println(\"Secure method executed.\"); } } 이 예제는 신뢰할 수 있는 클래스만이 secureMethod()를 호출할 수 있도록 보장합니다. 만약 허가되지 않은 클래스가 메서드에 접근하려 할 경우, 예외가 발생합니다.\n결론: 리플렉션의 올바른 사용과 보호 자바 리플렉션 API는 유연하고 강력한 도구이지만, 특히 Velocity와 같은 템플릿 엔진과 결합될 경우 심각한 보안 위험을 초래합니다. 블랙리스트 기반 접근 방식은 우회될 가능성이 높지만, 화이트리스트 방식은 신뢰할 수 있는 요소만 실행되도록 하여 더 강력한 보호를 제공합니다. 또한, StackWalker API를 활용하면 메서드 호출을 검증하고 무단 접근을 차단하여 보안을 한층 강화할 수 있습니다.\n화이트리스트와 StackWalker와 같은 도구를 결합함으로써, 자바 애플리케이션을 리플렉션 기반 공격에 대해 더욱 안전하고 견고하게 만들 수 있습니다.\n","wordCount":"925","inLanguage":"ko","datePublished":"2019-09-03T00:00:00Z","dateModified":"2019-09-03T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://windshock.github.io/ko/post/2019-09-03-security-threats-and-mitigation-strategies-for-java-reflection/"},"publisher":{"@type":"Organization","name":"Code Before Breach","logo":{"@type":"ImageObject","url":"https://windshock.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://windshock.github.io/ko/ accesskey=h title="Code Before Breach (Alt + H)"><img src=https://windshock.github.io/images/logo-terminal-animated.svg alt aria-label=logo height=36>Code Before Breach</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://windshock.github.io/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://windshock.github.io/ko/search/ title="검색 (Alt + /)" accesskey=/><span>검색</span></a></li><li><a href=https://windshock.github.io/ko/tags/ title=태그><span>태그</span></a></li><li><a href=https://windshock.github.io/ko/categories/ title=카테고리><span>카테고리</span></a></li><li><a href=https://windshock.github.io/ko/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=https://windshock.github.io/ko/about/ title=소개><span>소개</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://windshock.github.io/ko/>홈</a>&nbsp;»&nbsp;<a href=https://windshock.github.io/ko/post/>Posts</a></div><h1 class="post-title entry-hint-parent">자바 리플렉션의 보안 위협과 완화 전략</h1><div class=post-meta><span title='2019-09-03 00:00:00 +0000 UTC'>9월 3, 2019</span>&nbsp;·&nbsp;5 분&nbsp;·&nbsp;925 단어&nbsp;|&nbsp;번역:<ul class=i18n_list><li><a href=https://windshock.github.io/en/post/2019-09-03-security-threats-and-mitigation-strategies-for-java-reflection/>En</a></li></ul></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><ul><li><a href=#%ec%9e%90%eb%b0%94-%eb%a6%ac%ed%94%8c%eb%a0%89%ec%85%98%ec%9d%98-%eb%b3%b4%ec%95%88-%ec%9c%84%ed%98%91%ea%b3%bc-%ec%99%84%ed%99%94-%ec%a0%84%eb%9e%b5 aria-label="자바 리플렉션의 보안 위협과 완화 전략">자바 리플렉션의 보안 위협과 완화 전략</a><ul><li><a href=#%eb%a6%ac%ed%94%8c%eb%a0%89%ec%85%98-api-%ec%82%ac%ec%9a%a9-%ec%8b%9c%ec%9d%98-%ec%9c%84%ed%97%98%ec%84%b1 aria-label="리플렉션 API 사용 시의 위험성">리플렉션 API 사용 시의 위험성</a></li><li><a href=#java-9%ec%99%80-stackwalker-api aria-label="Java 9와 StackWalker API">Java 9와 StackWalker API</a></li><li><a href=#%eb%b8%94%eb%9e%99%eb%a6%ac%ec%8a%a4%ed%8a%b8-%ea%b8%b0%eb%b0%98-%eb%b3%b4%ec%95%88%ec%9d%98-%eb%ac%b8%ec%a0%9c%ec%a0%90%ea%b3%bc-%ed%99%94%ec%9d%b4%ed%8a%b8%eb%a6%ac%ec%8a%a4%ed%8a%b8%ec%9d%98-%ed%95%84%ec%9a%94%ec%84%b1 aria-label="블랙리스트 기반 보안의 문제점과 화이트리스트의 필요성">블랙리스트 기반 보안의 문제점과 화이트리스트의 필요성</a></li><li><a href=#secureuberspector%ec%9d%98-%ec%97%ad%ed%95%a0%ea%b3%bc-%ed%95%9c%ea%b3%84 aria-label="SecureUberspector의 역할과 한계">SecureUberspector의 역할과 한계</a></li><li><a href=#%ed%99%94%ec%9d%b4%ed%8a%b8%eb%a6%ac%ec%8a%a4%ed%8a%b8-%ec%a0%81%ec%9a%a9-%ea%b5%ac%ec%b2%b4%ec%a0%81%ec%9d%b8-%ec%a0%84%eb%9e%b5 aria-label="화이트리스트 적용: 구체적인 전략">화이트리스트 적용: 구체적인 전략</a></li><li><a href=#stackwalker%eb%a5%bc-%ed%86%b5%ed%95%9c-%eb%b3%b4%ed%98%b8-%ed%98%b8%ec%b6%9c%ec%9e%90-%ea%b2%80%ec%a6%9d aria-label="StackWalker를 통한 보호: 호출자 검증">StackWalker를 통한 보호: 호출자 검증</a></li><li><a href=#%ea%b2%b0%eb%a1%a0-%eb%a6%ac%ed%94%8c%eb%a0%89%ec%85%98%ec%9d%98-%ec%98%ac%eb%b0%94%eb%a5%b8-%ec%82%ac%ec%9a%a9%ea%b3%bc-%eb%b3%b4%ed%98%b8 aria-label="결론: 리플렉션의 올바른 사용과 보호">결론: 리플렉션의 올바른 사용과 보호</a></li></ul></li></ul></div></details></div><div class=post-content><h3 id=자바-리플렉션의-보안-위협과-완화-전략>자바 리플렉션의 보안 위협과 완화 전략<a hidden class=anchor aria-hidden=true href=#자바-리플렉션의-보안-위협과-완화-전략>#</a></h3><p><strong>자바 리플렉션 API</strong>는 런타임에 클래스, 메서드, 인터페이스를 동적으로 조작할 수 있게 해주는 강력한 도구입니다. 하지만 그 유연성 때문에 공격자가 이를 악용해 시스템에 무단 접근할 수 있는 심각한 보안 위험이 발생합니다. 본 문서에서는 자바 리플렉션이 야기하는 보안 위협을 살펴보고, 이러한 위험을 완화하기 위한 전략들을 설명합니다.</p><h4 id=리플렉션-api-사용-시의-위험성>리플렉션 API 사용 시의 위험성<a hidden class=anchor aria-hidden=true href=#리플렉션-api-사용-시의-위험성>#</a></h4><p>리플렉션은 객체의 구조를 검사하거나 런타임에 메서드를 동적으로 호출하는 데 일반적으로 사용됩니다. 그러나 적절한 **보안 관리자(Security Manager)**가 없는 경우, <code>execute</code>, <code>eval</code> 등과 같은 민감한 메서드에 접근할 수 있어 잠재적인 <strong>원격 코드 실행(RCE)</strong> 공격을 유발할 수 있습니다.</p><p>예를 들어, 아래 코드는 시스템 명령어를 실행하기 위해 리플렉션을 사용하는 위험성을 보여줍니다:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span>set($exp<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;test&#34;</span>)
</span></span><span style=display:flex><span>$exp.<span style=color:#a6e22e>getClass</span>().<span style=color:#a6e22e>forName</span>(<span style=color:#e6db74>&#34;java.lang.Runtime&#34;</span>)
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>getMethod</span>(<span style=color:#e6db74>&#34;getRuntime&#34;</span>, <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>invoke</span>(<span style=color:#66d9ef>null</span>, <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>exec</span>(<span style=color:#e6db74>&#34;calc&#34;</span>)
</span></span></code></pre></div><p>이 코드는 Velocity 템플릿 엔진과 리플렉션을 사용하여 시스템 명령어를 실행하는데, 적절한 보안 조치가 마련되지 않은 경우 공격자에 의해 악용될 수 있습니다. 다행히도, Java 9에서는 이러한 위험을 완화하기 위한 보안 메커니즘이 강화되었습니다.</p><h4 id=java-9와-stackwalker-api>Java 9와 StackWalker API<a hidden class=anchor aria-hidden=true href=#java-9와-stackwalker-api>#</a></h4><p>Java 9에서는 기존의 <code>Reflection.getCallerClass</code> 메서드가 더 이상 사용되지 않고, 대신 <strong>StackWalker API</strong>가 도입되었습니다. 이 API는 호출 클래스를 검사하는 보다 안전한 방법을 제공합니다. 이전에는 보안 검사가 바로 직전 호출자에 대해서만 수행되었지만, <strong>StackWalker</strong>를 사용하면 전체 호출 스택을 검사하여 보다 포괄적인 보안을 확보할 수 있습니다.</p><p>자세한 내용은 <a href=https://www.sitepoint.com/deep-dive-into-java-9s-stack-walking-api/>Stack Walking API 가이드</a>를 참고하세요. 이 방법은 호출 체인 전체에 걸친 잠재적 취약점을 모두 해결하도록 돕는데, 이는 <strong>CVE-2012-4681</strong> 취약점 사례에서도 확인할 수 있습니다. 이 취약점에서는 자바의 호출자 민감 메서드가 악용되어 공격이 발생했으나, Java 8 이후로 <code>@CallerSensitive</code> 애노테이션을 통해 이러한 메서드를 보호할 수 있게 되었습니다.</p><h4 id=블랙리스트-기반-보안의-문제점과-화이트리스트의-필요성>블랙리스트 기반 보안의 문제점과 화이트리스트의 필요성<a hidden class=anchor aria-hidden=true href=#블랙리스트-기반-보안의-문제점과-화이트리스트의-필요성>#</a></h4><p>전통적인 블랙리스트 기반 보안 접근 방식은 특정 위험 요소를 차단하는 데 초점을 맞추지만, 모든 공격 벡터를 포괄하지 못하는 한계가 있습니다. 예를 들어, 특정 메서드나 클래스를 블랙리스트에 올려도, 공격자는 차단되지 않은 다른 대체 방법을 사용하여 우회할 수 있습니다.</p><p><strong>표현 언어 주입(Expression Language Injection)</strong> 및 기타 동적 코드 실행 공격은 이러한 한계를 자주 악용합니다. <a href=https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf>Blackhat JSON Attacks</a>에서처럼, 블랙리스트 필터링 방식은 우회될 수 있으며, 공격자는 차단되지 않은 경로를 통해 악의적인 명령어를 실행할 수 있습니다.</p><p>이러한 이유로 <strong>화이트리스트 접근 방식</strong>이 일반적으로 더 효과적입니다. 화이트리스트 방식은 명시적으로 신뢰할 수 있는 클래스와 메서드만 접근을 허용하고 기본적으로 나머지를 모두 차단하므로, 승인되지 않은 메서드나 리플렉션 기반 공격을 통한 코드 실행 위험을 크게 줄일 수 있습니다.</p><h4 id=secureuberspector의-역할과-한계>SecureUberspector의 역할과 한계<a hidden class=anchor aria-hidden=true href=#secureuberspector의-역할과-한계>#</a></h4><p>Apache Velocity의 <strong>SecureUberspector</strong>는 클래스 로딩과 리플렉션을 제한하는 도구로, 특히 신뢰할 수 없는 다수의 템플릿 작성자가 관여하는 경우에 유용합니다. 이는 임의의 객체 실행과 해당 객체에 대한 리플렉션을 차단하여 보안을 강화합니다. 그러나 한계가 존재합니다.</p><p>예를 들어, <strong>CVE-2019-17558</strong>에서 SecureUberspector는 모든 리플렉션 기반 공격을 완전히 차단하지 못했습니다. 특히, <strong>javax.script.ScriptEngineManager</strong>의 사용을 막지 못해, 이를 통해 임의의 코드 실행이 가능해졌습니다. <a href=https://securitylab.github.com/advisories/GHSL-2020-048-apache-velocity/>GHSL-2020-048</a>에서는 공격자가 이 취약점을 이용하여 SecureUberspector를 우회하는 방법을 보여줍니다:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span>set($engine <span style=color:#f92672>=</span> $scriptEngineManager.<span style=color:#a6e22e>getEngineByName</span>(<span style=color:#e6db74>&#34;nashorn&#34;</span>))
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span>engine.<span style=color:#a6e22e>eval</span>(<span style=color:#e6db74>&#34;java.lang.Runtime.getRuntime().exec(&#39;calc&#39;)&#34;</span>)
</span></span></code></pre></div><p>이 스크립트는 SecureUberspector를 우회하여 원격 명령어 실행을 가능하게 합니다. 마찬가지로, 공격자는 <a href=https://blog.securelayer7.net/analyzing-security-vulnerabilities-in-xwiki-in-depth-examination/>SecureLayer7 분석</a>에서 언급된 바와 같이 <strong>Groovy</strong> 스크립트를 사용해 보안 메커니즘을 우회할 수 있습니다.</p><h4 id=화이트리스트-적용-구체적인-전략>화이트리스트 적용: 구체적인 전략<a hidden class=anchor aria-hidden=true href=#화이트리스트-적용-구체적인-전략>#</a></h4><p>화이트리스트는 신뢰할 수 있는 클래스, 메서드, 객체만 허용하고 그 외는 모두 차단하는 보안 모델로, 선호되는 방식입니다. 아래는 자바에서 화이트리스트를 적용하는 구체적인 방법들입니다.</p><ol><li><p><strong>보안 관리자(Security Manager) 사용</strong><br>자바 <strong>보안 관리자</strong>를 사용하면 민감한 리소스에 대한 접근을 제한하고 특정 클래스나 메서드만 실행할 수 있도록 할 수 있습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>System.<span style=color:#a6e22e>setSecurityManager</span>(<span style=color:#66d9ef>new</span> SecurityManager());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 신뢰할 수 있는 메서드/클래스에 대한 권한 정의</span>
</span></span><span style=display:flex><span>PermissionCollection perms <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Permissions();
</span></span><span style=display:flex><span>perms.<span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>new</span> RuntimePermission(<span style=color:#e6db74>&#34;accessDeclaredMembers&#34;</span>)); <span style=color:#75715e>// 리플렉션 접근 허용</span>
</span></span><span style=display:flex><span>perms.<span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>new</span> RuntimePermission(<span style=color:#e6db74>&#34;createClassLoader&#34;</span>)); <span style=color:#75715e>// 클래스 로더 생성 허용</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AccessController.<span style=color:#a6e22e>doPrivileged</span>(<span style=color:#66d9ef>new</span> PrivilegedAction<span style=color:#f92672>&lt;</span>Void<span style=color:#f92672>&gt;</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Void <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 화이트리스트에 포함된 메서드 내에서만 실행</span>
</span></span><span style=display:flex><span>        secureMethod();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}, <span style=color:#66d9ef>new</span> AccessControlContext(<span style=color:#66d9ef>new</span> ProtectionDomain<span style=color:#f92672>[]</span> {<span style=color:#66d9ef>new</span> ProtectionDomain(<span style=color:#66d9ef>null</span>, perms)}));
</span></span></code></pre></div></li><li><p><strong>리플렉션을 통한 접근 제어</strong><br>리플렉션 사용 시, 특정 클래스와 메서드에 대한 접근을 수동으로 제한하여 명시적으로 허용되지 않은 경우 접근을 거부할 수 있습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> Set<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> allowedMethods <span style=color:#f92672>=</span> Set.<span style=color:#a6e22e>of</span>(
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;java.lang.String&#34;</span>, <span style=color:#e6db74>&#34;java.util.List&#34;</span> <span style=color:#75715e>// 화이트리스트에 포함된 클래스</span>
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> Object <span style=color:#a6e22e>invokeMethod</span>(Method method, Object target, Object... args) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>allowedMethods.<span style=color:#a6e22e>contains</span>(method.<span style=color:#a6e22e>getDeclaringClass</span>().<span style=color:#a6e22e>getName</span>())) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> SecurityException(<span style=color:#e6db74>&#34;Unauthorized method invocation: &#34;</span> <span style=color:#f92672>+</span> method.<span style=color:#a6e22e>getName</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> method.<span style=color:#a6e22e>invoke</span>(target, args); <span style=color:#75715e>// 화이트리스트에 포함된 메서드만 실행</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><strong>스크립트 엔진에서의 화이트리스트 적용</strong><br><strong>javax.script.ScriptEngineManager</strong>와 같은 스크립트 엔진도 화이트리스트를 구현하여 안전한 스크립트나 명령어만 실행되도록 할 수 있습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>ScriptEngine engine <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ScriptEngineManager().<span style=color:#a6e22e>getEngineByName</span>(<span style=color:#e6db74>&#34;nashorn&#34;</span>);
</span></span><span style=display:flex><span>engine.<span style=color:#a6e22e>setBindings</span>(<span style=color:#66d9ef>new</span> SimpleBindings(allowedMethods), ScriptContext.<span style=color:#a6e22e>ENGINE_SCOPE</span>); <span style=color:#75715e>// 화이트리스트 적용</span>
</span></span><span style=display:flex><span>engine.<span style=color:#a6e22e>eval</span>(<span style=color:#e6db74>&#34;some safe script here&#34;</span>);
</span></span></code></pre></div></li><li><p><strong>템플릿 엔진에서의 화이트리스트 적용</strong><br>SecureUberspector와 같은 도구는 템플릿 엔진 내에서 신뢰할 수 있는 메서드와 객체에 대한 접근을 제한하는 화이트리스트 방식을 강제하도록 설정할 수 있습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> Iterator <span style=color:#a6e22e>getIterator</span>(Object obj, Info i) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (obj <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        SecureIntrospectorControl sic <span style=color:#f92672>=</span> (SecureIntrospectorControl) introspector;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (sic.<span style=color:#a6e22e>checkObjectExecutePermission</span>(obj.<span style=color:#a6e22e>getClass</span>(), <span style=color:#66d9ef>null</span>)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>getIterator</span>(obj, i);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            log.<span style=color:#a6e22e>warn</span>(<span style=color:#e6db74>&#34;보안 제한으로 인해 &#34;</span> <span style=color:#f92672>+</span> obj.<span style=color:#a6e22e>getClass</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;에서 iterator를 가져올 수 없습니다.&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ol><h4 id=stackwalker를-통한-보호-호출자-검증>StackWalker를 통한 보호: 호출자 검증<a hidden class=anchor aria-hidden=true href=#stackwalker를-통한-보호-호출자-검증>#</a></h4><p>Java 9에서 도입된 <strong>StackWalker API</strong>는 호출 스택을 검사하는 안전한 방법을 제공하여, 메서드 호출에 대한 더 나은 제어를 가능하게 합니다. StackWalker를 사용하면 메서드가 신뢰할 수 있는 호출자에 의해서만 호출되는지 확인할 수 있습니다.</p><p>다음은 StackWalker를 사용하여 메서드의 호출자를 검증하는 예제입니다:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.lang.StackWalker;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.List;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.Set;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.stream.Collectors;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SecurityManagerUtil</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 화이트리스트에 포함된 호출자 클래스</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> Set<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> allowedCallers <span style=color:#f92672>=</span> Set.<span style=color:#a6e22e>of</span>(<span style=color:#e6db74>&#34;com.example.TrustedClass&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>checkCaller</span>() {
</span></span><span style=display:flex><span>        List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> stackTrace <span style=color:#f92672>=</span> StackWalker.<span style=color:#a6e22e>getInstance</span>(StackWalker.<span style=color:#a6e22e>Option</span>.<span style=color:#a6e22e>RETAIN_CLASS_REFERENCE</span>)
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>walk</span>(frames <span style=color:#f92672>-&gt;</span> frames.<span style=color:#a6e22e>map</span>(frame <span style=color:#f92672>-&gt;</span> frame.<span style=color:#a6e22e>getDeclaringClass</span>().<span style=color:#a6e22e>getName</span>())
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>collect</span>(Collectors.<span style=color:#a6e22e>toList</span>()));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 호출자가 화이트리스트에 포함되지 않은 경우 예외 발생</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>boolean</span> isCallerAllowed <span style=color:#f92672>=</span> stackTrace.<span style=color:#a6e22e>stream</span>().<span style=color:#a6e22e>anyMatch</span>(allowedCallers::contains);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>isCallerAllowed) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> SecurityException(<span style=color:#e6db74>&#34;Unauthorized caller detected: &#34;</span> <span style=color:#f92672>+</span> stackTrace);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>secureMethod</span>() {
</span></span><span style=display:flex><span>        checkCaller(); <span style=color:#75715e>// 실행 전 호출자 검증</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Secure method executed.&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>이 예제는 신뢰할 수 있는 클래스만이 <code>secureMethod()</code>를 호출할 수 있도록 보장합니다. 만약 허가되지 않은 클래스가 메서드에 접근하려 할 경우, 예외가 발생합니다.</p><h4 id=결론-리플렉션의-올바른-사용과-보호>결론: 리플렉션의 올바른 사용과 보호<a hidden class=anchor aria-hidden=true href=#결론-리플렉션의-올바른-사용과-보호>#</a></h4><p>자바 리플렉션 API는 유연하고 강력한 도구이지만, 특히 Velocity와 같은 템플릿 엔진과 결합될 경우 심각한 보안 위험을 초래합니다. <strong>블랙리스트 기반</strong> 접근 방식은 우회될 가능성이 높지만, <strong>화이트리스트</strong> 방식은 신뢰할 수 있는 요소만 실행되도록 하여 더 강력한 보호를 제공합니다. 또한, <strong>StackWalker API</strong>를 활용하면 메서드 호출을 검증하고 무단 접근을 차단하여 보안을 한층 강화할 수 있습니다.</p><p>화이트리스트와 StackWalker와 같은 도구를 결합함으로써, 자바 애플리케이션을 리플렉션 기반 공격에 대해 더욱 안전하고 견고하게 만들 수 있습니다.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://windshock.github.io/ko/post/2023-04-18-strengthening-cybersecurity-through-government-ngos-and-bug-bounty-programs/><span class=title>« 이전 페이지</span><br><span>정부 NGO 및 버그 바운티 프로그램을 통한 사이버 보안 강화</span>
</a><a class=next href=https://windshock.github.io/ko/post/2019-08-08-about-the-xssaudit/><span class=title>다음 페이지 »</span><br><span>About the XSSAudit</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 자바 리플렉션의 보안 위협과 완화 전략 on x" href="https://x.com/intent/tweet/?text=%ec%9e%90%eb%b0%94%20%eb%a6%ac%ed%94%8c%eb%a0%89%ec%85%98%ec%9d%98%20%eb%b3%b4%ec%95%88%20%ec%9c%84%ed%98%91%ea%b3%bc%20%ec%99%84%ed%99%94%20%ec%a0%84%eb%9e%b5&amp;url=https%3a%2f%2fwindshock.github.io%2fko%2fpost%2f2019-09-03-security-threats-and-mitigation-strategies-for-java-reflection%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 자바 리플렉션의 보안 위협과 완화 전략 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fwindshock.github.io%2fko%2fpost%2f2019-09-03-security-threats-and-mitigation-strategies-for-java-reflection%2f&amp;title=%ec%9e%90%eb%b0%94%20%eb%a6%ac%ed%94%8c%eb%a0%89%ec%85%98%ec%9d%98%20%eb%b3%b4%ec%95%88%20%ec%9c%84%ed%98%91%ea%b3%bc%20%ec%99%84%ed%99%94%20%ec%a0%84%eb%9e%b5&amp;summary=%ec%9e%90%eb%b0%94%20%eb%a6%ac%ed%94%8c%eb%a0%89%ec%85%98%ec%9d%98%20%eb%b3%b4%ec%95%88%20%ec%9c%84%ed%98%91%ea%b3%bc%20%ec%99%84%ed%99%94%20%ec%a0%84%eb%9e%b5&amp;source=https%3a%2f%2fwindshock.github.io%2fko%2fpost%2f2019-09-03-security-threats-and-mitigation-strategies-for-java-reflection%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 자바 리플렉션의 보안 위협과 완화 전략 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwindshock.github.io%2fko%2fpost%2f2019-09-03-security-threats-and-mitigation-strategies-for-java-reflection%2f&title=%ec%9e%90%eb%b0%94%20%eb%a6%ac%ed%94%8c%eb%a0%89%ec%85%98%ec%9d%98%20%eb%b3%b4%ec%95%88%20%ec%9c%84%ed%98%91%ea%b3%bc%20%ec%99%84%ed%99%94%20%ec%a0%84%eb%9e%b5"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 자바 리플렉션의 보안 위협과 완화 전략 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwindshock.github.io%2fko%2fpost%2f2019-09-03-security-threats-and-mitigation-strategies-for-java-reflection%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 자바 리플렉션의 보안 위협과 완화 전략 on whatsapp" href="https://api.whatsapp.com/send?text=%ec%9e%90%eb%b0%94%20%eb%a6%ac%ed%94%8c%eb%a0%89%ec%85%98%ec%9d%98%20%eb%b3%b4%ec%95%88%20%ec%9c%84%ed%98%91%ea%b3%bc%20%ec%99%84%ed%99%94%20%ec%a0%84%eb%9e%b5%20-%20https%3a%2f%2fwindshock.github.io%2fko%2fpost%2f2019-09-03-security-threats-and-mitigation-strategies-for-java-reflection%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 자바 리플렉션의 보안 위협과 완화 전략 on telegram" href="https://telegram.me/share/url?text=%ec%9e%90%eb%b0%94%20%eb%a6%ac%ed%94%8c%eb%a0%89%ec%85%98%ec%9d%98%20%eb%b3%b4%ec%95%88%20%ec%9c%84%ed%98%91%ea%b3%bc%20%ec%99%84%ed%99%94%20%ec%a0%84%eb%9e%b5&amp;url=https%3a%2f%2fwindshock.github.io%2fko%2fpost%2f2019-09-03-security-threats-and-mitigation-strategies-for-java-reflection%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 자바 리플렉션의 보안 위협과 완화 전략 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%ec%9e%90%eb%b0%94%20%eb%a6%ac%ed%94%8c%eb%a0%89%ec%85%98%ec%9d%98%20%eb%b3%b4%ec%95%88%20%ec%9c%84%ed%98%91%ea%b3%bc%20%ec%99%84%ed%99%94%20%ec%a0%84%eb%9e%b5&u=https%3a%2f%2fwindshock.github.io%2fko%2fpost%2f2019-09-03-security-threats-and-mitigation-strategies-for-java-reflection%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://windshock.github.io/ko/>Code Before Breach</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>function loadGiscus(e){document.querySelectorAll('.giscus-frame, script[src*="giscus.app"]').forEach(e=>e.remove());const t=document.createElement("script");t.src="https://giscus.app/client.js",t.setAttribute("data-repo","windshock/windshock.github.io"),t.setAttribute("data-repo-id","MDEwOlJlcG9zaXRvcnkxODQ2MDMyMTk="),t.setAttribute("data-category","General"),t.setAttribute("data-category-id","DIC_kwDOCwDSU84CoqLg"),t.setAttribute("data-mapping","pathname"),t.setAttribute("data-reactions-enabled","1"),t.setAttribute("data-theme",e),t.setAttribute("data-lang","en"),t.setAttribute("data-input-position","bottom"),t.setAttribute("data-loading","lazy"),t.crossOrigin="anonymous",t.async=!0,document.body.appendChild(t)}const currentTheme=document.body.classList.contains("dark")?"dark":"light";loadGiscus(currentTheme);const observer=new MutationObserver(()=>{const e=document.body.classList.contains("dark")?"dark":"light";loadGiscus(e)});observer.observe(document.body,{attributes:!0,attributeFilter:["class"]})</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="복사";function s(){t.innerHTML="복사 완료!",setTimeout(()=>{t.innerHTML="복사"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>