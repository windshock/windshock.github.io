<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Amadey 악성코드: 정적 탐지 vs 메모리 기반 탐지 비교 연구 | Code Before Breach</title>
<meta name=keywords content="악성코드,Amadey,정적 분석,메모리 포렌식,메모리 기반 탐지,YARA,EDR"><meta name=description content="Amadey를 사례로 정적 서명 탐지와 메모리 기반 탐지를 구조·회피 난이도·YARA 응용 관점에서 비교 정리합니다."><meta name=author content><link rel=canonical href=https://windshock.github.io/ko/post/2026-01-07-amadey-static-vs-memory-detection/><link href="https://fonts.googleapis.com/css2?family=Spectral:wght@400;700&display=swap" rel=stylesheet><link rel=alternate type=application/rss+xml title=RSS href=https://windshock.github.io/index.xml><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://windshock.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://windshock.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://windshock.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://windshock.github.io/apple-touch-icon.png><link rel=mask-icon href=https://windshock.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://windshock.github.io/en/post/2026-01-07-amadey-static-vs-memory-detection/><link rel=alternate hreflang=ko href=https://windshock.github.io/ko/post/2026-01-07-amadey-static-vs-memory-detection/><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/swiper@11/swiper-bundle.min.css><script defer src=https://cdn.jsdelivr.net/npm/swiper@11/swiper-bundle.min.js></script><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6N6EEJ259T"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6N6EEJ259T")}</script><meta property="og:url" content="https://windshock.github.io/ko/post/2026-01-07-amadey-static-vs-memory-detection/"><meta property="og:site_name" content="Code Before Breach"><meta property="og:title" content="Amadey 악성코드: 정적 탐지 vs 메모리 기반 탐지 비교 연구"><meta property="og:description" content="Amadey를 사례로 정적 서명 탐지와 메모리 기반 탐지를 구조·회피 난이도·YARA 응용 관점에서 비교 정리합니다."><meta property="og:locale" content="ko-KR"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2026-01-07T00:00:00+00:00"><meta property="article:modified_time" content="2026-01-07T00:00:00+00:00"><meta property="article:tag" content="악성코드"><meta property="article:tag" content="Amadey"><meta property="article:tag" content="정적 분석"><meta property="article:tag" content="메모리 포렌식"><meta property="article:tag" content="메모리 기반 탐지"><meta property="article:tag" content="YARA"><meta name=twitter:card content="summary"><meta name=twitter:title content="Amadey 악성코드: 정적 탐지 vs 메모리 기반 탐지 비교 연구"><meta name=twitter:description content="Amadey를 사례로 정적 서명 탐지와 메모리 기반 탐지를 구조·회피 난이도·YARA 응용 관점에서 비교 정리합니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://windshock.github.io/ko/post/"},{"@type":"ListItem","position":2,"name":"Amadey 악성코드: 정적 탐지 vs 메모리 기반 탐지 비교 연구","item":"https://windshock.github.io/ko/post/2026-01-07-amadey-static-vs-memory-detection/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Amadey 악성코드: 정적 탐지 vs 메모리 기반 탐지 비교 연구","name":"Amadey 악성코드: 정적 탐지 vs 메모리 기반 탐지 비교 연구","description":"Amadey를 사례로 정적 서명 탐지와 메모리 기반 탐지를 구조·회피 난이도·YARA 응용 관점에서 비교 정리합니다.","keywords":["악성코드","Amadey","정적 분석","메모리 포렌식","메모리 기반 탐지","YARA","EDR"],"articleBody":"Amadey 악성코드: 정적 탐지 vs 메모리 기반 탐지 비교 연구 PDF Open (new tab): /files/Memory_Reveals_Truth.pdf PDF가 보이지 않으면 여기로 열어보세요: /files/Memory_Reveals_Truth.pdf\n관련 영상 정적 탐지와 메모리 기반 탐지의 구조적 차이 정적 탐지는 디스크에 존재하는 악성코드 파일 자체를 분석하여 알려진 패턴이나 서명으로 식별하는 기법입니다. 예를 들어 바이러스 백신은 악성 바이너리의 고유 바이트 서명이나 문자열을 데이터베이스와 대조하여 탐지합니다. 그러나 Amadey와 같은 현대 악성코드는 이러한 정적 서명 탐지를 우회하기 위해 파일을 암호화하거나 난독화합니다. Amadey의 경우 악성 페이로드 내 문자열들을 2중으로 인코딩(사용자 정의 인코딩 + Base64) 하여 정적 분석과 탐지를 어렵게 만듭니다[1]. 이처럼 정적 탐지는 패커(packer)나 암호화로 감싸진 악성코드에 취약하며, 파일 해시나 고정 서명에 의존하므로 폴리모픽(polymorphic) 변종들을 잡아내기 어렵습니다[2][3]. 실제로 Amadey는 다양한 난독화 및 MaaS 형태로 유포되며, 표면적인 파일 해시나 특정 문자열 서명만으로는 변종을 놓칠 수 있습니다.\n반면 메모리 기반 탐지는 실행 중인 프로세스의 메모리를 직접 스캔하여 악성 행위를 식별하는 기법입니다. 이는 악성코드가 실행되면서 자신을 복호화하거나 다른 프로세스에 로드할 때 드러나는 실제 페이로드를 포착합니다. 예를 들어 폴리모픽 악성코드는 실행 시 결국 메모리상에 복호화된 코드로 나타나기 때문에, 메모리 포렌식 분석을 통해 난독화를 우회하고 본질적 악성 코드를 확인할 수 있습니다[4]. 또한 메모리 탐지는 코드 인젝션이나 프로세스 할로잉(process hollowing) 같은 기법도 잡아낼 수 있습니다. 예를 들어 악성코드가 합법적 프로세스를 생성한 뒤 그 메모리를 악성 코드로 덮어씌우면(프로세스 할로잉), 디스크 상에는 정상 파일만 존재하므로 정적 탐지가 불가능합니다. 그러나 메모리 기반 탐지에서는 프로세스의 메모리 이미지와 디스크 이미지를 비교하여 불일치를 발견함으로써 이러한 메모리 내 코드 대체 흔적을 탐지할 수 있습니다[5]. 즉, 정적 탐지가 **“파일이 어떻게 생겼는가”**에 초점을 둔다면, 메모리 탐지는 **“프로세스가 실제 무엇을 하고 있는가”**에 주목하여 런타임의 악성 행위를 밝혀냅니다[4][6].\n요약하면, 정적 탐지는 속도와 효율은 높지만 패킹/난독화에 취약하며, 메모리 탐지는 리소스가 더 들지만 실행 시 드러나는 실제 악성코드를 포착하여 우회당하기 어렵다는 구조적 차이가 있습니다. 특히 파일을 메모리에 풀어 실행하는 로더/드로퍼 계열 악성코드(예: Amadey, SmokeLoader 등)에 대해서는 메모리 기반 접근이 훨씬 효과적입니다[4].\n메모리 상의 실행 Invariant와 회피 어려움 악성코드가 **메모리상에서 드러내는 “실행 invariant(불변 특징)”**이란, 다양한 변종이나 난독화 방식에도 불구하고 악성 행위를 위해서는 어쩔 수 없이 지켜야 하는 핵심 코드나 데이터 패턴을 의미합니다. 이는 일종의 공통된 알고리즘적 서명으로, 공격자가 파일 단에서는 바꾸더라도 실행 단계에서 결국 나타날 수밖에 없는 특징입니다. Amadey 사례를 보면, 이 악성코드는 명령어 문자열을 복호화한 뒤 C2 통신 등에 사용하는데, 복호화 키로 사용되는 다수의 32글자 길이의 고정 HEX 문자열들이 메모리에 나타납니다[7]. 심지어 Amadey 바이너리에는 개발 당시 경로로 추정되는 “\\Amadey\\Release\\Amadey.pdb” 문자열이 남아 있었는데, 이는 변종이 재패킹되어도 메모리에 로드되면 드러날 수 있는 흔적입니다[8]. 정적 탐지 단계에서 이들은 암호화되어 감춰져 있지만, 실행 시에는 반드시 복호화되어 사용되므로 메모리에서 포착이 가능합니다.\n이러한 실행 중 불변 패턴은 공격자가 임의로 바꾸기 어려운 근본적 동작을 반영합니다[9]. 예를 들어 랜섬웨어를 생각하면, 아무리 코드 구조를 바꿔도 파일 암호화 루틴과 복호화 키 출력이라는 기능 자체는 invariant로 남습니다[9]. 마찬가지로 정보탈취형 악성코드는 브라우저 쿠키나 계정 정보를 훔쳐야 하므로 “cookies.sqlite” 같은 브라우저 데이터베이스 경로나 **“installedBrowsers”**와 같은 키워드가 메모리에 나타날 수밖에 없습니다[10]. RedLine 스틸러의 한 변종을 메모리 분석한 결과, DownloadAndExecuteUpdate, StringDecrypt, ChromeGetRoamingName, SystemInfoHelper와 같이 기능을 나타내는 문자열들이 공통적으로 확인되었는데[10], 이는 해당 악성행위(업데이트 다운로드 실행, 문자열 복호화, 크롬 데이터 경로 사용, 시스템 정보수집 등)가 변종 간 일관되게 수행됨을 의미합니다. 공격자가 이러한 핵심 로직을 매번 완전히 새로 작성하지 않는 한, 이들 문자열과 API 호출 패턴은 메모리상에 계속 나타나므로 탐지에 활용할 수 있습니다.\n공격자가 이러한 실행 invariant를 회피하기 어려운 이유는 크게 두 가지입니다. 첫째, 기능 유지의 제약 때문입니다. 악성코드가 목표로 하는 동작(예컨대 Amadey의 시스템 정보 수집 및 C2 통신)은 변하지 않으므로, 해당 기능을 구현하는 핵심 코드 구조나 데이터는 일정 부분 공통으로 남을 수밖에 없습니다[9]. 둘째, 회피를 위한 비용 부담이 큽니다. 만약 공격자가 메모리 invariant 자체를 제거하려면, 메타모픽(metamorphic) 기법처럼 코드를 실행 때마다 의미가하게 완전 변형하거나 JIT 컴파일/인터프리터 방식으로 실시간 생성해야 합니다[11][12]. 그러나 이러한 기법은 개발 난이도가 극도로 높고, 실행 시 성능 오버헤드도 발생합니다. 예를 들어 동일한 두 숫자 덧셈도 매 번 무작위로 다른 방식으로 구현하거나, 코드를 실행 직전에 해독했다 다시 암호화하는 식으로 동작하려면 시스템 리소스를 소모하고 오류 가능성도 높아집니다[13]. 일반적인 악성코드는 그렇게까지 복잡한 엔진을 탑재하지 않으며, MaaS 형태로 빠르게 배포되는 Amadey나 RedLine 등의 사례에서는 개발 효율성을 위해 오히려 코어 로직을 재사용하는 경향이 있습니다. 실제로 Emotet 같은 금융 트로잔도 매일 수천 변종이 생성되지만 행위 패턴은 유사했고, 폴리모픽 패킹만 활용했을 뿐 페이로드 내부 로직은 장기간 유지된 바 있습니다[3][14]. 요컨대 Invariant를 완전히 제거하려는 시도는 공격자에게 득보다 실이 크기 때문에, 변종이 거듭되어도 일정한 메모리 패턴이 남게 되고, 이는 방어자가 장기적인 탐지 포인트로 활용할 수 있습니다.\n기술적 사례: Amadey의 한 변종을 메모리 덤프해 분석한 연구에 따르면, 고유한 함수 호출 시퀀스들이 드러났습니다. 예컨데 아래와 같은 x86 명령어 흐름은 Amadey에서 일관되게 등장하는 루틴입니다.\n// Amadey 메모리 덤프에서 추출된 코드 시퀀스 (예시)\n$sequence_0 = { 89 45 F4 83 7D F4 08 74 4F 8D 85 E8 FD FF FF 89 04 24 E8 ?? ?? ?? ?? C7 04 24 ?? ?? ?? ?? }\n이 패턴을 디스어셈블리해보면, 지역 변수 값을 비교하여 분기하고 메모리 버퍼를 할당해 특정 함수로 호출하는 논리가 드러납니다 (예: mov [ebp-0xC], eax; cmp [ebp-0xC], 8; je …; lea eax, [ebp-0x218]; …)[15]. 이처럼 복잡한 바이트열도 결국 특정 기능을 수행하는 코드의 모습을 하고 있으며, Amadey 계열에서는 변종 간에도 유사한 제어 흐름을 보여 탐지에 응용되었습니다[16][17]. 공격자가 이를 우회하려면 내부 알고리즘 자체를 바꾸는 수준의 개편이 필요하지만, 그러면 악성코드의 신뢰성과 개발 비용 문제가 생기므로 쉽지 않습니다. 결국 **메모리 상에 드러나는 이러한 실행 invariant는 공격자 입장에서 “어쩔 수 없이 노출되는 약점”**인 셈입니다.\nYARA 룰을 통한 메모리 기반 탐지 효율성과 일반화 가능성 메모리 기반 탐지를 실제 수동으로 수행하는 것은 어렵기 때문에, YARA 룰과 같은 패턴 매칭 도구가 널리 활용됩니다. YARA는 텍스트/바이너리 패턴을 정의하여 악성코드 군을 식별할 수 있는 유연한 규칙 언어로, 정적 검사뿐 아니라 메모리 덤프나 프로세스 메모리에도 적용 가능합니다[4][18]. 특히 YARA는 해시 매칭보다 일반화된 패턴을 사용하므로, 폴리모픽 변종에 대응한 invariant 탐지에 유용합니다[9].\n메모리 기반 YARA 탐지의 효율성은 높은 탐지율과 낮은 오탐율로 나타납니다. 잘 설계된 YARA 룰은 한 악성코드 패밀리의 다양한 샘플을 아울러 식별할 수 있습니다[9]. 예를 들어 CloudSEK 연구진이 공개한 Amadey 탐지 YARA 룰을 보면, 디스크 상의 “MZ” 헤더 확인 이후 Amadey 전용 PDB 경로 문자열 또는 복호화 키 패턴을 찾는 조건으로 구성되어 있어, 패킹이 풀린 Amadey라면 변종에 상관없이 탐지될 수 있게 했습니다[7][19]. 이는 정적 탐지에 해당하는 룰이지만, 실질적으로 Amadey의 **핵심 정체성(내부 모듈명, 키 패턴)**을 노렸기 때문에 일종의 invariant 탐지로 볼 수 있습니다. 나아가 YARA-Signator 같은 도구는 메모리 덤프나 언팩된 파일의 디스어셈블리에서 고유한 바이트 시퀀스를 자동 추출하여 YARA 룰을 생성해줍니다[20]. 이렇게 생성된 룰은 API 호출, 제어 흐름, 상수 데이터 참조 패턴을 포함하므로, 간단한 바이트 치환 난독화로는 회피하기 어렵습니다[15][21]. 실제로 YARA-Signator 기반 Amadey 룰에는 5~7개의 명령어로 이루어진 시퀀스 여러 개가 strings로 정의되어, Amadey 변종 코드에서 반복 출현하는 고유 시그니처로 사용되었습니다[16][22].\n일반화 가능성 측면에서, 메모리 기반 탐지 룰은 얼마나 보편적인 invariant를 포착했는지에 따라 범용성이 결정됩니다. 한편으로, 너무 특정 샘플에 맞춘 메모리 패턴은 변종이 약간만 바뀌어도 놓칠 수 있습니다. 예컨대 YARA-Signator 제작자는 “Malpedia에 수록된 단일 샘플 기반으로 생성된 규칙은 일반화 수준에 한계가 있을 수 있다”라고 언급하였는데[23], 이는 곧 메모리 탐지 룰도 지속적인 업데이트와 검증이 필요함을 시사합니다. 실제 현장에서 메모리 YARA를 설계할 때는 여러 변종의 메모리 공통 덤프를 비교하여 일치하는 패턴을 추출하거나, 악성 행위 자체를 나타내는 문자열/코드 조합을 선택하는 식으로 포괄성을 높이는 전략이 요구됩니다. 다행히 Amadey나 RedLine 같은 상용 악성코드는 한 시점의 버전에서 핵심 로직이 크게 변하지 않으므로, 한두 개 룰로도 수많은 변종을 커버하는 높은 효율을 보입니다[9]. 예를 들어 앞서 소개한 RedLine 탐지 YARA에서는 8개의 문자열 조건 중 6개만 일치하면 변종을 악성으로 분류하는데, 이로써 경로 문자열, 함수명, 프로토콜, DB 파일명 등 다양한 특징을 조합하여 오탐을 낮추면서 웬만한 변종은 모두 탐지하는 일반화 효과를 거두고 있습니다[10][24].\n물론 과도한 일반화는 오탐 위험을 높일 수 있으므로, 메모리 YARA 룰은 특정 악성 행위에만 나타나는 패턴인지 정상 소프트웨어에도 있을 수 있는지를 고려해야 합니다. 이를 위해 메모리 기반 YARA는 종종 프로세스 컨텍스트 조건이나 사이즈 제한 등을 추가합니다. 예를 들어 Mandiant가 공개한 메모리 전용 다운로더 PEAKLIGHT 탐지 YARA에서는, PowerShell 스크립트 내부에서만 나타날 법한 구문 패턴 7개 중 4개 이상 발견되고 스크립트 크기가 10KB 미만일 때 룰이 매칭되도록 조건을 걸었습니다[25][26]. 이런 추가 조건은 일반화된 패턴이라도 특정 악성 시나리오에만 반응하게 만들어 탐지 정확도를 높입니다.\n아래 표는 정적 서명 탐지와 메모리 기반 탐지의 비교를 요약한 것입니다:\n탐지 방식 장점 단점 회피 난이도 정적 탐지 (파일 기준) 빠른 검사, 알려진 서명 정확 탐지 패킹/암호화에 취약, 새로운 해시/서명 누락 위험 낮음 (패커로 쉽게 우회 가능) 메모리 기반 탐지 난독화 우회 가능 (복호화된 실제 코드 탐지),\n실행 행위 기반 탐지 (파일리스 공격 탐지) 실시간 메모리 스캔 오버헤드,\n전문 도구 필요 높음 (코드 로직 자체 변경 필요) 위 표에서 보듯 정적 탐지는 우회 난이도가 낮아 Amadey처럼 간단한 문자열 인코딩만으로도 우회를 허용하지만[1], 메모리 탐지는 코드 내부 알고리즘까지 바꾸지 않는 이상 피하기 어려운 높은 난이도를 공격자에게 요구합니다. 따라서 YARA와 같은 규칙 기반 도구를 활용한 메모리 탐지는 효율성과 일반화 면에서 현대 악성코드 대응에 효과적이며, 실제로 많은 보안 업체들이 샌드박스 실행 후 메모리 스캔을 통해 가족별 악성코드를 식별하는 기법을 활용하고 있습니다[4][27].\n악성코드 패밀리 간 메모리 수렴성 비교 (Amadey vs. RedLine vs. FormBook vs. SmokeLoader) 이제 Amadey 외에 다른 악성코드 패밀리에서도 **유사한 메모리 수렴성(공통 패턴)**이 나타나는지 살펴보겠습니다. 메모리 수렴성이란 각기 다른 변종들이 최종적으로 메모리상에서 비슷한 형태나 동작을 보이는 현상을 말합니다. 이는 해당 악성코드 패밀리가 수행하는 고유 악성행위가 비슷하기 때문에 생기는 현상으로 볼 수 있습니다.\nAmadey (트로이목마/로더) – 앞서 분석한 대로 주요 문자열 복호화 루틴과 키 패턴, Mutex 생성, C2 통신 스레드 생성 코드 등이 메모리에서 일관되게 나타납니다[7][28]. Amadey는 MaaS 봇넷으로써 시스템 정보 수집 후 다수 추가 페이로드를 다운로드하는 것이 주 임무이므로, HTTP POST로 시스템 정보를 보내는 루틴(예: OS 버전, 사용자명 등을 문자열로 조합해 전송) 또한 변종에 상관없이 메모리에 공통 구현되어 있습니다[29][30]. 즉 네트워크 통신 구조, 문자열 디코딩 등에서 메모리 수렴성이 높습니다.\nRedLine (정보탈취형 스틸러) – 러시아 해커 포럼에서 판매되는 유명 정보탈취 악성코드로, 웹 브라우저 저장 비밀번호, 자동완성 데이터, 암호화폐 지갑 정보 등을 훔칩니다[31]. RedLine은 종종 .NET으로 개발되어 런타임 시 어셈블리를 로드하거나 자체 보호를 위해 난독화되지만, 메모리상에서는 브라우저 프로파일 경로, SQLite 쿠키 DB 경로 (“cookies.sqlite”), 탈취 대상 애플리케이션 리스트 등의 문자열이 평문으로 드러납니다[32]. 또한 FTP/IM 클라이언트 명칭, 암호화폐 지갑 키워드 등도 탈취 대상에 따라 하드코딩되어 있어, 이러한 값들이 메모리에서 invariant로 검출됩니다. RedLine의 경우 다양한 버전이 등장해도 **탈취 대상과 방법(예: 파일 경로 열람, 시스템 정보 수집)**이 유사하기에, 메모리 수렴성이 높아 하나의 YARA 룰로도 여러 버전을 검출한 사례가 있습니다[33].\nFormBook (정보탈취형/로더) – FormBook은 프로세스 인젝션에 특화된 고유한 런패킹(run-PE) 크립터를 사용하는 것으로 유명합니다[34]. 이 **“Babushka Crypter”**는 여러 계층으로 페이로드를 암호화한 뒤 최종 페이로드를 다른 프로세스 메모리에 실행시키는데, 이 과정에서 메모리에 일정한 패턴이 나타납니다. 예를 들어 자신을 CreateProcess로 실행한 후 대상 프로세스 메모리에 PE 헤더를 쓰고 섹션을 복사한 뒤 OEP로 점프하는 코드 흐름은 FormBook 계열에 공통된 invariant입니다. 해당 루틴은 메모리 상에서 DLL 스톰핑/인젝션에 수반되는 API 호출 (예: VirtualAllocEx, WriteProcessMemory, SetThreadContext, ResumeThread 등) 패턴으로 식별할 수 있습니다. 실제로 이 Babushka 인젝터의 행위 패턴은 유명해서, 시큐리티 연구자들이 FormBook류를 식별하는 YARA룰에도 이를 반영하고 있습니다[34]. 정리하면 FormBook 계열은 다층 암호화를 거치지만 결국 메모리상에서 나타나는 인젝션 행위는 유사하게 수렴합니다.\nSmokeLoader (로더) – 2011년부터 활동한 오래된 로더 악성코드인 SmokeLoader 역시 파일 최소화 및 메모리 로딩 전략을 씁니다. 최신 SmokeLoader 변종은 **“stager”**라는 전단계 모듈이 자신을 난독화하고 분석 방해를 한 뒤, 주된 악성 모듈을 explorer.exe 프로세스 메모리에 인젝션하는 구조를 가집니다[35]. 이때 메모리 내부에서는 항상 explorer 프로세스의 메모리에 존재하지만 PE 이미지상 디스크에는 없는 모듈이 발견되는 공통 특징이 있습니다. 따라서 메모리 포렌식으로 explorer 등에 비정상적으로 로드된 코드 영역을 찾으면 SmokeLoader를 식별할 수 있습니다. 또한 SmokeLoader 메인 모듈은 영구성 확보(레지스트리 Run키 등록 등), C2 비콘 통신, 추가 모듈 로드 등의 기능을 수행하는데[36], 이러한 행위도 변종마다 유사해서 메모리상 API 호출 시퀀스 (예: 자신을 시작 프로그램에 복제, 원격 서버에 주기적 접속)가 수렴성을 보입니다. SmokeLoader는 2024년 당국 단속으로 일시 중단되었다 2025년에 프로토콜만 변경된 채 부활할 정도로 코어 로직이 유지되었고[37], 이는 메모리 기반 탐지 측면에서 과거 룰을 업데이트하여 계속 탐지할 수 있음을 의미합니다.\n위 사례들을 종합하면, Amadey, RedLine, FormBook, SmokeLoader와 같은 악성코드 패밀리들은 각기 전파 방식이나 세부 구현은 달라도 “메모리 상에서 드러나는 핵심 악성 행위” 측면에서 일정한 수렴성을 보인다는 것을 알 수 있습니다. 이는 곧 메모리 기반 탐지 전략이 한 패밀리에 대해 마련되면 유사 변종뿐 아니라 동족 악성에도 응용될 수 있다는 전망을 줍니다. 예를 들어 Loader류 악성코드 전반의 공통 메모리 특징(프로세스 할로잉, 코드 인젝션 패턴 등)을 일반화한 YARA 룰을 만들어두면, 새로운 로더 악성코드가 등장해도 상당 부분 탐지 커버리지가 확보될 수 있습니다. 이처럼 메모리 invariant에 주목한 탐지는 서로 다른 악성코드 패밀리 간의 교차 탐지도 어느 정도 가능하게 해주며, 궁극적으로 일반화된 방어를 구현하는 데 기여합니다[9].\n공격자의 회피 시도와 그 비용 (성능 및 개발 복잡도) 메모리 기반 탐지가 효과적이므로, 역으로 공격자는 이를 무력화하기 위한 시도를 할 수 있습니다. 그러나 앞서 논의했듯 이러한 시도에는 상당한 **비용(cost)**이 따릅니다. 주요 회피 방안과 그 한계를 살펴보면 다음과 같습니다:\n코드 메타모픽 변형 – 공격자는 메타모픽 엔진을 도입하여 실행될 때마다 코드 자체를 재구성하도록 만들 수 있습니다. 예컨대 같은 기능을 매번 다른 명령어와 순서로 구현하거나[12], 무작위로 레지스터 할당을 바꾸고 더미 코드를 삽입하는 등의 기법입니다. 이렇게 하면 변종마다 메모리 상 기계어 패턴이 달라져 정형화된 YARA 시그니처로 잡기 어려워질 수 있습니다. 하지만 이 접근은 개발 난이도가 가장 높습니다. 동등한 기능 구현을 위한 다양한 코드패스 생성에는 복잡한 컴파일러 수준의 로직이 필요하고, 잘못하면 코드 버그나 충돌이 발생할 수 있습니다[11][38]. 또한 이렇게 생성된 코드가 항상 의도대로 동작하는지 검증하기 어렵고, 새로운 안티바이러스 진단을 유발할 가능성도 있습니다. 일반적인 공격자 입장에서 메타모픽 기능을 지속적으로 유지보수하는 것은 비용 부담이 커서, 역사적으로도 고도화된 바이러스나 APT 멀웨어 일부에만 제한적으로 사용되었습니다[3][39].\n코드 지속 암/복호화 (메모리 상 암호화) – 또 다른 방법은 악성코드가 자기 자신의 코드를 실행 중에도 암호화된 형태로 유지하고, 필요한 순간에만 복호화하여 잠시 실행한 뒤 다시 메모리에서 지우는 것입니다. 이를테면 특정 함수 호출 직전에 해당 코드 부분을 복호화하고 실행한 후 즉시 메모리에서 제거하거나 다시 암호화하는 방식입니다. 이러면 메모리 스캔 시점에 따라 악성 패턴이 안 잡힐 수 있습니다. 그러나 이 역시 성능상의 문제가 큽니다. 매 함수나 루프마다 복호화/암호화 연산을 하면 CPU 사용량이 늘고 실행 속도가 저하됩니다. 특히 실시간으로 메모리를 지웠다가 다시 할당하는 작업은 레지던트 악성코드의 효율성을 떨어뜨리고 오류 발생 가능성을 높입니다. 그리고 EDR 솔루션들은 메모리 할당/보호 속성 변화를 후킹하여 추적하기 때문에, 이러한 시도도 완전한 은폐책은 되지 못합니다 (예: RWX 메모리 영역 생성과 삭제 빈도가 비정상적이면 경고). 따라서 공격자가 이런 기법을 도입하면 자신의 악성코드가 느려지고 불안정해지는 비용을 감수해야 합니다.\n가상머신/인터프리터 내 실행 – 일부 고급 회피기법으로, 악성 페이로드를 자체 가상 머신 바이트코드로 변환한 뒤 메모리에 가상 머신 인터프리터만 올려서 동작하게 만드는 방법이 있습니다. 이 경우 메모리에는 인터프리터만 존재하고 실제 악성 행위는 가상 머신 안에서 해석되므로, 겉보기에는 패턴이 안 드러날 수 있습니다. 그러나 인터프리터 자체가 새로운 패턴이 되므로 이것도 장기적으로는 탐지 가능해집니다. 수십 KB 이상의 VM 해석기 코드가 메모리에 상주하면 오히려 특이한 메모리 특징이 되어 EDR에 탐지될 수 있고, 해당 VM의 명령 집합을 리버스 엔지니어링 당하면 결국 더 강인한 서명이 만들어집니다. 또한 VM을 사용하면 명령어 처리 오버헤드로 실행 성능이 저하됩니다. 공격자는 이러한 복잡한 커스텀 VM 개발과 유지보수 부담을 져야 하며, 이는 일반 금융정보 탈취나 로더 목적의 악성코드로서는 과투자에 가깝습니다.\n기타 회피 기법 – 안티 메모리 스캔 기술로, 자신을 디버거로 위장해 OpenProcess로 메모리 읽기를 차단하거나, 페이지 권한을 교묘히 설정하여 접근하면 크래시를 유발하는 식의 방어도 이론적으로 가능합니다. 하지만 이를 구현하면 정상 동작에 지장을 줄 수 있고, 윈도우 API 후킹 등으로 충분히 우회당할 수 있습니다. 또한 EDR과의 치킨게임 양상이 되어, 방어 측에서도 커널 드라이버 등을 통해 더욱 강제적인 메모리 검사 기법을 적용할 수 있습니다. 일반적으로 공격자가 취하는 현실적인 회피는 최대한 패킹과 난독화를 강화하고, 지속적으로 변종을 만들어 정적 IOC 수명을 단축시키는 정도에 그칩니다[40][41]. 메모리 단계까지 신경 쓰는 공격자는 극소수이며, 그런 경우에도 위에서 논의한 대가를 치르게 마련입니다.\n결론적으로, 공격자가 메모리 기반 탐지를 완전히 따돌리려면 개발 복잡도나 운영 안정성 측면에서 막대한 비용을 감수해야 합니다. 이는 방어자에게 유리한 지형을 만들어줍니다. 메모리상의 invariant를 노린 탐지 전략은 단기간에 무력화되기 어렵고, 설령 공격자가 대응하더라도 그 부담은 공격자 측에 전가됩니다. 예컨대 Amadey 제작자가 탐지를 피하려고 핵심 코드 흐름을 전면 수정하면, 그 기간 동안 서비스가 원활히 운영되기 힘들 것이고, 오히려 눈에 띄는 변화로 보안 커뮤니티에 포착될 가능성이 높습니다. 따라서 메모리 기반 탐지는 장기적으로 유효한 방어 수단으로 평가됩니다. 실제로 다계층 보안 체계에서는 정적, 동적, 행위 기반 탐지와 함께 메모리 포렌식 기반 탐지를 조합하여 활용함으로써, 신종 위협에 대한 종합적인 대응력을 높이고 있습니다[42][43]. Amadey를 비롯한 여러 악성코드 사례 분석을 통해 보았듯이, 메모리에는 거짓말이 없으며(runtime doesn’t lie), 이 점이 방어자가 끝까지 악성코드의 실체를 밝히는 열쇠가 될 것입니다.\n참고 자료 (References) 【1】 Splunk Threat Research Team – “Amadey Threat Analysis and Detections” (2023)[1][29]\n【6】 CloudSEK Research – “Amadey with AV Disabler drops RedLine – YARA rules” (2023)[7][20]\n【11】 InventiveHQ – “Why Hash Lookup Fails Against Polymorphic Malware (Memory-Based Detection)” (2026)[4][5]\n【13】 InventiveHQ – 동일 출처 상동[4][44]\n【29】 Amr Ashraf – “RedLine Stealer Analysis – YARA rule” (2023)[32][33]\n【14】 Malpedia – “Formbook – unique RunPE crypter behavior”[34]\n【34】 TheHackerNews – “SmokeLoader Returns with New Changes” (2025)[35][37]\n","wordCount":"2600","inLanguage":"ko","datePublished":"2026-01-07T00:00:00Z","dateModified":"2026-01-07T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://windshock.github.io/ko/post/2026-01-07-amadey-static-vs-memory-detection/"},"publisher":{"@type":"Organization","name":"Code Before Breach","logo":{"@type":"ImageObject","url":"https://windshock.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://windshock.github.io/ko/ accesskey=h title="Code Before Breach (Alt + H)"><img src=https://windshock.github.io/images/logo-terminal-animated.svg alt aria-label=logo class="h-7 w-auto" height=28>Code Before Breach</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://windshock.github.io/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://windshock.github.io/ko/search/ title="검색 (Alt + /)" accesskey=/><span>검색</span></a></li><li><a href=https://windshock.github.io/ko/tags/ title=태그><span>태그</span></a></li><li><a href=https://windshock.github.io/ko/categories/ title=카테고리><span>카테고리</span></a></li><li><a href=https://windshock.github.io/ko/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=https://windshock.github.io/ko/about/ title=소개><span>소개</span></a></li><li><a href=https://windshock.github.io/ko/index.xml title="RSS 피드"><span>RSS 피드</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://windshock.github.io/ko/>홈</a>&nbsp;»&nbsp;<a href=https://windshock.github.io/ko/post/>Posts</a></div><h1 class="post-title entry-hint-parent">Amadey 악성코드: 정적 탐지 vs 메모리 기반 탐지 비교 연구</h1><div class=post-description>Amadey를 사례로 정적 서명 탐지와 메모리 기반 탐지를 구조·회피 난이도·YARA 응용 관점에서 비교 정리합니다.</div><div class=post-meta><span title='2026-01-07 00:00:00 +0000 UTC'>1월 7, 2026</span>&nbsp;·&nbsp;13 분&nbsp;·&nbsp;2600 단어&nbsp;|&nbsp;번역:<ul class=i18n_list><li><a href=https://windshock.github.io/en/post/2026-01-07-amadey-static-vs-memory-detection/>En</a></li></ul></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><ul><li><a href=#amadey-%ec%95%85%ec%84%b1%ec%bd%94%eb%93%9c-%ec%a0%95%ec%a0%81-%ed%83%90%ec%a7%80-vs-%eb%a9%94%eb%aa%a8%eb%a6%ac-%ea%b8%b0%eb%b0%98-%ed%83%90%ec%a7%80-%eb%b9%84%ea%b5%90-%ec%97%b0%ea%b5%ac aria-label="Amadey 악성코드: 정적 탐지 vs 메모리 기반 탐지 비교 연구">Amadey 악성코드: 정적 탐지 vs 메모리 기반 탐지 비교 연구</a><ul><li><a href=#pdf aria-label=PDF>PDF</a></li><li><a href=#%ea%b4%80%eb%a0%a8-%ec%98%81%ec%83%81 aria-label="관련 영상">관련 영상</a></li><li><a href=#%ec%a0%95%ec%a0%81-%ed%83%90%ec%a7%80%ec%99%80-%eb%a9%94%eb%aa%a8%eb%a6%ac-%ea%b8%b0%eb%b0%98-%ed%83%90%ec%a7%80%ec%9d%98-%ea%b5%ac%ec%a1%b0%ec%a0%81-%ec%b0%a8%ec%9d%b4 aria-label="정적 탐지와 메모리 기반 탐지의 구조적 차이">정적 탐지와 메모리 기반 탐지의 구조적 차이</a></li><li><a href=#%eb%a9%94%eb%aa%a8%eb%a6%ac-%ec%83%81%ec%9d%98-%ec%8b%a4%ed%96%89-invariant%ec%99%80-%ed%9a%8c%ed%94%bc-%ec%96%b4%eb%a0%a4%ec%9b%80 aria-label="메모리 상의 실행 Invariant와 회피 어려움">메모리 상의 실행 Invariant와 회피 어려움</a></li><li><a href=#yara-%eb%a3%b0%ec%9d%84-%ed%86%b5%ed%95%9c-%eb%a9%94%eb%aa%a8%eb%a6%ac-%ea%b8%b0%eb%b0%98-%ed%83%90%ec%a7%80-%ed%9a%a8%ec%9c%a8%ec%84%b1%ea%b3%bc-%ec%9d%bc%eb%b0%98%ed%99%94-%ea%b0%80%eb%8a%a5%ec%84%b1 aria-label="YARA 룰을 통한 메모리 기반 탐지 효율성과 일반화 가능성">YARA 룰을 통한 메모리 기반 탐지 효율성과 일반화 가능성</a></li><li><a href=#%ec%95%85%ec%84%b1%ec%bd%94%eb%93%9c-%ed%8c%a8%eb%b0%80%eb%a6%ac-%ea%b0%84-%eb%a9%94%eb%aa%a8%eb%a6%ac-%ec%88%98%eb%a0%b4%ec%84%b1-%eb%b9%84%ea%b5%90-amadey-vs-redline-vs-formbook-vs-smokeloader aria-label="악성코드 패밀리 간 메모리 수렴성 비교 (Amadey vs. RedLine vs. FormBook vs. SmokeLoader)">악성코드 패밀리 간 메모리 수렴성 비교 (Amadey vs. RedLine vs. FormBook vs. SmokeLoader)</a></li><li><a href=#%ea%b3%b5%ea%b2%a9%ec%9e%90%ec%9d%98-%ed%9a%8c%ed%94%bc-%ec%8b%9c%eb%8f%84%ec%99%80-%ea%b7%b8-%eb%b9%84%ec%9a%a9-%ec%84%b1%eb%8a%a5-%eb%b0%8f-%ea%b0%9c%eb%b0%9c-%eb%b3%b5%ec%9e%a1%eb%8f%84 aria-label="공격자의 회피 시도와 그 비용 (성능 및 개발 복잡도)">공격자의 회피 시도와 그 비용 (성능 및 개발 복잡도)</a></li><li><a href=#%ec%b0%b8%ea%b3%a0-%ec%9e%90%eb%a3%8c-references aria-label="참고 자료 (References)">참고 자료 (References)</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=amadey-악성코드-정적-탐지-vs-메모리-기반-탐지-비교-연구>Amadey 악성코드: 정적 탐지 vs 메모리 기반 탐지 비교 연구<a hidden class=anchor aria-hidden=true href=#amadey-악성코드-정적-탐지-vs-메모리-기반-탐지-비교-연구>#</a></h1><h2 id=pdf>PDF<a hidden class=anchor aria-hidden=true href=#pdf>#</a></h2><ul><li><strong>Open (new tab):</strong> <a href=/files/Memory_Reveals_Truth.pdf><code>/files/Memory_Reveals_Truth.pdf</code></a></li></ul><iframe id=pdfjs-memory-reveals-truth-ko src="/pdfjs/single.html?file=/files/Memory_Reveals_Truth.pdf#page=1" width=100% height=560 style="border:1px solid #e5e7eb;border-radius:8px"></iframe>
<script>(function(){const e=document.getElementById("pdfjs-memory-reveals-truth-ko");if(!e)return;window.addEventListener("message",function(t){if(t.origin!==window.location.origin)return;const n=t.data||{};if(n.type!=="pdfjs-resize")return;if(typeof n.height!="number")return;e.style.height=Math.max(420,Math.min(n.height,980))+"px"})})()</script><blockquote><p>PDF가 보이지 않으면 여기로 열어보세요: <a href=/files/Memory_Reveals_Truth.pdf><code>/files/Memory_Reveals_Truth.pdf</code></a></p></blockquote><h2 id=관련-영상>관련 영상<a hidden class=anchor aria-hidden=true href=#관련-영상>#</a></h2><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/HkmiNIjGBts?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div><h2 id=정적-탐지와-메모리-기반-탐지의-구조적-차이>정적 탐지와 메모리 기반 탐지의 구조적 차이<a hidden class=anchor aria-hidden=true href=#정적-탐지와-메모리-기반-탐지의-구조적-차이>#</a></h2><p><strong>정적 탐지</strong>는 디스크에 존재하는 악성코드 파일 자체를 분석하여 알려진 패턴이나 서명으로 식별하는 기법입니다. 예를 들어 바이러스 백신은 악성 바이너리의 고유 바이트 서명이나 문자열을 데이터베이스와 대조하여 탐지합니다. 그러나 Amadey와 같은 현대 악성코드는 이러한 <strong>정적 서명 탐지</strong>를 우회하기 위해 파일을 암호화하거나 난독화합니다. Amadey의 경우 악성 페이로드 내 문자열들을 <strong>2중으로 인코딩(사용자 정의 인코딩 + Base64)</strong> 하여 정적 분석과 탐지를 어렵게 만듭니다<a href="https://www.splunk.com/en_us/blog/security/amadey-threat-analysis-and-detections.html#:~:text=This%20malware%20uses%20two%20layers,followed%20by%20a%20Base64%20algorithm">[1]</a>. 이처럼 정적 탐지는 <strong>패커</strong>(packer)나 <strong>암호화</strong>로 감싸진 악성코드에 취약하며, 파일 해시나 고정 서명에 의존하므로 폴리모픽(polymorphic) 변종들을 잡아내기 어렵습니다<a href="https://inventivehq.com/blog/why-hash-lookup-fails-against-polymorphic-malware#:~:text=Metamorphic%20Malware%3A%20The%20Next%20Evolution">[2]</a><a href="https://inventivehq.com/blog/why-hash-lookup-fails-against-polymorphic-malware#:~:text=The%20Emotet%20banking%20Trojan%2C%20one,detection%20becomes%20obsolete%20within%20hours">[3]</a>. 실제로 Amadey는 다양한 난독화 및 <strong>MaaS</strong> 형태로 유포되며, <strong>표면적인 파일 해시나 특정 문자열 서명만으로는 변종을 놓칠 수 있습니다</strong>.</p><p>반면 <strong>메모리 기반 탐지</strong>는 <strong>실행 중인 프로세스의 메모리를 직접 스캔</strong>하여 악성 행위를 식별하는 기법입니다. 이는 악성코드가 실행되면서 자신을 복호화하거나 다른 프로세스에 로드할 때 드러나는 <strong>실제 페이로드</strong>를 포착합니다. 예를 들어 <strong>폴리모픽</strong> 악성코드는 실행 시 결국 메모리상에 복호화된 코드로 나타나기 때문에, <strong>메모리 포렌식 분석을 통해 난독화를 우회</strong>하고 본질적 악성 코드를 확인할 수 있습니다<a href="https://inventivehq.com/blog/why-hash-lookup-fails-against-polymorphic-malware#:~:text=Memory,rather%20than%20the%20encrypted%20dropper">[4]</a>. 또한 메모리 탐지는 <strong>코드 인젝션</strong>이나 <strong>프로세스 할로잉(process hollowing)</strong> 같은 기법도 잡아낼 수 있습니다. 예를 들어 악성코드가 합법적 프로세스를 생성한 뒤 그 메모리를 악성 코드로 덮어씌우면(프로세스 할로잉), 디스크 상에는 정상 파일만 존재하므로 정적 탐지가 불가능합니다. 그러나 메모리 기반 탐지에서는 <strong>프로세스의 메모리 이미지와 디스크 이미지를 비교</strong>하여 불일치를 발견함으로써 이러한 <strong>메모리 내 코드 대체 흔적</strong>을 탐지할 수 있습니다<a href="https://inventivehq.com/blog/why-hash-lookup-fails-against-polymorphic-malware#:~:text=Process%20hollowing%20detection%20identifies%20when,based%20evasion%20tactics">[5]</a>. 즉, <strong>정적 탐지</strong>가 **“파일이 어떻게 생겼는가”**에 초점을 둔다면, <strong>메모리 탐지</strong>는 **“프로세스가 실제 무엇을 하고 있는가”**에 주목하여 런타임의 악성 행위를 밝혀냅니다<a href="https://inventivehq.com/blog/why-hash-lookup-fails-against-polymorphic-malware#:~:text=Memory,rather%20than%20the%20encrypted%20dropper">[4]</a><a href="https://inventivehq.com/blog/why-hash-lookup-fails-against-polymorphic-malware#:~:text=Behavioral%20Detection%20as%20a%20Solution">[6]</a>.</p><p>요약하면, <strong>정적 탐지</strong>는 속도와 효율은 높지만 패킹/난독화에 취약하며, <strong>메모리 탐지</strong>는 리소스가 더 들지만 <strong>실행 시 드러나는 실제 악성코드</strong>를 포착하여 우회당하기 어렵다는 구조적 차이가 있습니다. 특히 파일을 <strong>메모리에 풀어 실행하는 로더/드로퍼 계열 악성코드</strong>(예: Amadey, SmokeLoader 등)에 대해서는 메모리 기반 접근이 훨씬 효과적입니다<a href="https://inventivehq.com/blog/why-hash-lookup-fails-against-polymorphic-malware#:~:text=Memory,rather%20than%20the%20encrypted%20dropper">[4]</a>.</p><h2 id=메모리-상의-실행-invariant와-회피-어려움>메모리 상의 <strong>실행 Invariant</strong>와 회피 어려움<a hidden class=anchor aria-hidden=true href=#메모리-상의-실행-invariant와-회피-어려움>#</a></h2><p>악성코드가 **메모리상에서 드러내는 “실행 invariant(불변 특징)”**이란, 다양한 변종이나 난독화 방식에도 불구하고 <strong>악성 행위를 위해서는 어쩔 수 없이 지켜야 하는 핵심 코드나 데이터 패턴</strong>을 의미합니다. 이는 일종의 <strong>공통된 알고리즘적 서명</strong>으로, 공격자가 파일 단에서는 바꾸더라도 <strong>실행 단계에서 결국 나타날 수밖에 없는 특징</strong>입니다. Amadey 사례를 보면, 이 악성코드는 <strong>명령어 문자열을 복호화</strong>한 뒤 C2 통신 등에 사용하는데, 복호화 키로 사용되는 다수의 <strong>32글자 길이의 고정 HEX 문자열</strong>들이 메모리에 나타납니다<a href="https://www.cloudsek.com/blog/amadey-equipped-with-av-disabler-drops-redline-stealer#:~:text=strings%3A%20%24pdb%20%20%3D%20,9%5D%7B32%7D%5Cx00">[7]</a>. 심지어 Amadey 바이너리에는 개발 당시 경로로 추정되는 <strong>“\Amadey\Release\Amadey.pdb”</strong> 문자열이 남아 있었는데, 이는 변종이 재패킹되어도 메모리에 로드되면 드러날 수 있는 흔적입니다<a href="https://www.cloudsek.com/blog/amadey-equipped-with-av-disabler-drops-redline-stealer#:~:text=strings%3A%20%24pdb%20%20%3D%20,9%5D%7B32%7D%5Cx00%7B1%2C16%7D%5Ba">[8]</a>. 정적 탐지 단계에서 이들은 암호화되어 감춰져 있지만, <strong>실행 시에는 반드시 복호화되어 사용되므로</strong> 메모리에서 포착이 가능합니다.</p><p>이러한 <strong>실행 중 불변 패턴</strong>은 공격자가 임의로 바꾸기 어려운 근본적 동작을 반영합니다<a href="https://inventivehq.com/blog/why-hash-lookup-fails-against-polymorphic-malware#:~:text=For%20polymorphic%20malware%2C%20YARA%20rules,positives%20across%20entire%20malware%20families">[9]</a>. 예를 들어 <strong>랜섬웨어</strong>를 생각하면, 아무리 코드 구조를 바꿔도 <strong>파일 암호화 루틴과 복호화 키 출력</strong>이라는 기능 자체는 invariant로 남습니다<a href="https://inventivehq.com/blog/why-hash-lookup-fails-against-polymorphic-malware#:~:text=For%20polymorphic%20malware%2C%20YARA%20rules,positives%20across%20entire%20malware%20families">[9]</a>. 마찬가지로 <strong>정보탈취형 악성코드</strong>는 브라우저 쿠키나 계정 정보를 훔쳐야 하므로 <strong>“cookies.sqlite”</strong> 같은 브라우저 데이터베이스 경로나 **“installedBrowsers”**와 같은 키워드가 메모리에 나타날 수밖에 없습니다<a href="https://amr-git-dot.github.io/malware%20analysis/RedLineStealer/#:~:text=%24string4%20%3D%20">[10]</a>. RedLine 스틸러의 한 변종을 메모리 분석한 결과, <strong>DownloadAndExecuteUpdate</strong>, <strong>StringDecrypt</strong>, <strong>ChromeGetRoamingName</strong>, <strong>SystemInfoHelper</strong>와 같이 기능을 나타내는 문자열들이 공통적으로 확인되었는데<a href="https://amr-git-dot.github.io/malware%20analysis/RedLineStealer/#:~:text=%24string4%20%3D%20">[10]</a>, 이는 해당 악성행위(업데이트 다운로드 실행, 문자열 복호화, 크롬 데이터 경로 사용, 시스템 정보수집 등)가 변종 간 일관되게 수행됨을 의미합니다. 공격자가 이러한 핵심 로직을 매번 완전히 새로 작성하지 않는 한, <strong>이들 문자열과 API 호출 패턴은 메모리상에 계속 나타나므로</strong> 탐지에 활용할 수 있습니다.</p><p><strong>공격자가 이러한 실행 invariant를 회피하기 어려운 이유</strong>는 크게 두 가지입니다. 첫째, <strong>기능 유지의 제약</strong> 때문입니다. 악성코드가 목표로 하는 동작(예컨대 Amadey의 시스템 정보 수집 및 C2 통신)은 변하지 않으므로, 해당 기능을 구현하는 핵심 코드 구조나 데이터는 일정 부분 <strong>공통으로 남을 수밖에 없습니다<a href="https://inventivehq.com/blog/why-hash-lookup-fails-against-polymorphic-malware#:~:text=For%20polymorphic%20malware%2C%20YARA%20rules,positives%20across%20entire%20malware%20families">[9]</a></strong>. 둘째, <strong>회피를 위한 비용 부담</strong>이 큽니다. 만약 공격자가 메모리 invariant 자체를 제거하려면, <strong>메타모픽(metamorphic) 기법</strong>처럼 <strong>코드를 실행 때마다 의미가하게 완전 변형</strong>하거나 <strong>JIT 컴파일/인터프리터</strong> 방식으로 실시간 생성해야 합니다<a href="https://inventivehq.com/blog/why-hash-lookup-fails-against-polymorphic-malware#:~:text=Where%20polymorphic%20malware%20encrypts%20or,encrypted%20payload%20exists%20across%20variants">[11]</a><a href="https://inventivehq.com/blog/why-hash-lookup-fails-against-polymorphic-malware#:~:text=For%20example%2C%20a%20code%20sequence,sequences%2C%20evading%20signature%20matching%20entirely">[12]</a>. 그러나 이러한 기법은 <strong>개발 난이도가 극도로 높고</strong>, 실행 시 <strong>성능 오버헤드</strong>도 발생합니다. 예를 들어 동일한 두 숫자 덧셈도 매 번 무작위로 다른 방식으로 구현하거나, 코드를 실행 직전에 해독했다 다시 암호화하는 식으로 동작하려면 <strong>시스템 리소스를 소모하고 오류 가능성</strong>도 높아집니다<a href="https://inventivehq.com/blog/why-hash-lookup-fails-against-polymorphic-malware#:~:text=Metamorphic%20techniques%20include%20instruction%20substitution,to%20creating%20truly%20unique%20variants">[13]</a>. 일반적인 악성코드는 그렇게까지 복잡한 엔진을 탑재하지 않으며, <strong>MaaS 형태로 빠르게 배포</strong>되는 Amadey나 RedLine 등의 사례에서는 <strong>개발 효율성을 위해 오히려 코어 로직을 재사용</strong>하는 경향이 있습니다. 실제로 Emotet 같은 금융 트로잔도 매일 수천 변종이 생성되지만 <strong>행위 패턴은 유사</strong>했고, 폴리모픽 패킹만 활용했을 뿐 <strong>페이로드 내부 로직은 장기간 유지</strong>된 바 있습니다<a href="https://inventivehq.com/blog/why-hash-lookup-fails-against-polymorphic-malware#:~:text=The%20Emotet%20banking%20Trojan%2C%20one,detection%20becomes%20obsolete%20within%20hours">[3]</a><a href="https://inventivehq.com/blog/why-hash-lookup-fails-against-polymorphic-malware#:~:text=how%20polymorphic%20malware%20mutates%20its,opportunities%20independent%20of%20file%20signatures">[14]</a>. 요컨대 <strong>Invariant를 완전히 제거하려는 시도는 공격자에게 득보다 실이 크기 때문에</strong>, 변종이 거듭되어도 일정한 메모리 패턴이 남게 되고, 이는 방어자가 <strong>장기적인 탐지 포인트</strong>로 활용할 수 있습니다.</p><p><strong>기술적 사례:</strong> Amadey의 한 변종을 메모리 덤프해 분석한 연구에 따르면, <strong>고유한 함수 호출 시퀀스</strong>들이 드러났습니다. 예컨데 아래와 같은 x86 명령어 흐름은 Amadey에서 일관되게 등장하는 루틴입니다.</p><p>// Amadey 메모리 덤프에서 추출된 코드 시퀀스 (예시)<br>$sequence_0 = { 89 45 F4 83 7D F4 08 74 4F 8D 85 E8 FD FF FF 89 04 24 E8 ?? ?? ?? ?? C7 04 24 ?? ?? ?? ?? }</p><p>이 패턴을 디스어셈블리해보면, <strong>지역 변수 값을 비교하여 분기</strong>하고 <strong>메모리 버퍼를 할당해 특정 함수로 호출</strong>하는 논리가 드러납니다 (예: mov [ebp-0xC], eax; cmp [ebp-0xC], 8; je &mldr;; lea eax, [ebp-0x218]; &mldr;)<a href=https://www.cloudsek.com/blog/amadey-equipped-with-av-disabler-drops-redline-stealer>[15]</a>. 이처럼 복잡한 바이트열도 결국 <strong>특정 기능을 수행하는 코드의 모습</strong>을 하고 있으며, Amadey 계열에서는 변종 간에도 유사한 제어 흐름을 보여 탐지에 응용되었습니다<a href=https://www.cloudsek.com/blog/amadey-equipped-with-av-disabler-drops-redline-stealer>[16]</a><a href="https://www.cloudsek.com/blog/amadey-equipped-with-av-disabler-drops-redline-stealer#:~:text=%2F%2F%20%20%20c70424%3F%3F%3F%3F%3F%3F%3F%3F%20,">[17]</a>. 공격자가 이를 우회하려면 내부 알고리즘 자체를 바꾸는 수준의 개편이 필요하지만, 그러면 악성코드의 신뢰성과 개발 비용 문제가 생기므로 쉽지 않습니다. 결국 **메모리 상에 드러나는 이러한 실행 invariant는 공격자 입장에서 “어쩔 수 없이 노출되는 약점”**인 셈입니다.</p><h2 id=yara-룰을-통한-메모리-기반-탐지-효율성과-일반화-가능성>YARA 룰을 통한 메모리 기반 탐지 효율성과 일반화 가능성<a hidden class=anchor aria-hidden=true href=#yara-룰을-통한-메모리-기반-탐지-효율성과-일반화-가능성>#</a></h2><p>메모리 기반 탐지를 실제 수동으로 수행하는 것은 어렵기 때문에, <strong>YARA 룰</strong>과 같은 패턴 매칭 도구가 널리 활용됩니다. YARA는 <strong>텍스트/바이너리 패턴을 정의하여 악성코드 군을 식별</strong>할 수 있는 유연한 규칙 언어로, <strong>정적 검사뿐 아니라 메모리 덤프나 프로세스 메모리</strong>에도 적용 가능합니다<a href="https://inventivehq.com/blog/why-hash-lookup-fails-against-polymorphic-malware#:~:text=Memory,rather%20than%20the%20encrypted%20dropper">[4]</a><a href="https://inventivehq.com/blog/why-hash-lookup-fails-against-polymorphic-malware#:~:text=YARA%20,code%20patterns%2C%20strings%2C%20or%20structures">[18]</a>. 특히 YARA는 해시 매칭보다 일반화된 패턴을 사용하므로, <strong>폴리모픽 변종에 대응한 invariant 탐지</strong>에 유용합니다<a href="https://inventivehq.com/blog/why-hash-lookup-fails-against-polymorphic-malware#:~:text=For%20polymorphic%20malware%2C%20YARA%20rules,positives%20across%20entire%20malware%20families">[9]</a>.</p><p><strong>메모리 기반 YARA 탐지의 효율성</strong>은 <strong>높은 탐지율과 낮은 오탐율</strong>로 나타납니다. 잘 설계된 YARA 룰은 <strong>한 악성코드 패밀리의 다양한 샘플을 아울러 식별</strong>할 수 있습니다<a href="https://inventivehq.com/blog/why-hash-lookup-fails-against-polymorphic-malware#:~:text=For%20polymorphic%20malware%2C%20YARA%20rules,positives%20across%20entire%20malware%20families">[9]</a>. 예를 들어 CloudSEK 연구진이 공개한 Amadey 탐지 YARA 룰을 보면, 디스크 상의 <strong>“MZ” 헤더</strong> 확인 이후 <strong>Amadey 전용 PDB 경로 문자열 또는 복호화 키 패턴</strong>을 찾는 조건으로 구성되어 있어, 패킹이 풀린 Amadey라면 변종에 상관없이 탐지될 수 있게 했습니다<a href="https://www.cloudsek.com/blog/amadey-equipped-with-av-disabler-drops-redline-stealer#:~:text=strings%3A%20%24pdb%20%20%3D%20,9%5D%7B32%7D%5Cx00">[7]</a><a href="https://www.cloudsek.com/blog/amadey-equipped-with-av-disabler-drops-redline-stealer#:~:text=uint16,">[19]</a>. 이는 <strong>정적 탐지</strong>에 해당하는 룰이지만, 실질적으로 Amadey의 **핵심 정체성(내부 모듈명, 키 패턴)**을 노렸기 때문에 일종의 invariant 탐지로 볼 수 있습니다. 나아가 <strong>YARA-Signator</strong> 같은 도구는 <strong>메모리 덤프나 언팩된 파일의 디스어셈블리에서 고유한 바이트 시퀀스를 자동 추출</strong>하여 YARA 룰을 생성해줍니다<a href="https://www.cloudsek.com/blog/amadey-equipped-with-av-disabler-drops-redline-stealer#:~:text=%2F,also%20into%20consideration%20when%20you">[20]</a>. 이렇게 생성된 룰은 <strong>API 호출, 제어 흐름, 상수 데이터 참조 패턴</strong>을 포함하므로, 간단한 바이트 치환 난독화로는 회피하기 어렵습니다<a href=https://www.cloudsek.com/blog/amadey-equipped-with-av-disabler-drops-redline-stealer>[15][21]</a>. 실제로 YARA-Signator 기반 Amadey 룰에는 5~7개의 명령어로 이루어진 시퀀스 여러 개가 strings로 정의되어, Amadey 변종 코드에서 반복 출현하는 <strong>고유 시그니처</strong>로 사용되었습니다<a href=https://www.cloudsek.com/blog/amadey-equipped-with-av-disabler-drops-redline-stealer>[16]</a><a href="https://www.cloudsek.com/blog/amadey-equipped-with-av-disabler-drops-redline-stealer#:~:text=%24sequence_3%20%3D%20,esp%2C%200x424">[22]</a>.</p><p><strong>일반화 가능성</strong> 측면에서, 메모리 기반 탐지 룰은 <strong>얼마나 보편적인 invariant를 포착했는지에 따라 범용성</strong>이 결정됩니다. 한편으로, <strong>너무 특정 샘플에 맞춘 메모리 패턴</strong>은 변종이 약간만 바뀌어도 놓칠 수 있습니다. 예컨대 YARA-Signator 제작자는 “Malpedia에 수록된 단일 샘플 기반으로 생성된 규칙은 일반화 수준에 한계가 있을 수 있다”라고 언급하였는데<a href="https://www.cloudsek.com/blog/amadey-equipped-with-av-disabler-drops-redline-stealer#:~:text=,and%20assign%20them%20confidence%20levels">[23]</a>, 이는 곧 <strong>메모리 탐지 룰도 지속적인 업데이트와 검증이 필요</strong>함을 시사합니다. 실제 현장에서 메모리 YARA를 설계할 때는 <strong>여러 변종의 메모리 공통 덤프를 비교하여 일치하는 패턴</strong>을 추출하거나, <strong>악성 행위 자체를 나타내는 문자열/코드 조합</strong>을 선택하는 식으로 <strong>포괄성을 높이는 전략</strong>이 요구됩니다. 다행히 Amadey나 RedLine 같은 상용 악성코드는 한 시점의 버전에서 핵심 로직이 크게 변하지 않으므로, <strong>한두 개 룰로도 수많은 변종을 커버</strong>하는 높은 효율을 보입니다<a href="https://inventivehq.com/blog/why-hash-lookup-fails-against-polymorphic-malware#:~:text=For%20polymorphic%20malware%2C%20YARA%20rules,positives%20across%20entire%20malware%20families">[9]</a>. 예를 들어 앞서 소개한 RedLine 탐지 YARA에서는 8개의 문자열 조건 중 6개만 일치하면 변종을 <strong>악성</strong>으로 분류하는데, 이로써 <strong>경로 문자열, 함수명, 프로토콜, DB 파일명</strong> 등 다양한 특징을 조합하여 오탐을 낮추면서 웬만한 변종은 모두 탐지하는 일반화 효과를 거두고 있습니다<a href="https://amr-git-dot.github.io/malware%20analysis/RedLineStealer/#:~:text=%24string4%20%3D%20">[10]</a><a href="https://amr-git-dot.github.io/malware%20analysis/RedLineStealer/#:~:text=condition%3A%20,">[24]</a>.</p><p>물론 <strong>과도한 일반화는 오탐 위험</strong>을 높일 수 있으므로, 메모리 YARA 룰은 <strong>특정 악성 행위에만 나타나는 패턴</strong>인지 <strong>정상 소프트웨어에도 있을 수 있는지</strong>를 고려해야 합니다. 이를 위해 메모리 기반 YARA는 종종 <strong>프로세스 컨텍스트 조건</strong>이나 <strong>사이즈 제한</strong> 등을 추가합니다. 예를 들어 Mandiant가 공개한 메모리 전용 다운로더 <strong>PEAKLIGHT</strong> 탐지 YARA에서는, PowerShell 스크립트 내부에서만 나타날 법한 구문 패턴 7개 중 4개 이상 발견되고 <strong>스크립트 크기가 10KB 미만</strong>일 때 룰이 매칭되도록 조건을 걸었습니다<a href="https://cloud.google.com/blog/ko/topics/threat-intelligence/peaklight-decoding-stealthy-memory-only-malware?hl=ko#:~:text=strings%3A%20%24str1%20%3D%20%2Ffunction%5Cs,ascii%20wide%20%24str6">[25]</a><a href="https://cloud.google.com/blog/ko/topics/threat-intelligence/peaklight-decoding-stealthy-memory-only-malware?hl=ko#:~:text=%24str7%20%3D%20%22Add%20,10KB">[26]</a>. 이런 추가 조건은 일반화된 패턴이라도 <strong>특정 악성 시나리오에만 반응</strong>하게 만들어 탐지 정확도를 높입니다.</p><p>아래 표는 <strong>정적 서명 탐지와 메모리 기반 탐지의 비교</strong>를 요약한 것입니다:</p><table><thead><tr><th style=text-align:left>탐지 방식</th><th style=text-align:left>장점</th><th style=text-align:left>단점</th><th style=text-align:left>회피 난이도</th></tr></thead><tbody><tr><td style=text-align:left><strong>정적 탐지</strong> (파일 기준)</td><td style=text-align:left>빠른 검사, 알려진 서명 정확 탐지</td><td style=text-align:left>패킹/암호화에 취약, 새로운 해시/서명 누락 위험</td><td style=text-align:left>낮음 (패커로 쉽게 우회 가능)</td></tr><tr><td style=text-align:left><strong>메모리 기반 탐지</strong></td><td style=text-align:left>난독화 우회 가능 (복호화된 실제 코드 탐지),<br>실행 행위 기반 탐지 (파일리스 공격 탐지)</td><td style=text-align:left>실시간 메모리 스캔 오버헤드,<br>전문 도구 필요</td><td style=text-align:left>높음 (코드 로직 자체 변경 필요)</td></tr></tbody></table><p>위 표에서 보듯 정적 탐지는 우회 난이도가 낮아 Amadey처럼 <strong>간단한 문자열 인코딩만으로도 우회를 허용</strong>하지만<a href="https://www.splunk.com/en_us/blog/security/amadey-threat-analysis-and-detections.html#:~:text=This%20malware%20uses%20two%20layers,followed%20by%20a%20Base64%20algorithm">[1]</a>, 메모리 탐지는 <strong>코드 내부 알고리즘까지 바꾸지 않는 이상 피하기 어려운 높은 난이도</strong>를 공격자에게 요구합니다. 따라서 YARA와 같은 규칙 기반 도구를 활용한 메모리 탐지는 <strong>효율성과 일반화 면에서 현대 악성코드 대응에 효과적</strong>이며, 실제로 많은 보안 업체들이 <strong>샌드박스 실행 후 메모리 스캔</strong>을 통해 가족별 악성코드를 식별하는 기법을 활용하고 있습니다<a href="https://inventivehq.com/blog/why-hash-lookup-fails-against-polymorphic-malware#:~:text=Memory,rather%20than%20the%20encrypted%20dropper">[4]</a><a href="https://inventivehq.com/blog/why-hash-lookup-fails-against-polymorphic-malware#:~:text=Effective%20protection%20against%20polymorphic%20malware,family%20patterns%20spanning%20multiple%20variants">[27]</a>.</p><h2 id=악성코드-패밀리-간-메모리-수렴성-비교-amadey-vs-redline-vs-formbook-vs-smokeloader>악성코드 패밀리 간 메모리 <strong>수렴성</strong> 비교 (Amadey vs. RedLine vs. FormBook vs. SmokeLoader)<a hidden class=anchor aria-hidden=true href=#악성코드-패밀리-간-메모리-수렴성-비교-amadey-vs-redline-vs-formbook-vs-smokeloader>#</a></h2><p>이제 Amadey 외에 다른 악성코드 패밀리에서도 **유사한 메모리 수렴성(공통 패턴)**이 나타나는지 살펴보겠습니다. <strong>메모리 수렴성</strong>이란 각기 다른 변종들이 <strong>최종적으로 메모리상에서 비슷한 형태나 동작을 보이는 현상</strong>을 말합니다. 이는 해당 악성코드 패밀리가 수행하는 고유 악성행위가 비슷하기 때문에 생기는 현상으로 볼 수 있습니다.</p><ul><li><p><strong>Amadey (트로이목마/로더)</strong> – 앞서 분석한 대로 <strong>주요 문자열 복호화 루틴과 키 패턴, Mutex 생성, C2 통신 스레드 생성 코드</strong> 등이 메모리에서 일관되게 나타납니다<a href="https://www.cloudsek.com/blog/amadey-equipped-with-av-disabler-drops-redline-stealer#:~:text=strings%3A%20%24pdb%20%20%3D%20,9%5D%7B32%7D%5Cx00">[7]</a><a href="https://www.splunk.com/en_us/blog/security/amadey-threat-analysis-and-detections.html#:~:text=It%20also%20creates%20a%20mutex,the%20compromised%20or%20targeted%20host">[28]</a>. Amadey는 <strong>MaaS 봇넷</strong>으로써 시스템 정보 수집 후 다수 추가 페이로드를 <strong>다운로드</strong>하는 것이 주 임무이므로, <strong>HTTP POST로 시스템 정보를 보내는 루틴</strong>(예: OS 버전, 사용자명 등을 문자열로 조합해 전송) 또한 변종에 상관없이 메모리에 공통 구현되어 있습니다<a href="https://www.splunk.com/en_us/blog/security/amadey-threat-analysis-and-detections.html#:~:text=Amadey%20will%20execute%202%20threads,Amadey%20and%20its%20C2%20infrastructure">[29]</a><a href="https://www.splunk.com/en_us/blog/security/amadey-threat-analysis-and-detections.html#:~:text=Amadey%20compiles%20the%20gathered%20information,information%20of%20the%20compromised%20host">[30]</a>. 즉 <strong>네트워크 통신 구조, 문자열 디코딩</strong> 등에서 메모리 수렴성이 높습니다.</p></li><li><p><strong>RedLine (정보탈취형 스틸러)</strong> – 러시아 해커 포럼에서 판매되는 유명 정보탈취 악성코드로, <strong>웹 브라우저 저장 비밀번호, 자동완성 데이터, 암호화폐 지갑 정보</strong> 등을 훔칩니다<a href="https://malpedia.caad.fkie.fraunhofer.de/details/win.redline_stealer#:~:text=RedLine%20Stealer%20is%20a%20malware,send%20back%20information%20about%20the">[31]</a>. RedLine은 종종 .NET으로 개발되어 <strong>런타임 시 어셈블리를 로드</strong>하거나 <strong>자체 보호를 위해 난독화</strong>되지만, 메모리상에서는 <strong>브라우저 프로파일 경로, SQLite 쿠키 DB 경로 (“cookies.sqlite”), 탈취 대상 애플리케이션 리스트</strong> 등의 문자열이 <strong>평문으로 드러납니다<a href="https://amr-git-dot.github.io/malware%20analysis/RedLineStealer/#:~:text=%24string5%20%3D%20">[32]</a></strong>. 또한 <strong>FTP/IM 클라이언트 명칭, 암호화폐 지갑 키워드</strong> 등도 탈취 대상에 따라 하드코딩되어 있어, 이러한 값들이 메모리에서 invariant로 검출됩니다. RedLine의 경우 다양한 버전이 등장해도 **탈취 대상과 방법(예: 파일 경로 열람, 시스템 정보 수집)**이 유사하기에, 메모리 수렴성이 높아 하나의 YARA 룰로도 여러 버전을 검출한 사례가 있습니다<a href="https://amr-git-dot.github.io/malware%20analysis/RedLineStealer/#:~:text=%24string6%20%3D%20">[33]</a>.</p></li><li><p><strong>FormBook (정보탈취형/로더)</strong> – FormBook은 <strong>프로세스 인젝션</strong>에 특화된 고유한 <strong>런패킹(run-PE) 크립터</strong>를 사용하는 것으로 유명합니다<a href="https://malpedia.caad.fkie.fraunhofer.de/details/win.formbook#:~:text=FormBook%20contains%20a%20unique%20crypter,by%20Insidemalware">[34]</a>. 이 **“Babushka Crypter”**는 여러 계층으로 페이로드를 암호화한 뒤 최종 페이로드를 <strong>다른 프로세스 메모리에 실행</strong>시키는데, 이 과정에서 메모리에 <strong>일정한 패턴</strong>이 나타납니다. 예를 들어 <strong>자신을 CreateProcess로 실행한 후 대상 프로세스 메모리에 PE 헤더를 쓰고 섹션을 복사한 뒤 OEP로 점프</strong>하는 코드 흐름은 FormBook 계열에 공통된 invariant입니다. 해당 루틴은 <strong>메모리 상에서 DLL 스톰핑/인젝션에 수반되는 API 호출</strong> (예: VirtualAllocEx, WriteProcessMemory, SetThreadContext, ResumeThread 등) 패턴으로 식별할 수 있습니다. 실제로 이 <strong>Babushka 인젝터의 행위 패턴</strong>은 유명해서, 시큐리티 연구자들이 <strong>FormBook류를 식별하는 YARA룰</strong>에도 이를 반영하고 있습니다<a href="https://malpedia.caad.fkie.fraunhofer.de/details/win.formbook#:~:text=FormBook%20contains%20a%20unique%20crypter,by%20Insidemalware">[34]</a>. 정리하면 FormBook 계열은 <strong>다층 암호화를 거치지만 결국 메모리상에서 나타나는 인젝션 행위는 유사하게 수렴</strong>합니다.</p></li><li><p><strong>SmokeLoader (로더)</strong> – 2011년부터 활동한 오래된 로더 악성코드인 SmokeLoader 역시 <strong>파일 최소화 및 메모리 로딩</strong> 전략을 씁니다. 최신 SmokeLoader 변종은 **“stager”**라는 전단계 모듈이 <strong>자신을 난독화하고 분석 방해</strong>를 한 뒤, <strong>주된 악성 모듈을 explorer.exe 프로세스 메모리에 인젝션</strong>하는 구조를 가집니다<a href="https://thehackernews.com/2025/09/weekly-recap-chrome-0-day-ai-hacking.html#:~:text=consists%20of%20two%20main%20components%3A,service%20attacks%2C%20and%20mining%20cryptocurrency">[35]</a>. 이때 <strong>메모리 내부에서는</strong> 항상 <strong>explorer 프로세스의 메모리에 존재하지만 PE 이미지상 디스크에는 없는 모듈</strong>이 발견되는 공통 특징이 있습니다. 따라서 <strong>메모리 포렌식으로 explorer 등에 비정상적으로 로드된 코드 영역</strong>을 찾으면 SmokeLoader를 식별할 수 있습니다. 또한 SmokeLoader 메인 모듈은 <strong>영구성 확보(레지스트리 Run키 등록 등), C2 비콘 통신, 추가 모듈 로드</strong> 등의 기능을 수행하는데<a href="https://thehackernews.com/2025/09/weekly-recap-chrome-0-day-ai-hacking.html#:~:text=detect%20virtual%20environments%20,startup">[36]</a>, 이러한 행위도 변종마다 유사해서 <strong>메모리상 API 호출 시퀀스</strong> (예: <strong>자신을 시작 프로그램에 복제, 원격 서버에 주기적 접속</strong>)가 수렴성을 보입니다. SmokeLoader는 2024년 당국 단속으로 일시 중단되었다 2025년에 <strong>프로토콜만 변경된 채 부활</strong>할 정도로 코어 로직이 유지되었고<a href="https://thehackernews.com/2025/09/weekly-recap-chrome-0-day-ai-hacking.html#:~:text=,and%20inject%20the">[37]</a>, 이는 메모리 기반 탐지 측면에서 과거 룰을 업데이트하여 계속 탐지할 수 있음을 의미합니다.</p></li></ul><p>위 사례들을 종합하면, <strong>Amadey, RedLine, FormBook, SmokeLoader와 같은 악성코드 패밀리들은 각기 전파 방식이나 세부 구현은 달라도 “메모리 상에서 드러나는 핵심 악성 행위” 측면에서 일정한 수렴성을 보인다</strong>는 것을 알 수 있습니다. 이는 곧 <strong>메모리 기반 탐지 전략이 한 패밀리에 대해 마련되면 유사 변종뿐 아니라 동족 악성에도 응용</strong>될 수 있다는 전망을 줍니다. 예를 들어 <strong>Loader류 악성코드 전반</strong>의 공통 메모리 특징(프로세스 할로잉, 코드 인젝션 패턴 등)을 일반화한 YARA 룰을 만들어두면, 새로운 로더 악성코드가 등장해도 상당 부분 탐지 커버리지가 확보될 수 있습니다. 이처럼 <strong>메모리 invariant에 주목한 탐지</strong>는 <strong>서로 다른 악성코드 패밀리 간의 교차 탐지</strong>도 어느 정도 가능하게 해주며, 궁극적으로 <strong>일반화된 방어</strong>를 구현하는 데 기여합니다<a href="https://inventivehq.com/blog/why-hash-lookup-fails-against-polymorphic-malware#:~:text=For%20polymorphic%20malware%2C%20YARA%20rules,positives%20across%20entire%20malware%20families">[9]</a>.</p><h2 id=공격자의-회피-시도와-그-비용-성능-및-개발-복잡도>공격자의 회피 시도와 그 비용 (성능 및 개발 복잡도)<a hidden class=anchor aria-hidden=true href=#공격자의-회피-시도와-그-비용-성능-및-개발-복잡도>#</a></h2><p>메모리 기반 탐지가 효과적이므로, 역으로 공격자는 이를 <strong>무력화하기 위한 시도</strong>를 할 수 있습니다. 그러나 앞서 논의했듯 이러한 시도에는 상당한 **비용(cost)**이 따릅니다. 주요 회피 방안과 그 한계를 살펴보면 다음과 같습니다:</p><ul><li><p><strong>코드 메타모픽 변형</strong> – 공격자는 <strong>메타모픽 엔진</strong>을 도입하여 <strong>실행될 때마다 코드 자체를 재구성</strong>하도록 만들 수 있습니다. 예컨대 같은 기능을 매번 다른 명령어와 순서로 구현하거나<a href="https://inventivehq.com/blog/why-hash-lookup-fails-against-polymorphic-malware#:~:text=For%20example%2C%20a%20code%20sequence,sequences%2C%20evading%20signature%20matching%20entirely">[12]</a>, 무작위로 레지스터 할당을 바꾸고 더미 코드를 삽입하는 등의 기법입니다. 이렇게 하면 변종마다 메모리 상 기계어 패턴이 달라져 <strong>정형화된 YARA 시그니처로 잡기 어려워질 수 있습니다</strong>. 하지만 이 접근은 개발 난이도가 가장 높습니다. <strong>동등한 기능 구현을 위한 다양한 코드패스 생성</strong>에는 복잡한 컴파일러 수준의 로직이 필요하고, 잘못하면 코드 버그나 충돌이 발생할 수 있습니다<a href="https://inventivehq.com/blog/why-hash-lookup-fails-against-polymorphic-malware#:~:text=Where%20polymorphic%20malware%20encrypts%20or,encrypted%20payload%20exists%20across%20variants">[11]</a><a href="https://inventivehq.com/blog/why-hash-lookup-fails-against-polymorphic-malware#:~:text=direct%20addition%20in%20one%20variant%2C,sequences%2C%20evading%20signature%20matching%20entirely">[38]</a>. 또한 이렇게 생성된 코드가 <strong>항상 의도대로 동작하는지 검증</strong>하기 어렵고, 새로운 안티바이러스 진단을 유발할 가능성도 있습니다. <strong>일반적인 공격자 입장</strong>에서 메타모픽 기능을 지속적으로 유지보수하는 것은 비용 부담이 커서, 역사적으로도 고도화된 바이러스나 APT 멀웨어 일부에만 제한적으로 사용되었습니다<a href="https://inventivehq.com/blog/why-hash-lookup-fails-against-polymorphic-malware#:~:text=The%20Emotet%20banking%20Trojan%2C%20one,detection%20becomes%20obsolete%20within%20hours">[3]</a><a href="https://inventivehq.com/blog/why-hash-lookup-fails-against-polymorphic-malware#:~:text=Nation,based%20detection%20and%20cataloging">[39]</a>.</p></li><li><p><strong>코드 지속 암/복호화 (메모리 상 암호화)</strong> – 또 다른 방법은 악성코드가 <strong>자기 자신의 코드를 실행 중에도 암호화된 형태로 유지</strong>하고, <strong>필요한 순간에만 복호화하여 잠시 실행</strong>한 뒤 다시 메모리에서 지우는 것입니다. 이를테면 특정 함수 호출 직전에 해당 코드 부분을 복호화하고 실행한 후 즉시 메모리에서 제거하거나 다시 암호화하는 방식입니다. 이러면 메모리 스캔 시점에 따라 악성 패턴이 안 잡힐 수 있습니다. 그러나 이 역시 성능상의 문제가 큽니다. 매 함수나 루프마다 복호화/암호화 연산을 하면 <strong>CPU 사용량이 늘고 실행 속도가 저하</strong>됩니다. 특히 실시간으로 메모리를 지웠다가 다시 할당하는 작업은 <strong>레지던트 악성코드의 효율성을 떨어뜨리고 오류 발생 가능성</strong>을 높입니다. 그리고 EDR 솔루션들은 <strong>메모리 할당/보호 속성 변화를 후킹</strong>하여 추적하기 때문에, 이러한 시도도 완전한 은폐책은 되지 못합니다 (예: <strong>RWX 메모리 영역 생성과 삭제 빈도가 비정상적이면 경고</strong>). 따라서 공격자가 이런 기법을 도입하면 <strong>자신의 악성코드가 느려지고 불안정해지는 비용</strong>을 감수해야 합니다.</p></li><li><p><strong>가상머신/인터프리터 내 실행</strong> – 일부 고급 회피기법으로, <strong>악성 페이로드를 자체 가상 머신 바이트코드로 변환</strong>한 뒤 메모리에 <strong>가상 머신 인터프리터만 올려서 동작</strong>하게 만드는 방법이 있습니다. 이 경우 메모리에는 인터프리터만 존재하고 실제 악성 행위는 가상 머신 안에서 해석되므로, 겉보기에는 패턴이 안 드러날 수 있습니다. 그러나 <strong>인터프리터 자체가 새로운 패턴</strong>이 되므로 이것도 장기적으로는 탐지 가능해집니다. 수십 KB 이상의 VM 해석기 코드가 메모리에 상주하면 오히려 <strong>특이한 메모리 특징</strong>이 되어 EDR에 탐지될 수 있고, 해당 VM의 명령 집합을 리버스 엔지니어링 당하면 결국 더 강인한 서명이 만들어집니다. 또한 VM을 사용하면 <strong>명령어 처리 오버헤드로 실행 성능이 저하</strong>됩니다. 공격자는 이러한 <strong>복잡한 커스텀 VM 개발과 유지보수 부담</strong>을 져야 하며, 이는 일반 금융정보 탈취나 로더 목적의 악성코드로서는 과투자에 가깝습니다.</p></li><li><p><strong>기타 회피 기법</strong> – <strong>안티 메모리 스캔</strong> 기술로, 자신을 디버거로 위장해 <strong>OpenProcess로 메모리 읽기를 차단</strong>하거나, <strong>페이지 권한을 교묘히 설정</strong>하여 접근하면 크래시를 유발하는 식의 방어도 이론적으로 가능합니다. 하지만 이를 구현하면 <strong>정상 동작에 지장</strong>을 줄 수 있고, 윈도우 API 후킹 등으로 충분히 우회당할 수 있습니다. 또한 <strong>EDR과의 치킨게임</strong> 양상이 되어, 방어 측에서도 커널 드라이버 등을 통해 더욱 강제적인 메모리 검사 기법을 적용할 수 있습니다. 일반적으로 공격자가 취하는 현실적인 회피는 <strong>최대한 패킹과 난독화를 강화</strong>하고, <strong>지속적으로 변종을 만들어 정적 IOC 수명을 단축</strong>시키는 정도에 그칩니다<a href="https://inventivehq.com/blog/why-hash-lookup-fails-against-polymorphic-malware#:~:text=Why%20Hash%20Databases%20Can%27t%20Keep,Up">[40]</a><a href="https://inventivehq.com/blog/why-hash-lookup-fails-against-polymorphic-malware#:~:text=evade%20detection%20entirely%2C%20infecting%20organizations,before%20protective%20signatures%20exist">[41]</a>. 메모리 단계까지 신경 쓰는 공격자는 극소수이며, 그런 경우에도 위에서 논의한 대가를 치르게 마련입니다.</p></li></ul><p><strong>결론적으로</strong>, 공격자가 <strong>메모리 기반 탐지를 완전히 따돌리려면</strong> <strong>개발 복잡도</strong>나 <strong>운영 안정성 측면에서 막대한 비용</strong>을 감수해야 합니다. 이는 방어자에게 유리한 지형을 만들어줍니다. <strong>메모리상의 invariant를 노린 탐지 전략은 단기간에 무력화되기 어렵고, 설령 공격자가 대응하더라도 그 부담은 공격자 측에 전가</strong>됩니다. 예컨대 Amadey 제작자가 탐지를 피하려고 핵심 코드 흐름을 전면 수정하면, 그 기간 동안 서비스가 원활히 운영되기 힘들 것이고, 오히려 눈에 띄는 변화로 보안 커뮤니티에 포착될 가능성이 높습니다. 따라서 <strong>메모리 기반 탐지</strong>는 <strong>장기적으로 유효한 방어 수단</strong>으로 평가됩니다. 실제로 <strong>다계층 보안 체계</strong>에서는 정적, 동적, 행위 기반 탐지와 함께 <strong>메모리 포렌식 기반 탐지</strong>를 조합하여 활용함으로써, 신종 위협에 대한 종합적인 대응력을 높이고 있습니다<a href="https://inventivehq.com/blog/why-hash-lookup-fails-against-polymorphic-malware#:~:text=Implementing%20Defense">[42]</a><a href="https://inventivehq.com/blog/why-hash-lookup-fails-against-polymorphic-malware#:~:text=Sandboxing%20reveals%20runtime%20behavior%20through,on%20any%20single%20detection%20mechanism">[43]</a>. Amadey를 비롯한 여러 악성코드 사례 분석을 통해 보았듯이, <strong>메모리에는 거짓말이 없으며(runtime doesn’t lie)</strong>, 이 점이 방어자가 끝까지 악성코드의 실체를 밝히는 열쇠가 될 것입니다.</p><h2 id=참고-자료-references>참고 자료 (References)<a hidden class=anchor aria-hidden=true href=#참고-자료-references>#</a></h2><ul><li><p>【1】 Splunk Threat Research Team – <em>“Amadey Threat Analysis and Detections”</em> (2023)<a href="https://www.splunk.com/en_us/blog/security/amadey-threat-analysis-and-detections.html#:~:text=This%20malware%20uses%20two%20layers,followed%20by%20a%20Base64%20algorithm">[1]</a><a href="https://www.splunk.com/en_us/blog/security/amadey-threat-analysis-and-detections.html#:~:text=Amadey%20will%20execute%202%20threads,Amadey%20and%20its%20C2%20infrastructure">[29]</a></p></li><li><p>【6】 CloudSEK Research – <em>“Amadey with AV Disabler drops RedLine – YARA rules”</em> (2023)<a href="https://www.cloudsek.com/blog/amadey-equipped-with-av-disabler-drops-redline-stealer#:~:text=strings%3A%20%24pdb%20%20%3D%20,9%5D%7B32%7D%5Cx00">[7]</a><a href="https://www.cloudsek.com/blog/amadey-equipped-with-av-disabler-drops-redline-stealer#:~:text=%2F,also%20into%20consideration%20when%20you">[20]</a></p></li><li><p>【11】 InventiveHQ – <em>“Why Hash Lookup Fails Against Polymorphic Malware (Memory-Based Detection)”</em> (2026)<a href="https://inventivehq.com/blog/why-hash-lookup-fails-against-polymorphic-malware#:~:text=Memory,rather%20than%20the%20encrypted%20dropper">[4]</a><a href="https://inventivehq.com/blog/why-hash-lookup-fails-against-polymorphic-malware#:~:text=Process%20hollowing%20detection%20identifies%20when,based%20evasion%20tactics">[5]</a></p></li><li><p>【13】 InventiveHQ – <em>동일 출처 상동</em><a href="https://inventivehq.com/blog/why-hash-lookup-fails-against-polymorphic-malware#:~:text=Memory,rather%20than%20the%20encrypted%20dropper">[4]</a><a href="https://inventivehq.com/blog/why-hash-lookup-fails-against-polymorphic-malware#:~:text=Process%20hollowing%20detection%20identifies%20when,DLL%20injection%2C%20code%20cave%20utilization">[44]</a></p></li><li><p>【29】 Amr Ashraf – <em>“RedLine Stealer Analysis – YARA rule”</em> (2023)<a href="https://amr-git-dot.github.io/malware%20analysis/RedLineStealer/#:~:text=%24string5%20%3D%20">[32]</a><a href="https://amr-git-dot.github.io/malware%20analysis/RedLineStealer/#:~:text=%24string6%20%3D%20">[33]</a></p></li><li><p>【14】 Malpedia – <em>“Formbook – unique RunPE crypter behavior”</em><a href="https://malpedia.caad.fkie.fraunhofer.de/details/win.formbook#:~:text=FormBook%20contains%20a%20unique%20crypter,by%20Insidemalware">[34]</a></p></li><li><p>【34】 TheHackerNews – <em>“SmokeLoader Returns with New Changes”</em> (2025)<a href="https://thehackernews.com/2025/09/weekly-recap-chrome-0-day-ai-hacking.html#:~:text=consists%20of%20two%20main%20components%3A,service%20attacks%2C%20and%20mining%20cryptocurrency">[35]</a><a href="https://thehackernews.com/2025/09/weekly-recap-chrome-0-day-ai-hacking.html#:~:text=,and%20inject%20the">[37]</a></p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://windshock.github.io/ko/tags/%EC%95%85%EC%84%B1%EC%BD%94%EB%93%9C/>악성코드</a></li><li><a href=https://windshock.github.io/ko/tags/amadey/>Amadey</a></li><li><a href=https://windshock.github.io/ko/tags/%EC%A0%95%EC%A0%81-%EB%B6%84%EC%84%9D/>정적 분석</a></li><li><a href=https://windshock.github.io/ko/tags/%EB%A9%94%EB%AA%A8%EB%A6%AC-%ED%8F%AC%EB%A0%8C%EC%8B%9D/>메모리 포렌식</a></li><li><a href=https://windshock.github.io/ko/tags/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B8%B0%EB%B0%98-%ED%83%90%EC%A7%80/>메모리 기반 탐지</a></li><li><a href=https://windshock.github.io/ko/tags/yara/>YARA</a></li><li><a href=https://windshock.github.io/ko/tags/edr/>EDR</a></li></ul><nav class=paginav><a class=next href=https://windshock.github.io/ko/post/2025-12-29-visibility-changes-behavior/><span class=title>다음 페이지 »</span><br><span>내부 취약점 현황 공개가 보안 조치율에 미치는 심리·행동적 효과</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Amadey 악성코드: 정적 탐지 vs 메모리 기반 탐지 비교 연구 on x" href="https://x.com/intent/tweet/?text=Amadey%20%ec%95%85%ec%84%b1%ec%bd%94%eb%93%9c%3a%20%ec%a0%95%ec%a0%81%20%ed%83%90%ec%a7%80%20vs%20%eb%a9%94%eb%aa%a8%eb%a6%ac%20%ea%b8%b0%eb%b0%98%20%ed%83%90%ec%a7%80%20%eb%b9%84%ea%b5%90%20%ec%97%b0%ea%b5%ac&amp;url=https%3a%2f%2fwindshock.github.io%2fko%2fpost%2f2026-01-07-amadey-static-vs-memory-detection%2f&amp;hashtags=%ec%95%85%ec%84%b1%ec%bd%94%eb%93%9c%2cAmadey%2c%ec%a0%95%ec%a0%81%eb%b6%84%ec%84%9d%2c%eb%a9%94%eb%aa%a8%eb%a6%ac%ed%8f%ac%eb%a0%8c%ec%8b%9d%2c%eb%a9%94%eb%aa%a8%eb%a6%ac%ea%b8%b0%eb%b0%98%ed%83%90%ec%a7%80%2cYARA%2cEDR"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Amadey 악성코드: 정적 탐지 vs 메모리 기반 탐지 비교 연구 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fwindshock.github.io%2fko%2fpost%2f2026-01-07-amadey-static-vs-memory-detection%2f&amp;title=Amadey%20%ec%95%85%ec%84%b1%ec%bd%94%eb%93%9c%3a%20%ec%a0%95%ec%a0%81%20%ed%83%90%ec%a7%80%20vs%20%eb%a9%94%eb%aa%a8%eb%a6%ac%20%ea%b8%b0%eb%b0%98%20%ed%83%90%ec%a7%80%20%eb%b9%84%ea%b5%90%20%ec%97%b0%ea%b5%ac&amp;summary=Amadey%20%ec%95%85%ec%84%b1%ec%bd%94%eb%93%9c%3a%20%ec%a0%95%ec%a0%81%20%ed%83%90%ec%a7%80%20vs%20%eb%a9%94%eb%aa%a8%eb%a6%ac%20%ea%b8%b0%eb%b0%98%20%ed%83%90%ec%a7%80%20%eb%b9%84%ea%b5%90%20%ec%97%b0%ea%b5%ac&amp;source=https%3a%2f%2fwindshock.github.io%2fko%2fpost%2f2026-01-07-amadey-static-vs-memory-detection%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Amadey 악성코드: 정적 탐지 vs 메모리 기반 탐지 비교 연구 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwindshock.github.io%2fko%2fpost%2f2026-01-07-amadey-static-vs-memory-detection%2f&title=Amadey%20%ec%95%85%ec%84%b1%ec%bd%94%eb%93%9c%3a%20%ec%a0%95%ec%a0%81%20%ed%83%90%ec%a7%80%20vs%20%eb%a9%94%eb%aa%a8%eb%a6%ac%20%ea%b8%b0%eb%b0%98%20%ed%83%90%ec%a7%80%20%eb%b9%84%ea%b5%90%20%ec%97%b0%ea%b5%ac"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Amadey 악성코드: 정적 탐지 vs 메모리 기반 탐지 비교 연구 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwindshock.github.io%2fko%2fpost%2f2026-01-07-amadey-static-vs-memory-detection%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Amadey 악성코드: 정적 탐지 vs 메모리 기반 탐지 비교 연구 on whatsapp" href="https://api.whatsapp.com/send?text=Amadey%20%ec%95%85%ec%84%b1%ec%bd%94%eb%93%9c%3a%20%ec%a0%95%ec%a0%81%20%ed%83%90%ec%a7%80%20vs%20%eb%a9%94%eb%aa%a8%eb%a6%ac%20%ea%b8%b0%eb%b0%98%20%ed%83%90%ec%a7%80%20%eb%b9%84%ea%b5%90%20%ec%97%b0%ea%b5%ac%20-%20https%3a%2f%2fwindshock.github.io%2fko%2fpost%2f2026-01-07-amadey-static-vs-memory-detection%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Amadey 악성코드: 정적 탐지 vs 메모리 기반 탐지 비교 연구 on telegram" href="https://telegram.me/share/url?text=Amadey%20%ec%95%85%ec%84%b1%ec%bd%94%eb%93%9c%3a%20%ec%a0%95%ec%a0%81%20%ed%83%90%ec%a7%80%20vs%20%eb%a9%94%eb%aa%a8%eb%a6%ac%20%ea%b8%b0%eb%b0%98%20%ed%83%90%ec%a7%80%20%eb%b9%84%ea%b5%90%20%ec%97%b0%ea%b5%ac&amp;url=https%3a%2f%2fwindshock.github.io%2fko%2fpost%2f2026-01-07-amadey-static-vs-memory-detection%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Amadey 악성코드: 정적 탐지 vs 메모리 기반 탐지 비교 연구 on ycombinator" href="https://news.ycombinator.com/submitlink?t=Amadey%20%ec%95%85%ec%84%b1%ec%bd%94%eb%93%9c%3a%20%ec%a0%95%ec%a0%81%20%ed%83%90%ec%a7%80%20vs%20%eb%a9%94%eb%aa%a8%eb%a6%ac%20%ea%b8%b0%eb%b0%98%20%ed%83%90%ec%a7%80%20%eb%b9%84%ea%b5%90%20%ec%97%b0%ea%b5%ac&u=https%3a%2f%2fwindshock.github.io%2fko%2fpost%2f2026-01-07-amadey-static-vs-memory-detection%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://windshock.github.io/ko/>Code Before Breach</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>function loadGiscus(e){document.querySelectorAll('.giscus-frame, script[src*="giscus.app"]').forEach(e=>e.remove());const t=document.createElement("script");t.src="https://giscus.app/client.js",t.setAttribute("data-repo","windshock/windshock.github.io"),t.setAttribute("data-repo-id","MDEwOlJlcG9zaXRvcnkxODQ2MDMyMTk="),t.setAttribute("data-category","General"),t.setAttribute("data-category-id","DIC_kwDOCwDSU84CoqLg"),t.setAttribute("data-mapping","pathname"),t.setAttribute("data-reactions-enabled","1"),t.setAttribute("data-theme",e),t.setAttribute("data-lang","en"),t.setAttribute("data-input-position","bottom"),t.setAttribute("data-loading","lazy"),t.crossOrigin="anonymous",t.async=!0,document.body.appendChild(t)}const currentTheme=document.body.classList.contains("dark")?"dark":"light";loadGiscus(currentTheme);const observer=new MutationObserver(()=>{const e=document.body.classList.contains("dark")?"dark":"light";loadGiscus(e)});observer.observe(document.body,{attributes:!0,attributeFilter:["class"]})</script><script>function initSwiperIfNeeded(){if(typeof Swiper=="undefined")return setTimeout(initSwiperIfNeeded,50);document.querySelector(".swiper")?(new Swiper(".swiper",{slidesPerView:1.2,spaceBetween:16,loop:!0,preloadImages:!1,lazy:{loadOnTransitionStart:!0,loadPrevNext:!0},pagination:{el:".swiper-pagination",clickable:!0},breakpoints:{768:{slidesPerView:2.5},1024:{slidesPerView:3.2}}}),document.querySelectorAll("img.swiper-lazy").forEach(e=>{e.src=e.dataset.src})):setTimeout(initSwiperIfNeeded,100)}initSwiperIfNeeded()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="복사";function s(){t.innerHTML="복사 완료!",setTimeout(()=>{t.innerHTML="복사"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>